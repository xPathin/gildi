{
    "language": "Solidity",
    "sources": {
        "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {ERC1155Utils} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155\n    struct ERC1155Storage {\n        mapping(uint256 id => mapping(address account => uint256)) _balances;\n\n        mapping(address account => mapping(address operator => bool)) _operatorApprovals;\n\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n        string _uri;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;\n\n    function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {\n        assembly {\n            $.slot := ERC1155StorageLocation\n        }\n    }\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._uri;\n    }\n\n    /// @inheritdoc IERC1155\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /// @inheritdoc IERC1155\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC1155\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._operatorApprovals[account][operator];\n    }\n\n    /// @inheritdoc IERC1155\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /// @inheritdoc IERC1155\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        address sender = _msgSender();\n        if (from != sender && !isApprovedForAll(from, sender)) {\n            revert ERC1155MissingApprovalForAll(sender, from);\n        }\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = $._balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    $._balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                $._balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (ids.length == 1) {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\n            } else {\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        $._uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        assembly (\"memory-safe\") {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {PausableUpgradeable} from \"../../../utils/PausableUpgradeable.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {\n    function __ERC1155Pausable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC1155-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override whenNotPaused {\n        super._update(from, to, ids, values);\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n *\n * NOTE: This contract implies a global limit of 2**256 - 1 to the number of tokens\n * that can be minted.\n *\n * CAUTION: This extension should not be added in an upgrade to an already deployed contract.\n */\nabstract contract ERC1155SupplyUpgradeable is Initializable, ERC1155Upgradeable {\n    using Arrays for uint256[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155Supply\n    struct ERC1155SupplyStorage {\n        mapping(uint256 id => uint256) _totalSupply;\n        uint256 _totalSupplyAll;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155Supply\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155SupplyStorageLocation = 0x4a593662ee04d27b6a00ebb31be7fe0c102c2ade82a7c5d764f2df05dc4e2800;\n\n    function _getERC1155SupplyStorage() private pure returns (ERC1155SupplyStorage storage $) {\n        assembly {\n            $.slot := ERC1155SupplyStorageLocation\n        }\n    }\n\n    function __ERC1155Supply_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Supply_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Total value of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        return $._totalSupply[id];\n    }\n\n    /**\n     * @dev Total value of tokens.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        return $._totalSupplyAll;\n    }\n\n    /**\n     * @dev Indicates whether any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return totalSupply(id) > 0;\n    }\n\n    /// @inheritdoc ERC1155Upgradeable\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        super._update(from, to, ids, values);\n\n        if (from == address(0)) {\n            uint256 totalMintValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n                // Overflow check required: The rest of the code assumes that totalSupply never overflows\n                $._totalSupply[ids.unsafeMemoryAccess(i)] += value;\n                totalMintValue += value;\n            }\n            // Overflow check required: The rest of the code assumes that totalSupplyAll never overflows\n            $._totalSupplyAll += totalMintValue;\n        }\n\n        if (to == address(0)) {\n            uint256 totalBurnValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n\n                unchecked {\n                    // Overflow not possible: values[i] <= balanceOf(from, ids[i]) <= totalSupply(ids[i])\n                    $._totalSupply[ids.unsafeMemoryAccess(i)] -= value;\n                    // Overflow not possible: sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                    totalBurnValue += value;\n                }\n            }\n            unchecked {\n                // Overflow not possible: totalBurnValue = sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                $._totalSupplyAll -= totalBurnValue;\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155HolderUpgradeable is Initializable, ERC165Upgradeable, IERC1155Receiver {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function __Pausable_init() internal onlyInitializing {\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/AccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/IAccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
        },
        "@openzeppelin/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
        },
        "@openzeppelin/contracts/interfaces/IERC1363.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
        },
        "@openzeppelin/contracts/interfaces/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
        },
        "@openzeppelin/contracts/interfaces/IERC1967.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity >=0.4.11;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
        },
        "@openzeppelin/contracts/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
        },
        "@openzeppelin/contracts/interfaces/IERC5267.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5267.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
        },
        "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n"
        },
        "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
        },
        "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.21;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/proxy/Proxy.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC1155} from \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
        },
        "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\nimport {IERC1155Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-1155 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\n *\n * _Available since v5.1._\n */\nlibrary ERC1155Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155Received(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155Receiver-onERC1155BatchReceived}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC1155BatchReceived(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    // Tokens rejected\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC1155Receiver implementer\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(reason, 0x20), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
        },
        "@openzeppelin/contracts/utils/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Arrays.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytesSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getStringSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(string[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Comparators.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly (\"memory-safe\") {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    // slither-disable-next-line constable-states\n    string private _nameFallback;\n    // slither-disable-next-line constable-states\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.\n     */\n    function toDataWithIntendedValidatorHash(\n        address validator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, hex\"19_00\")\n            mstore(0x02, shl(96, validator))\n            mstore(0x16, messageHash)\n            digest := keccak256(0x00, 0x36)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Errors.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
        },
        "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "@openzeppelin/contracts/utils/math/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/math/SafeCast.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/math/SignedMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Nonces.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Panic.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/ShortStrings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        assembly (\"memory-safe\") {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {toShortStringWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {toShortStringWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/SlotDerivation.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/StorageSlot.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n * - Map can be cleared (all entries removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n * - `uint256 -> bytes32` (`UintToBytes32Map`) since v5.1.0\n * - `address -> address` (`AddressToAddressMap`) since v5.1.0\n * - `address -> bytes32` (`AddressToBytes32Map`) since v5.1.0\n * - `bytes32 -> address` (`Bytes32ToAddressMap`) since v5.1.0\n * - `bytes -> bytes` (`BytesToBytesMap`) since v5.4.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for *;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32ToBytes32Map storage map) internal {\n        uint256 len = length(map);\n        for (uint256 i = 0; i < len; ++i) {\n            delete map._values[map._keys.at(i)];\n        }\n        map._keys.clear();\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32 key, bytes32 value) {\n        bytes32 atKey = map._keys.at(index);\n        return (atKey, map._values[atKey]);\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool exists, bytes32 value) {\n        bytes32 val = map._values[key];\n        if (val == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, val);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        Bytes32ToBytes32Map storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes32[] memory) {\n        return map._keys.values(start, end);\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(UintToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256 key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), uint256(val));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(UintToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256 key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToBytes32Map\n\n    struct UintToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToBytes32Map storage map, uint256 key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToBytes32Map storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(UintToBytes32Map storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToBytes32Map storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToBytes32Map storage map, uint256 index) internal view returns (uint256 key, bytes32 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (uint256(atKey), val);\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToBytes32Map storage map, uint256 key) internal view returns (bool exists, bytes32 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(key));\n        return (success, val);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToBytes32Map storage map, uint256 key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToBytes32Map storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToBytes32Map storage map, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(AddressToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), uint256(val));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map, uint256 start, uint256 end) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToAddressMap\n\n    struct AddressToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToAddressMap storage map, address key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(AddressToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToAddressMap storage map, uint256 index) internal view returns (address key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToAddressMap storage map, address key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToAddressMap storage map, address key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(uint256(uint160(key)))))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        AddressToAddressMap storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToBytes32Map\n\n    struct AddressToBytes32Map {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToBytes32Map storage map, address key, bytes32 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), value);\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(AddressToBytes32Map storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToBytes32Map storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToBytes32Map storage map, uint256 index) internal view returns (address key, bytes32 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (address(uint160(uint256(atKey))), val);\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToBytes32Map storage map, address key) internal view returns (bool exists, bytes32 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, val);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToBytes32Map storage map, address key) internal view returns (bytes32) {\n        return get(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        AddressToBytes32Map storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(Bytes32ToUintMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32 key, uint256 value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (atKey, uint256(val));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool exists, uint256 value) {\n        (bool success, bytes32 val) = tryGet(map._inner, key);\n        return (success, uint256(val));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToAddressMap\n\n    struct Bytes32ToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToAddressMap storage map, bytes32 key, address value) internal returns (bool) {\n        return set(map._inner, key, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with map size. Developers should keep in mind that\n     * using it may render the function uncallable if the map grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function clear(Bytes32ToAddressMap storage map) internal {\n        clear(map._inner);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToAddressMap storage map, uint256 index) internal view returns (bytes32 key, address value) {\n        (bytes32 atKey, bytes32 val) = at(map._inner, index);\n        return (atKey, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool exists, address value) {\n        (bool success, bytes32 val) = tryGet(map._inner, key);\n        return (success, address(uint160(uint256(val))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, key))));\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(\n        Bytes32ToAddressMap storage map,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentBytesKey(bytes key);\n\n    struct BytesToBytesMap {\n        // Storage of keys\n        EnumerableSet.BytesSet _keys;\n        mapping(bytes key => bytes) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(BytesToBytesMap storage map, bytes memory key, bytes memory value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(BytesToBytesMap storage map, bytes memory key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Removes all the entries from a map. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the map grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(BytesToBytesMap storage map) internal {\n        uint256 len = length(map);\n        for (uint256 i = 0; i < len; ++i) {\n            delete map._values[map._keys.at(i)];\n        }\n        map._keys.clear();\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(BytesToBytesMap storage map, bytes memory key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(BytesToBytesMap storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        BytesToBytesMap storage map,\n        uint256 index\n    ) internal view returns (bytes memory key, bytes memory value) {\n        key = map._keys.at(index);\n        value = map._values[key];\n    }\n\n    /**\n     * @dev Tries to return the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(\n        BytesToBytesMap storage map,\n        bytes memory key\n    ) internal view returns (bool exists, bytes memory value) {\n        value = map._values[key];\n        exists = bytes(value).length != 0 || contains(map, key);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(BytesToBytesMap storage map, bytes memory key) internal view returns (bytes memory value) {\n        bool exists;\n        (exists, value) = tryGet(map, key);\n        if (!exists) {\n            revert EnumerableMapNonexistentBytesKey(key);\n        }\n    }\n\n    /**\n     * @dev Returns an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(BytesToBytesMap storage map) internal view returns (bytes[] memory) {\n        return map._keys.values();\n    }\n\n    /**\n     * @dev Returns an array containing a slice of the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(BytesToBytesMap storage map, uint256 start, uint256 end) internal view returns (bytes[] memory) {\n        return map._keys.values(start, end);\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\nimport {Arrays} from \"../Arrays.sol\";\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n * - Set can be cleared (all elements removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * The following types are supported:\n *\n * - `bytes32` (`Bytes32Set`) since v3.3.0\n * - `address` (`AddressSet`) since v3.3.0\n * - `uint256` (`UintSet`) since v3.3.0\n * - `string` (`StringSet`) since v5.4.0\n * - `bytes` (`BytesSet`) since v5.4.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with set size. Developers should keep in mind that\n     * using it may render the function uncallable if the set grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function _clear(Set storage set) private {\n        uint256 len = _length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set, uint256 start, uint256 end) private view returns (bytes32[] memory) {\n        unchecked {\n            end = Math.min(end, _length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes32[] memory result = new bytes32[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32Set storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    struct StringSet {\n        // Storage of set values\n        string[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(string value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(StringSet storage set, string memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(StringSet storage set, string memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                string memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(StringSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(StringSet storage set, string memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(StringSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(StringSet storage set, uint256 index) internal view returns (string memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set) internal view returns (string[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set, uint256 start, uint256 end) internal view returns (string[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            string[] memory result = new string[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    struct BytesSet {\n        // Storage of set values\n        bytes[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(BytesSet storage set, bytes memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(BytesSet storage set, bytes memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(BytesSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(BytesSet storage set, bytes memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(BytesSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(BytesSet storage set, uint256 index) internal view returns (bytes memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set) internal view returns (bytes[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set, uint256 start, uint256 end) internal view returns (bytes[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes[] memory result = new bytes[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/IERC20Minimal.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
        },
        "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/BitMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/LiquidityMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/SafeCast.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"
        },
        "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
        },
        "@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
        },
        "contracts/external/uniswap/v3/periphery/Multicall.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol';\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
        },
        "contracts/external/uniswap/v3/quoter/UniswapV3ViewQuoter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {IUniswapV3ViewQuoter} from '../../../../interfaces/external/uniswap/v3/quoter/IUniswapV3ViewQuoter.sol';\nimport {PoolAddress} from '../../../../libraries/external/uniswap/v3/quoter/PoolAddress.sol';\nimport {QuoterMath} from '../../../../libraries/external/uniswap/v3/quoter/QuoterMath.sol';\nimport {TickMath} from '../../../../libraries/external/uniswap/v3/core/TickMath.sol';\nimport {Path} from '../../../../libraries/external/uniswap/v3/periphery/Path.sol';\nimport {IUniswapV3Pool} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {LowGasSafeMath} from '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\nimport {SafeCast} from '@uniswap/v3-core/contracts/libraries/SafeCast.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title UniswapV3ViewQuoter Contract\n/// @notice A contract that provides quotes for swaps in Uniswap V3 pools\n/// @author Gildi Company\ncontract UniswapV3ViewQuoter is IUniswapV3ViewQuoter, Initializable {\n    using QuoterMath for *;\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Path for bytes;\n\n    // The v3 factory address\n    address public factory;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract.\n    /// @param _factory The Uniswap V3 factory address.\n    function initialize(address _factory) public initializer {\n        factory = _factory;\n    }\n\n    /// @dev Returns the pool address for the given token pair and fee\n    /// @param _tokenA First token in the pair\n    /// @param _tokenB Second token in the pair\n    /// @param _fee Fee tier for the pool\n    /// @return pool The address of the Uniswap V3 pool\n    function getPoolAddress(address _tokenA, address _tokenB, uint24 _fee) private view returns (address pool) {\n        pool = PoolAddress.computePoolAddress(factory, PoolAddress.getPoolKey(_tokenA, _tokenB, _fee));\n    }\n\n    /// @inheritdoc IUniswapV3ViewQuoter\n    function quoteExactInputSingleWithPool(\n        QuoteExactInputSingleWithPoolParams memory params\n    ) public view override returns (uint256 amountReceived, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed) {\n        int256 amount0;\n        int256 amount1;\n\n        bool zeroForOne = params.tokenIn < params.tokenOut;\n        IUniswapV3Pool pool = IUniswapV3Pool(params.pool);\n\n        // we need to pack a few variables to get under the stack limit\n        QuoterMath.QuoteParams memory quoteParams = QuoterMath.QuoteParams({\n            zeroForOne: zeroForOne,\n            fee: params.fee,\n            sqrtPriceLimitX96: params.sqrtPriceLimitX96 == 0\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : params.sqrtPriceLimitX96,\n            exactInput: false\n        });\n\n        (amount0, amount1, sqrtPriceX96After, initializedTicksCrossed) = QuoterMath.quote(\n            pool,\n            params.amountIn.toInt256(),\n            quoteParams\n        );\n\n        amountReceived = amount0 > 0 ? uint256(-amount1) : uint256(-amount0);\n    }\n\n    /// @inheritdoc IUniswapV3ViewQuoter\n    function quoteExactInputSingle(\n        QuoteExactInputSingleParams memory _params\n    ) public view override returns (uint256 amountReceived, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed) {\n        address poolAddress = getPoolAddress(_params.tokenIn, _params.tokenOut, _params.fee);\n\n        QuoteExactInputSingleWithPoolParams memory poolParams = QuoteExactInputSingleWithPoolParams({\n            tokenIn: _params.tokenIn,\n            tokenOut: _params.tokenOut,\n            amountIn: _params.amountIn,\n            fee: _params.fee,\n            pool: poolAddress,\n            sqrtPriceLimitX96: 0\n        });\n\n        (amountReceived, sqrtPriceX96After, initializedTicksCrossed) = quoteExactInputSingleWithPool(poolParams);\n    }\n\n    /// @inheritdoc IUniswapV3ViewQuoter\n    function quoteExactInput(\n        bytes memory _path,\n        uint256 _amountIn\n    )\n        public\n        view\n        override\n        returns (uint256 amountOut, uint160[] memory sqrtPriceX96AfterList, uint32[] memory initializedTicksCrossedList)\n    {\n        sqrtPriceX96AfterList = new uint160[](_path.numPools());\n        initializedTicksCrossedList = new uint32[](_path.numPools());\n\n        uint256 i = 0;\n        while (true) {\n            (address tokenIn, address tokenOut, uint24 fee) = _path.decodeFirstPool();\n            (uint256 _amountOut, uint160 _sqrtPriceX96After, uint32 initializedTicksCrossed) = quoteExactInputSingle(\n                QuoteExactInputSingleParams({\n                    tokenIn: tokenIn,\n                    tokenOut: tokenOut,\n                    fee: fee,\n                    amountIn: _amountIn,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n            sqrtPriceX96AfterList[i] = _sqrtPriceX96After;\n            initializedTicksCrossedList[i] = initializedTicksCrossed;\n            _amountIn = _amountOut;\n            i++;\n\n            if (_path.hasMultiplePools()) {\n                _path = _path.skipToken();\n            } else {\n                return (_amountIn, sqrtPriceX96AfterList, initializedTicksCrossedList);\n            }\n        }\n    }\n\n    /// @inheritdoc IUniswapV3ViewQuoter\n    function quoteExactOutputSingleWithPool(\n        QuoteExactOutputSingleWithPoolParams memory _params\n    ) public view override returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed) {\n        int256 amount0;\n        int256 amount1;\n        uint256 amountReceived;\n\n        bool zeroForOne = _params.tokenIn < _params.tokenOut;\n        IUniswapV3Pool pool = IUniswapV3Pool(_params.pool);\n\n        QuoterMath.QuoteParams memory quoteParams = QuoterMath.QuoteParams({\n            zeroForOne: zeroForOne,\n            exactInput: true, // will be overridden\n            fee: _params.fee,\n            sqrtPriceLimitX96: _params.sqrtPriceLimitX96 == 0\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\n                : _params.sqrtPriceLimitX96\n        });\n\n        (amount0, amount1, sqrtPriceX96After, initializedTicksCrossed) = QuoterMath.quote(\n            pool,\n            -(_params.amount.toInt256()),\n            quoteParams\n        );\n\n        amountIn = amount0 > 0 ? uint256(amount0) : uint256(amount1);\n        amountReceived = amount0 > 0 ? uint256(-amount1) : uint256(-amount0);\n    }\n\n    /// @inheritdoc IUniswapV3ViewQuoter\n    function quoteExactOutputSingle(\n        QuoteExactOutputSingleParams memory _params\n    ) public view override returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed) {\n        address poolAddress = getPoolAddress(_params.tokenIn, _params.tokenOut, _params.fee);\n\n        QuoteExactOutputSingleWithPoolParams memory poolParams = QuoteExactOutputSingleWithPoolParams({\n            tokenIn: _params.tokenIn,\n            tokenOut: _params.tokenOut,\n            amount: _params.amount,\n            fee: _params.fee,\n            pool: poolAddress,\n            sqrtPriceLimitX96: 0\n        });\n\n        (amountIn, sqrtPriceX96After, initializedTicksCrossed) = quoteExactOutputSingleWithPool(poolParams);\n    }\n\n    /// @inheritdoc IUniswapV3ViewQuoter\n    function quoteExactOutput(\n        bytes memory _path,\n        uint256 _amountOut\n    )\n        public\n        view\n        override\n        returns (uint256 amountIn, uint160[] memory sqrtPriceX96AfterList, uint32[] memory initializedTicksCrossedList)\n    {\n        sqrtPriceX96AfterList = new uint160[](_path.numPools());\n        initializedTicksCrossedList = new uint32[](_path.numPools());\n\n        uint256 i = 0;\n        while (true) {\n            (address tokenOut, address tokenIn, uint24 fee) = _path.decodeFirstPool();\n\n            (uint256 _amountIn, uint160 _sqrtPriceX96After, uint32 _initializedTicksCrossed) = quoteExactOutputSingle(\n                QuoteExactOutputSingleParams({\n                    tokenIn: tokenIn,\n                    tokenOut: tokenOut,\n                    amount: _amountOut,\n                    fee: fee,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n            sqrtPriceX96AfterList[i] = _sqrtPriceX96After;\n            initializedTicksCrossedList[i] = _initializedTicksCrossed;\n            _amountOut = _amountIn;\n            i++;\n\n            if (_path.hasMultiplePools()) {\n                _path = _path.skipToken();\n            } else {\n                return (_amountOut, sqrtPriceX96AfterList, initializedTicksCrossedList);\n            }\n        }\n    }\n}\n"
        },
        "contracts/external/uniswap/v3/staker/UniswapV3Staker.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.24;\n\nimport '../../../../interfaces/external/uniswap/v3/staker/IUniswapV3Staker.sol';\nimport '../../../../libraries/external/uniswap/v3/staker/IncentiveId.sol';\nimport '../../../../libraries/external/uniswap/v3/staker/RewardMath.sol';\nimport '../../../../libraries/external/uniswap/v3/staker/NFTPositionInfo.sol';\nimport '../../../../libraries/external/uniswap/v3/staker/TransferHelperExtended.sol';\nimport '../../../../external/uniswap/v3/periphery/Multicall.sol';\n\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IERC20Minimal.sol';\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title Uniswap V3 canonical staking interface\ncontract UniswapV3Staker is IUniswapV3Staker, Multicall, Initializable {\n    /// @notice Represents a staking incentive\n    struct Incentive {\n        uint256 totalRewardUnclaimed;\n        uint160 totalSecondsClaimedX128;\n        uint96 numberOfStakes;\n    }\n\n    /// @notice Represents the deposit of a liquidity NFT\n    struct Deposit {\n        address owner;\n        uint48 numberOfStakes;\n        int24 tickLower;\n        int24 tickUpper;\n    }\n\n    /// @notice Represents a staked liquidity NFT\n    struct Stake {\n        uint160 secondsPerLiquidityInsideInitialX128;\n        uint96 liquidityNoOverflow;\n        uint128 liquidityIfOverflow;\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    IUniswapV3Factory public factory;\n    /// @inheritdoc IUniswapV3Staker\n    INonfungiblePositionManager public nonfungiblePositionManager;\n\n    /// @inheritdoc IUniswapV3Staker\n    uint256 public maxIncentiveStartLeadTime;\n    /// @inheritdoc IUniswapV3Staker\n    uint256 public maxIncentiveDuration;\n\n    /// @dev bytes32 refers to the return value of IncentiveId.compute\n    mapping(bytes32 => Incentive) public incentives;\n\n    /// @dev deposits[tokenId] => Deposit\n    mapping(uint256 => Deposit) public deposits;\n\n    /// @dev stakes[tokenId][incentiveHash] => Stake\n    mapping(uint256 => mapping(bytes32 => Stake)) private _stakes;\n\n    /// @inheritdoc IUniswapV3Staker\n    function stakes(\n        uint256 tokenId,\n        bytes32 incentiveId\n    ) public view override returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) {\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        secondsPerLiquidityInsideInitialX128 = stake.secondsPerLiquidityInsideInitialX128;\n        liquidity = stake.liquidityNoOverflow;\n        if (liquidity == type(uint96).max) {\n            liquidity = stake.liquidityIfOverflow;\n        }\n    }\n\n    /// @dev rewards[rewardToken][owner] => uint256\n    mapping(IERC20Minimal => mapping(address => uint256)) public rewards;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract.\n    /// @param _factory the Uniswap V3 factory\n    /// @param _nonfungiblePositionManager the NFT position manager contract address\n    /// @param _maxIncentiveStartLeadTime the max duration of an incentive in seconds\n    /// @param _maxIncentiveDuration the max amount of seconds into the future the incentive startTime can be set\n    function initialize(\n        IUniswapV3Factory _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        uint256 _maxIncentiveStartLeadTime,\n        uint256 _maxIncentiveDuration\n    ) public initializer {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        maxIncentiveStartLeadTime = _maxIncentiveStartLeadTime;\n        maxIncentiveDuration = _maxIncentiveDuration;\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function createIncentive(IncentiveKey memory key, uint256 reward) external override {\n        require(reward > 0, 'UniswapV3Staker::createIncentive: reward must be positive');\n        require(\n            block.timestamp <= key.startTime,\n            'UniswapV3Staker::createIncentive: start time must be now or in the future'\n        );\n        require(\n            key.startTime - block.timestamp <= maxIncentiveStartLeadTime,\n            'UniswapV3Staker::createIncentive: start time is too far into future'\n        );\n        require(key.startTime < key.endTime, 'UniswapV3Staker::createIncentive: start time must be before end time');\n        require(\n            key.endTime - key.startTime <= maxIncentiveDuration,\n            'UniswapV3Staker::createIncentive: incentive duration is too long'\n        );\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        TransferHelperExtended.safeTransferFrom(address(key.rewardToken), msg.sender, address(this), reward);\n\n        emit IncentiveCreated(key.rewardToken, key.pool, key.startTime, key.endTime, key.refundee, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function endIncentive(IncentiveKey memory key) external override returns (uint256 refund) {\n        require(block.timestamp >= key.endTime, 'UniswapV3Staker::endIncentive: cannot end incentive before end time');\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        Incentive storage incentive = incentives[incentiveId];\n\n        refund = incentive.totalRewardUnclaimed;\n\n        require(refund > 0, 'UniswapV3Staker::endIncentive: no refund available');\n        require(\n            incentive.numberOfStakes == 0,\n            'UniswapV3Staker::endIncentive: cannot end incentive while deposits are staked'\n        );\n\n        // issue the refund\n        incentive.totalRewardUnclaimed = 0;\n        TransferHelperExtended.safeTransfer(address(key.rewardToken), key.refundee, refund);\n\n        // note we never clear totalSecondsClaimedX128\n\n        emit IncentiveEnded(incentiveId, refund);\n    }\n\n    /// @notice Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`. Also stakes token\n    /// in one or more incentives if properly formatted `data` has a length > 0.\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(\n            msg.sender == address(nonfungiblePositionManager),\n            'UniswapV3Staker::onERC721Received: not a univ3 nft'\n        );\n\n        (, , , , , int24 tickLower, int24 tickUpper, , , , , ) = nonfungiblePositionManager.positions(tokenId);\n\n        deposits[tokenId] = Deposit({owner: from, numberOfStakes: 0, tickLower: tickLower, tickUpper: tickUpper});\n        emit DepositTransferred(tokenId, address(0), from);\n\n        if (data.length > 0) {\n            if (data.length == 160) {\n                _stakeToken(abi.decode(data, (IncentiveKey)), tokenId);\n            } else {\n                IncentiveKey[] memory keys = abi.decode(data, (IncentiveKey[]));\n                for (uint256 i = 0; i < keys.length; i++) {\n                    _stakeToken(keys[i], tokenId);\n                }\n            }\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function transferDeposit(uint256 tokenId, address to) external override {\n        require(to != address(0), 'UniswapV3Staker::transferDeposit: invalid transfer recipient');\n        address owner = deposits[tokenId].owner;\n        require(owner == msg.sender, 'UniswapV3Staker::transferDeposit: can only be called by deposit owner');\n        deposits[tokenId].owner = to;\n        emit DepositTransferred(tokenId, owner, to);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function withdrawToken(uint256 tokenId, address to, bytes memory data) external override {\n        require(to != address(this), 'UniswapV3Staker::withdrawToken: cannot withdraw to staker');\n        Deposit memory deposit = deposits[tokenId];\n        require(deposit.numberOfStakes == 0, 'UniswapV3Staker::withdrawToken: cannot withdraw token while staked');\n        require(deposit.owner == msg.sender, 'UniswapV3Staker::withdrawToken: only owner can withdraw token');\n\n        delete deposits[tokenId];\n        emit DepositTransferred(tokenId, deposit.owner, address(0));\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function stakeToken(IncentiveKey memory key, uint256 tokenId) external override {\n        require(deposits[tokenId].owner == msg.sender, 'UniswapV3Staker::stakeToken: only owner can stake token');\n\n        _stakeToken(key, tokenId);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function unstakeToken(IncentiveKey memory key, uint256 tokenId) external override {\n        Deposit memory deposit = deposits[tokenId];\n        // anyone can call unstakeToken if the block time is after the end time of the incentive\n        if (block.timestamp < key.endTime) {\n            require(\n                deposit.owner == msg.sender,\n                'UniswapV3Staker::unstakeToken: only owner can withdraw token before incentive end time'\n            );\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) = stakes(tokenId, incentiveId);\n\n        require(liquidity != 0, 'UniswapV3Staker::unstakeToken: stake does not exist');\n\n        Incentive storage incentive = incentives[incentiveId];\n\n        deposits[tokenId].numberOfStakes--;\n        incentive.numberOfStakes--;\n\n        (, uint160 secondsPerLiquidityInsideX128, ) = key.pool.snapshotCumulativesInside(\n            deposit.tickLower,\n            deposit.tickUpper\n        );\n        (uint256 reward, uint160 secondsInsideX128) = RewardMath.computeRewardAmount(\n            incentive.totalRewardUnclaimed,\n            incentive.totalSecondsClaimedX128,\n            key.startTime,\n            key.endTime,\n            liquidity,\n            secondsPerLiquidityInsideInitialX128,\n            secondsPerLiquidityInsideX128,\n            block.timestamp\n        );\n\n        // if this overflows, e.g. after 2^32-1 full liquidity seconds have been claimed,\n        // reward rate will fall drastically so it's safe\n        incentive.totalSecondsClaimedX128 += secondsInsideX128;\n        // reward is never greater than total reward unclaimed\n        incentive.totalRewardUnclaimed -= reward;\n        // this only overflows if a token has a total supply greater than type(uint256).max\n        rewards[key.rewardToken][deposit.owner] += reward;\n\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        delete stake.secondsPerLiquidityInsideInitialX128;\n        delete stake.liquidityNoOverflow;\n        if (liquidity >= type(uint96).max) delete stake.liquidityIfOverflow;\n        emit TokenUnstaked(tokenId, incentiveId);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function claimReward(\n        IERC20Minimal rewardToken,\n        address to,\n        uint256 amountRequested\n    ) external override returns (uint256 reward) {\n        reward = rewards[rewardToken][msg.sender];\n        if (amountRequested != 0 && amountRequested < reward) {\n            reward = amountRequested;\n        }\n\n        rewards[rewardToken][msg.sender] -= reward;\n        TransferHelperExtended.safeTransfer(address(rewardToken), to, reward);\n\n        emit RewardClaimed(to, reward);\n    }\n\n    /// @inheritdoc IUniswapV3Staker\n    function getRewardInfo(\n        IncentiveKey memory key,\n        uint256 tokenId\n    ) external view override returns (uint256 reward, uint160 secondsInsideX128) {\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) = stakes(tokenId, incentiveId);\n        require(liquidity > 0, 'UniswapV3Staker::getRewardInfo: stake does not exist');\n\n        Deposit memory deposit = deposits[tokenId];\n        Incentive memory incentive = incentives[incentiveId];\n\n        (, uint160 secondsPerLiquidityInsideX128, ) = key.pool.snapshotCumulativesInside(\n            deposit.tickLower,\n            deposit.tickUpper\n        );\n\n        (reward, secondsInsideX128) = RewardMath.computeRewardAmount(\n            incentive.totalRewardUnclaimed,\n            incentive.totalSecondsClaimedX128,\n            key.startTime,\n            key.endTime,\n            liquidity,\n            secondsPerLiquidityInsideInitialX128,\n            secondsPerLiquidityInsideX128,\n            block.timestamp\n        );\n    }\n\n    /// @dev Stakes a deposited token without doing an ownership check\n    function _stakeToken(IncentiveKey memory key, uint256 tokenId) private {\n        require(block.timestamp >= key.startTime, 'UniswapV3Staker::stakeToken: incentive not started');\n        require(block.timestamp < key.endTime, 'UniswapV3Staker::stakeToken: incentive ended');\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        require(\n            incentives[incentiveId].totalRewardUnclaimed > 0,\n            'UniswapV3Staker::stakeToken: non-existent incentive'\n        );\n        require(\n            _stakes[tokenId][incentiveId].liquidityNoOverflow == 0,\n            'UniswapV3Staker::stakeToken: token already staked'\n        );\n\n        (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) = NFTPositionInfo.getPositionInfo(\n            factory,\n            nonfungiblePositionManager,\n            tokenId\n        );\n\n        require(pool == key.pool, 'UniswapV3Staker::stakeToken: token pool is not the incentive pool');\n        require(liquidity > 0, 'UniswapV3Staker::stakeToken: cannot stake token with 0 liquidity');\n\n        deposits[tokenId].numberOfStakes++;\n        incentives[incentiveId].numberOfStakes++;\n\n        (, uint160 secondsPerLiquidityInsideX128, ) = pool.snapshotCumulativesInside(tickLower, tickUpper);\n\n        if (liquidity >= type(uint96).max) {\n            _stakes[tokenId][incentiveId] = Stake({\n                secondsPerLiquidityInsideInitialX128: secondsPerLiquidityInsideX128,\n                liquidityNoOverflow: type(uint96).max,\n                liquidityIfOverflow: liquidity\n            });\n        } else {\n            Stake storage stake = _stakes[tokenId][incentiveId];\n            stake.secondsPerLiquidityInsideInitialX128 = secondsPerLiquidityInsideX128;\n            stake.liquidityNoOverflow = uint96(liquidity);\n        }\n\n        emit TokenStaked(tokenId, incentiveId, liquidity);\n    }\n}\n"
        },
        "contracts/interfaces/external/IUniswapV2Factory.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
        },
        "contracts/interfaces/external/IUniswapV2Pair.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
        },
        "contracts/interfaces/external/IUniswapV2Router01.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
        },
        "contracts/interfaces/external/IUniswapV2Router02.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
        },
        "contracts/interfaces/external/IWNative.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity >=0.5.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @title Wrapped Native Token Interface\n/// @notice Interface for wrapped native tokens (e.g., WETH, WPOL) that can wrap/unwrap native currency\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IWNative is IERC20 {\n    /// @notice Deposit native currency and receive wrapped tokens\n    /// @dev Mints wrapped tokens equivalent to the native currency sent\n    function deposit() external payable;\n    \n    /// @notice Withdraw wrapped tokens and receive native currency\n    /// @dev Burns wrapped tokens and sends equivalent native currency to caller\n    /// @param amount The amount of wrapped tokens to withdraw\n    function withdraw(uint256 amount) external;\n}\n"
        },
        "contracts/interfaces/external/uniswap/v3/INonfungiblePositionManager.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity ^0.8.0;\n\n/// ERC721Metadata\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface INonfungiblePositionManager is IERC721Metadata {\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(\n        MintParams calldata params\n    ) external payable returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to achieve resulting liquidity\n    /// @return amount1 The amount of token1 to achieve resulting liquidity\n    function increaseLiquidity(\n        IncreaseLiquidityParams calldata params\n    ) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1);\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(\n        DecreaseLiquidityParams calldata params\n    ) external payable returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Returns the address of the WETH9 contract\n    /// @return The address of WETH9\n    function WETH9() external view returns (address);\n\n    /// @notice Returns the address of the factory\n    /// @return The address of the factory\n    function factory() external view returns (address);\n\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be called if the pool does not exist to create the pool and also initializes\n    /// the pool if it has not been initialized\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"
        },
        "contracts/interfaces/external/uniswap/v3/IUniswapV3Factory.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for the given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
        },
        "contracts/interfaces/external/uniswap/v3/IUniswapV3SwapRouter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface IUniswapV3SwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}"
        },
        "contracts/interfaces/external/uniswap/v3/IUniswapV3SwapRouter02.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IUniswapV3SwapRouter02 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
        },
        "contracts/interfaces/external/uniswap/v3/quoter/IUniswapV3ViewQuoter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity ^0.8.0;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IUniswapV3ViewQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param _path The path of the swap, i.e. each token pair and the pool fee\n    /// @param _amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of number of initialized ticks loaded\n    function quoteExactInput(\n        bytes memory _path,\n        uint256 _amountIn\n    )\n        external\n        view\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList\n        );\n\n    /// @notice Parameters for quoting a single exact input swap with explicit pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param amountIn The desired input amount\n    /// @param pool The address of the pool to consider for the pair\n    /// @param fee The fee of the pool to consider for the pair\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    struct QuoteExactInputSingleWithPoolParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        address pool;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param _params The params for the quote, which contains:\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// amountIn The desired input amount\n    /// fee The fee of the pool to consider for the pair\n    /// pool The address of the pool to consider for the pair\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of tokenOut that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks loaded\n    function quoteExactInputSingleWithPool(\n        QuoteExactInputSingleWithPoolParams memory _params\n    ) external view returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed);\n\n    /// @notice Parameters for quoting a single exact input swap\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param amountIn The desired input amount\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param _params The params for the quote, which contains:\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// amountIn The desired input amount\n    /// fee The fee of the token pool to consider for the pair\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of tokenOut that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks loaded\n    function quoteExactInputSingle(\n        QuoteExactInputSingleParams memory _params\n    ) external view returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed);\n\n    /// @notice Parameters for quoting a single exact output swap with explicit pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param amount The desired output amount\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param pool The address of the pool to consider for the pair\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    struct QuoteExactOutputSingleWithPoolParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        uint24 fee;\n        address pool;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param _params The params for the quote, which contains:\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// amount The desired output amount\n    /// fee The fee of the token pool to consider for the pair\n    /// pool The address of the pool to consider for the pair\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive amountOut\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks loaded\n    function quoteExactOutputSingleWithPool(\n        QuoteExactOutputSingleWithPoolParams memory _params\n    ) external view returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed);\n\n    /// @notice Parameters for quoting a single exact output swap\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param amount The desired output amount\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param _params The params for the quote, which contains:\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// amount The desired output amount\n    /// fee The fee of the token pool to consider for the pair\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive amountOut\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks loaded\n    function quoteExactOutputSingle(\n        QuoteExactOutputSingleParams memory _params\n    ) external view returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param _path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param _amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    function quoteExactOutput(\n        bytes memory _path,\n        uint256 _amountOut\n    )\n        external\n        view\n        returns (uint256 amountIn, uint160[] memory sqrtPriceX96AfterList, uint32[] memory initializedTicksCrossedList);\n}\n"
        },
        "contracts/interfaces/external/uniswap/v3/staker/IUniswapV3Staker.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '../../../../../interfaces/external/uniswap/v3/INonfungiblePositionManager.sol';\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IERC20Minimal.sol';\nimport '@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol';\n\n/// @title Uniswap V3 Staker Interface\n/// @notice Allows staking nonfungible liquidity tokens in exchange for reward tokens\ninterface IUniswapV3Staker is IERC721Receiver, IMulticall {\n    /// @param rewardToken The token being distributed as a reward\n    /// @param pool The Uniswap V3 pool\n    /// @param startTime The time when the incentive program begins\n    /// @param endTime The time when rewards stop accruing\n    /// @param refundee The address which receives any remaining reward tokens when the incentive is ended\n    struct IncentiveKey {\n        IERC20Minimal rewardToken;\n        IUniswapV3Pool pool;\n        uint256 startTime;\n        uint256 endTime;\n        address refundee;\n    }\n\n    /// @notice The Uniswap V3 Factory\n    function factory() external view returns (IUniswapV3Factory);\n\n    /// @notice The nonfungible position manager with which this staking contract is compatible\n    function nonfungiblePositionManager() external view returns (INonfungiblePositionManager);\n\n    /// @notice The max duration of an incentive in seconds\n    function maxIncentiveDuration() external view returns (uint256);\n\n    /// @notice The max amount of seconds into the future the incentive startTime can be set\n    function maxIncentiveStartLeadTime() external view returns (uint256);\n\n    /// @notice Represents a staking incentive\n    /// @param incentiveId The ID of the incentive computed from its parameters\n    /// @return totalRewardUnclaimed The amount of reward token not yet claimed by users\n    /// @return totalSecondsClaimedX128 Total liquidity-seconds claimed, represented as a UQ32.128\n    /// @return numberOfStakes The count of deposits that are currently staked for the incentive\n    function incentives(\n        bytes32 incentiveId\n    ) external view returns (uint256 totalRewardUnclaimed, uint160 totalSecondsClaimedX128, uint96 numberOfStakes);\n\n    /// @notice Returns information about a deposited NFT\n    /// @return owner The owner of the deposited NFT\n    /// @return numberOfStakes Counter of how many incentives for which the liquidity is staked\n    /// @return tickLower The lower tick of the range\n    /// @return tickUpper The upper tick of the range\n    function deposits(\n        uint256 tokenId\n    ) external view returns (address owner, uint48 numberOfStakes, int24 tickLower, int24 tickUpper);\n\n    /// @notice Returns information about a staked liquidity NFT\n    /// @param tokenId The ID of the staked token\n    /// @param incentiveId The ID of the incentive for which the token is staked\n    /// @return secondsPerLiquidityInsideInitialX128 secondsPerLiquidity represented as a UQ32.128\n    /// @return liquidity The amount of liquidity in the NFT as of the last time the rewards were computed\n    function stakes(\n        uint256 tokenId,\n        bytes32 incentiveId\n    ) external view returns (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity);\n\n    /// @notice Returns amounts of reward tokens owed to a given address according to the last time all stakes were updated\n    /// @param rewardToken The token for which to check rewards\n    /// @param owner The owner for which the rewards owed are checked\n    /// @return rewardsOwed The amount of the reward token claimable by the owner\n    function rewards(IERC20Minimal rewardToken, address owner) external view returns (uint256 rewardsOwed);\n\n    /// @notice Creates a new liquidity mining incentive program\n    /// @param key Details of the incentive to create\n    /// @param reward The amount of reward tokens to be distributed\n    function createIncentive(IncentiveKey memory key, uint256 reward) external;\n\n    /// @notice Ends an incentive after the incentive end time has passed and all stakes have been withdrawn\n    /// @param key Details of the incentive to end\n    /// @return refund The remaining reward tokens when the incentive is ended\n    function endIncentive(IncentiveKey memory key) external returns (uint256 refund);\n\n    /// @notice Transfers ownership of a deposit from the sender to the given recipient\n    /// @param tokenId The ID of the token (and the deposit) to transfer\n    /// @param to The new owner of the deposit\n    function transferDeposit(uint256 tokenId, address to) external;\n\n    /// @notice Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param to The address where the LP token will be sent\n    /// @param data An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom\n    function withdrawToken(uint256 tokenId, address to, bytes memory data) external;\n\n    /// @notice Stakes a Uniswap V3 LP token\n    /// @param key The key of the incentive for which to stake the NFT\n    /// @param tokenId The ID of the token to stake\n    function stakeToken(IncentiveKey memory key, uint256 tokenId) external;\n\n    /// @notice Unstakes a Uniswap V3 LP token\n    /// @param key The key of the incentive for which to unstake the NFT\n    /// @param tokenId The ID of the token to unstake\n    function unstakeToken(IncentiveKey memory key, uint256 tokenId) external;\n\n    /// @notice Transfers `amountRequested` of accrued `rewardToken` rewards from the contract to the recipient `to`\n    /// @param rewardToken The token being distributed as a reward\n    /// @param to The address where claimed rewards will be sent to\n    /// @param amountRequested The amount of reward tokens to claim. Claims entire reward amount if set to 0.\n    /// @return reward The amount of reward tokens claimed\n    function claimReward(\n        IERC20Minimal rewardToken,\n        address to,\n        uint256 amountRequested\n    ) external returns (uint256 reward);\n\n    /// @notice Calculates the reward amount that will be received for the given stake\n    /// @param key The key of the incentive\n    /// @param tokenId The ID of the token\n    /// @return reward The reward accrued to the NFT for the given incentive thus far\n    function getRewardInfo(\n        IncentiveKey memory key,\n        uint256 tokenId\n    ) external returns (uint256 reward, uint160 secondsInsideX128);\n\n    /// @notice Event emitted when a liquidity mining incentive has been created\n    /// @param rewardToken The token being distributed as a reward\n    /// @param pool The Uniswap V3 pool\n    /// @param startTime The time when the incentive program begins\n    /// @param endTime The time when rewards stop accruing\n    /// @param refundee The address which receives any remaining reward tokens after the end time\n    /// @param reward The amount of reward tokens to be distributed\n    event IncentiveCreated(\n        IERC20Minimal indexed rewardToken,\n        IUniswapV3Pool indexed pool,\n        uint256 startTime,\n        uint256 endTime,\n        address refundee,\n        uint256 reward\n    );\n\n    /// @notice Event that can be emitted when a liquidity mining incentive has ended\n    /// @param incentiveId The incentive which is ending\n    /// @param refund The amount of reward tokens refunded\n    event IncentiveEnded(bytes32 indexed incentiveId, uint256 refund);\n\n    /// @notice Emitted when ownership of a deposit changes\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\n    /// @param oldOwner The owner before the deposit was transferred\n    /// @param newOwner The owner after the deposit was transferred\n    event DepositTransferred(uint256 indexed tokenId, address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Event emitted when a Uniswap V3 LP token has been staked\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param liquidity The amount of liquidity staked\n    /// @param incentiveId The incentive in which the token is staking\n    event TokenStaked(uint256 indexed tokenId, bytes32 indexed incentiveId, uint128 liquidity);\n\n    /// @notice Event emitted when a Uniswap V3 LP token has been unstaked\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param incentiveId The incentive in which the token is staking\n    event TokenUnstaked(uint256 indexed tokenId, bytes32 indexed incentiveId);\n\n    /// @notice Event emitted when a reward token has been claimed\n    /// @param to The address where claimed rewards were sent to\n    /// @param reward The amount of reward tokens claimed\n    event RewardClaimed(address indexed to, uint256 reward);\n}\n"
        },
        "contracts/interfaces/manager/IGildiManager.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\n\n/// @title IGildiManager\n/// @notice Interface for the Gildi Manager.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ninterface IGildiManager is IERC165 {\n    /// @notice A user share.\n    struct UserShare {\n        /// @notice The user address.\n        address user;\n        /// @notice The number shares owned by the user.\n        uint256 shares;\n    }\n\n    /// @notice A report of the shares owned by a user in a specific time period.\n    struct SharesReport {\n        /// @notice The token ID.\n        uint256 tokenId;\n        /// @notice The start timestamp of the report.\n        uint256 start;\n        /// @notice The end timestamp of the report.\n        uint256 end;\n        /// @notice The total number of shares owned by all users.\n        uint256 totalNumberOfShares;\n        /// @notice The shares owned by each user.\n        UserShare[] userShares;\n        /// @notice Info for Pagination, if there are more results.\n        bool hasMore;\n        /// @notice Next cursor for Pagination.\n        uint256 nextCursor;\n    }\n\n    struct TokenBalance {\n        uint256 tokenId;\n        uint256 amount;\n        uint256 lockedAmount;\n    }\n\n    /// @notice A GILDI RWA release.\n    struct RWARelease {\n        /// @notice The token ID of the release (equal to release id).\n        uint256 tokenId;\n        /// @notice If the release is locked.\n        bool locked;\n        /// @notice When the release was unlocked.\n        uint256 unlockedAt;\n        /// @notice If the release is in the initial sale.\n        bool inInitialSale;\n        /// @notice The total number of shares.\n        uint256 totalShares;\n        /// @notice The number of unassigned shares.\n        uint256 unassignedShares;\n        /// @notice The number of burned shares.\n        uint256 burnedShares;\n        /// @notice The release is deleting.\n        bool deleting;\n        /// @notice The number of shares deleted.\n        uint256 deletedShares;\n        /// @notice The timestamp of the creation.\n        uint256 createdAt;\n    }\n\n    /// @notice Fetches all the release IDs.\n    /// @return An array of all the release IDs.\n    function getAllReleaseIds() external view returns (uint256[] memory);\n\n    /// @notice Create a new release.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    /// @param _amount The amount of the token.\n    /// @param _ownershipTrackingTimePeriod The time period in which we aggregate the shares owned by a user.\n    function createNewRelease(uint256 _releaseId, uint256 _amount, uint256 _ownershipTrackingTimePeriod) external;\n\n    /// @notice Assigns the user shares to a royalty rights release in a batch operation.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    /// @param _sharesBatch The shares to assign.\n    /// @dev The shares are assigned in a batch to prevent gas limit issues.\n    function assignShares(uint256 _releaseId, UserShare[] calldata _sharesBatch) external;\n\n    /// @notice Starts the initial sale of a release.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    function startInitialSale(uint256 _releaseId) external;\n\n    /// @notice Cancels the initial sale of a release.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    function cancelInitialSale(uint256 _releaseId) external;\n\n    /// @notice Ends the initial sale of a release.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    function endInitialSale(uint256 _releaseId) external;\n\n    /// @notice Check if a release exists.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    /// @return True if the release exists, false otherwise.\n    function releaseExists(uint256 _releaseId) external view returns (bool);\n\n    /// @notice Deletes a release in batches.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    /// @param _batchSizeOwners The number of owners to delete in a batch.\n    /// @dev Batch deletion is used to prevent gas limit issues.\n    function batchDeleteRelease(uint256 _releaseId, uint256 _batchSizeOwners) external;\n\n    /// @notice Unlocks a release.\n    /// @param _releaseId The ID of the Royalty Rights Token / release.\n    function unlockRelease(uint256 _releaseId) external;\n\n    /// @notice Deposits royalty rights tokens into the manager.\n    /// @param _tokenId The ID of the Royalty Rights Token / release.\n    /// @param _account The account to deposit the tokens to.\n    /// @param _amount The amount of tokens to deposit.\n    function deposit(uint256 _tokenId, address _account, uint256 _amount) external;\n\n    /// @notice Withdraws royalty rights tokens from the manager.\n    /// @param _tokenId The ID of the Royalty Rights Token / release.\n    /// @param _account The account to withdraw the tokens from.\n    /// @param _amount The amount of tokens to withdraw.\n    function withdraw(uint256 _tokenId, address _account, uint256 _amount) external;\n\n    /// @notice Locks tokens for a user.\n    /// @param _account The account to lock the tokens for.\n    /// @param _tokenId The ID of the Royalty Rights Token / release.\n    /// @param _amountToLock The amount of tokens to lock.\n    function lockTokens(address _account, uint256 _tokenId, uint256 _amountToLock) external;\n\n    /// @notice Unlocks tokens for a user.\n    /// @param _account The account to unlock the tokens for.\n    /// @param _tokenId The ID of the Royalty Rights Token / release.\n    /// @param _amountToUnlock The amount of tokens to unlock.\n    function unlockTokens(address _account, uint256 _tokenId, uint256 _amountToUnlock) external;\n\n    /// @notice Transfers ownership of a release's shares to another user.\n    /// @param _tokenId The ID of the Royalty Rights Token / release.\n    /// @param _from The address of the current owner.\n    /// @param _to The address of the new owner.\n    /// @param _amount The amount of shares to transfer.\n    function transferOwnership(uint256 _tokenId, address _from, address _to, uint256 _amount) external;\n\n    /// @notice Transfers ownership of a release's shares to another user during the initial sale.\n    /// @param _tokenId The ID of the Royalty Rights Token / release.\n    /// @param _from The address of the current owner.\n    /// @param _to The address of the new owner.\n    /// @param _amount The amount of shares to transfer.\n    function transferOwnershipInitialSale(uint256 _tokenId, address _from, address _to, uint256 _amount) external;\n\n    /// @notice Gets a release by its ID.\n    /// @param _releaseId The release ID.\n    /// @return The release.\n    function getReleaseById(uint256 _releaseId) external view returns (RWARelease memory);\n\n    /// @notice Checks if the release is locked.\n    /// @param _releaseId The release ID.\n    /// @return True if the release is locked, false otherwise.\n    function isLocked(uint256 _releaseId) external view returns (bool);\n\n    /// @notice Returns if the release is in the initial sale.\n    /// @param _releaseId The release ID.\n    /// @return True if the release is in the initial sale, false otherwise.\n    function isInInitialSale(uint256 _releaseId) external view returns (bool);\n\n    /// @notice Fetches the available balance of a user for a specific token.\n    /// @param _tokenId The token ID.\n    /// @param _account The account to fetch the balance for.\n    /// @return The available balance of the user for the token.\n    function getAvailableBalance(uint256 _tokenId, address _account) external view returns (uint256);\n\n    /// @notice Fetch the shares of a release owned by a user in a specific time period paginated.\n    /// @param _releaseId The release ID.\n    /// @param _start The start timestamp.\n    /// @param _end The end timestamp (exclusive).\n    /// @param _cursor The cursor for pagination.\n    /// @param _limit The limit for pagination.\n    function fetchSharesInPeriod(\n        uint256 _releaseId,\n        uint256 _start,\n        uint256 _end,\n        uint256 _cursor,\n        uint256 _limit\n    ) external view returns (SharesReport memory);\n\n    /// @notice Fetches the balance of a user for all tokens.\n    /// @param _account The account to fetch the balance for.\n    function balanceOf(address _account) external view returns (TokenBalance[] memory);\n\n    /// @notice Fetches the balance of a user for a specific token.\n    /// @param _tokenId The token ID.\n    /// @param _account The account to fetch the balance for.\n    function balanceOf(uint256 _tokenId, address _account) external view returns (TokenBalance memory);\n\n    /// @notice Checks if the release is fully assigned.\n    function isFullyAssigned(uint256 _releaseId) external view returns (bool);\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/IGildiExchange.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IGildiManager} from '../../manager/IGildiManager.sol';\nimport {IGildiPriceOracle} from '../../oracles/price/IGildiPriceOracle.sol';\nimport {IGildiExchangeOrderBook} from './IGildiExchangeOrderBook.sol';\nimport {IGildiExchangeFundManager} from './IGildiExchangeFundManager.sol';\nimport {IGildiExchangePaymentProcessor} from './IGildiExchangePaymentProcessor.sol';\nimport {IGildiExchangePaymentAggregator} from './IGildiExchangePaymentAggregator.sol';\n\n/// @title IGildiExchange\n/// @notice Interface for the Gildi Exchange.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiExchange is IAccessControl {\n    /// @notice Represents a fee/burn receiver with an address and a basis points value and the currency to receive in.\n    struct Receiver {\n        /// @dev The address that receives the fee\n        address receiverAddress;\n        /// @dev The currency in which the fee is paid\n        address payoutCurrency;\n        /// @dev The value in basis points\n        uint16 value;\n    }\n\n    /// @notice Represents a top-level fee distribution with an address and optional sub-fee receivers.\n    struct FeeDistribution {\n        /// @dev The primary fee receiver\n        Receiver feeReceiver;\n        /// @dev Used to distribute a portion of the parent fee, e.g., burn a fraction\n        Receiver[] subFeeReceivers;\n    }\n\n    /// @notice Application environment settings\n    struct AppEnvironment {\n        /// @dev Application settings including dependencies\n        AppSettings settings;\n        /// @dev The basis points denominator for percentage calculations\n        uint16 basisPoints;\n        /// @dev The admin role identifier\n        bytes32 adminRole;\n        /// @dev The marketplace manager role identifier\n        bytes32 marketplaceManagerRole;\n        /// @dev The claimer role identifier\n        bytes32 claimerRole;\n    }\n\n    /// @notice Application settings\n    struct AppSettings {\n        /// @dev The number of decimals for price asking\n        uint8 priceAskDecimals;\n        /// @dev The fee distribution structure\n        FeeDistribution[] fees;\n        /// @dev The marketplace currency\n        IERC20 marketplaceCurrency;\n        /// @dev The maximum number of buys per transaction\n        uint256 maxBuyPerTransaction;\n        /// @dev The Gildi manager interface\n        IGildiManager gildiManager;\n        /// @dev The order book interface\n        IGildiExchangeOrderBook orderBook;\n        /// @dev The price oracle interface\n        IGildiPriceOracle gildiPriceOracle;\n        /// @dev The fund manager interface\n        IGildiExchangeFundManager fundManager;\n        /// @dev The payment processor interface\n        IGildiExchangePaymentProcessor paymentProcessor;\n        /// @dev The payment aggregator interface\n        IGildiExchangePaymentAggregator paymentAggregator;\n    }\n\n    /// @notice Purchases tokens of a release\n    /// @dev Sweeps the floor\n    /// @param _releaseId The ID of the release\n    /// @param _amount The amount of tokens to purchase\n    /// @param _maxTotalPrice The maximum total price to spend in Marketplace Currency\n    /// @param _beneficiary The address to send the tokens to\n    /// @param _isProxyOperation Whether the operation is a proxy operation\n    /// @return amountSpent The amount of Marketplace Currency spent\n    /// @return amountUsdSpent The amount spent in USD\n    function purchase(\n        uint256 _releaseId,\n        uint256 _amount,\n        uint256 _maxTotalPrice,\n        address _beneficiary,\n        bool _isProxyOperation\n    ) external returns (uint256 amountSpent, uint256 amountUsdSpent);\n\n    /// @notice Transfer a token in the context of the Gildi Exchange\n    /// @param _from The address to transfer from\n    /// @param _to The address to transfer to\n    /// @param _value The amount to transfer\n    /// @param _amountCurrency The currency of the amount\n    function transferTokenInContext(address _from, address _to, uint256 _value, address _amountCurrency) external;\n\n    /// @notice Tries to burn a token in the context of the Gildi Exchange\n    /// @param _from The address to burn from\n    /// @param _value The amount to burn\n    /// @param _amountCurrency The currency of the amount\n    /// @return Whether the burn was successful\n    function tryBurnTokenInContext(address _from, uint256 _value, address _amountCurrency) external returns (bool);\n\n    /// @notice Gets the price needed to pay in marketplace currency to buy `_amountToBuy` units of `_releaseId`.\n    /// @param _releaseId The ID of the release\n    /// @param _amountToBuy The amount of tokens to buy\n    /// @param _buyer The address of the buyer (optional)\n    /// @return totalPriceInCurrency The total cost in marketplace currency\n    /// @return asset The asset the price is in\n    /// @return totalPriceUsd The total price in USD (using exchange's priceAskDecimals)\n    function quotePricePreview(\n        uint256 _releaseId,\n        uint256 _amountToBuy,\n        address _buyer\n    ) external view returns (uint256 totalPriceInCurrency, address asset, uint256 totalPriceUsd);\n\n    /// @notice Checks if a release is currently in its initial sale period\n    /// @param _releaseId The ID of the release\n    /// @return True if the release is in active initial sale, false otherwise\n    function isInInitialSale(uint256 _releaseId) external view returns (bool);\n\n    /// @notice Returns the app environment.\n    /// @return appEnvironment The app environment\n    function getAppEnvironment() external view returns (AppEnvironment memory);\n\n    /// @notice Gets the active marketplace asset for a release\n    /// @param _releaseId The ID of the release\n    /// @return The address of the active marketplace asset for the release\n    function getActiveMarketplaceReleaseAsset(uint256 _releaseId) external view returns (address);\n\n    /// @notice Converts a price in USD to the equivalent amount in the specified asset\n    /// @param _asset The address of the asset to convert to\n    /// @param _priceInUsd The price in USD to convert\n    /// @return The equivalent amount in the specified asset\n    function quotePrice(address _asset, uint256 _priceInUsd) external view returns (uint256);\n\n    /// @notice Get the fees of a specific release\n    /// @param _releaseId The ID of the release\n    /// @return An array of fee distributions for the release\n    function getReleaseFees(uint256 _releaseId) external view returns (FeeDistribution[] memory);\n\n    /// @notice Get a list of release IDs\n    /// @param _activeOnly Whether or not to only return active releases\n    /// @return activeReleases An array of release IDs\n    function getReleaseIds(bool _activeOnly) external view returns (uint256[] memory);\n\n    /// @notice Creates a listing with default slippage\n    /// @param _releaseId The ID of the release\n    /// @param _seller The address of the seller\n    /// @param _pricePerItem The price per item in USD\n    /// @param _quantity The quantity being listed\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _payoutCurrency The currency the seller wants to receive payment in\n    function createListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver\n    ) external;\n\n    /// @notice Creates a listing with custom slippage\n    /// @param _releaseId The ID of the release\n    /// @param _seller The address of the seller\n    /// @param _pricePerItem The price per item in USD\n    /// @param _quantity The quantity being listed\n    /// @param _payoutCurrency The currency the seller wants to receive payment in\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _slippageBps Slippage tolerance in basis points\n    function createListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external;\n\n    /// @notice Modifies a listing with default slippage\n    /// @param _listingId The ID of the listing to modify\n    /// @param _newPricePerItem The new price per item in USD\n    /// @param _newQuantity The new quantity (if 0, the listing will be removed)\n    /// @param _payoutCurrency The new payout currency\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    function modifyListing(\n        uint256 _listingId,\n        uint256 _newPricePerItem,\n        uint256 _newQuantity,\n        address _payoutCurrency,\n        address _fundsReceiver\n    ) external;\n\n    /// @notice Modifies a listing with custom slippage\n    /// @param _listingId The ID of the listing to modify\n    /// @param _newPricePerItem The new price per item in USD\n    /// @param _newQuantity The new quantity (if 0, the listing will be removed)\n    /// @param _payoutCurrency The new payout currency\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _slippageBps Slippage tolerance in basis points\n    function modifyListing(\n        uint256 _listingId,\n        uint256 _newPricePerItem,\n        uint256 _newQuantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external;\n\n    /// @notice Cancels a listing by ID\n    /// @param _listingId The ID of the listing to cancel\n    function cancelListing(uint256 _listingId) external;\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/IGildiExchangeFundManager.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title Gildi Exchange Fund Manager Interface\n/// @notice Interface for the Gildi Exchange Fund Manager contract.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ninterface IGildiExchangeFundManager {\n    // ========== Structs ==========\n\n    /// @notice Represents an fund entry storing the buyer, operator, fundParticipant, and value in Marketplace Currency.\n    struct Fund {\n        /// @dev Entity receiving the tokens (beneficiary)\n        address buyer;\n        /// @dev Entity that executed the transaction\n        address operator;\n        /// @dev Entity with funds in fund (seller or fee recipient)\n        address fundParticipant;\n        /// @dev Whether this was executed through a proxy\n        bool isProxyOperation;\n        /// @dev Amount in Marketplace Currency\n        FundAmount amount;\n        /// @dev Payout currency\n        address payoutCurrency;\n    }\n\n    /// @notice Represents an amount of tokens in a specific currency\n    struct FundAmount {\n        /// @dev The amount of tokens\n        uint256 value;\n        /// @dev The address of the currency token\n        address currencyAddress;\n    }\n\n    // ========== View Functions ==========\n\n    /// @notice Checks if a release has any funds\n    /// @param _releaseId The ID of the release\n    /// @return True if the release has funds, false otherwise\n    function releaseHasFunds(uint256 _releaseId) external view returns (bool);\n\n    // ========== Non-View Functions ==========\n\n    /// @notice Adds funds to fund for a participant\n    /// @param _releaseId The ID of the release\n    /// @param _participant The address of the fund participant\n    /// @param _buyer The address of the buyer\n    /// @param _operator The address of the operator\n    /// @param _isProxyOperation Whether this is a proxy operation\n    /// @param _amount The amount to add to fund\n    /// @param _amountCurrency The currency of the fund amount\n    /// @param _payoutCurrency The currency to payout in\n    function handleAddToFund(\n        uint256 _releaseId,\n        address _participant,\n        address _buyer,\n        address _operator,\n        bool _isProxyOperation,\n        uint256 _amount,\n        address _amountCurrency,\n        address _payoutCurrency\n    ) external;\n\n    /// @notice Cancels funds for a release in batches\n    /// @param _releaseId The ID of the release\n    /// @param _batchSize The number of funds to process in this batch\n    /// @return processed The number of funds processed\n    function handleCancelReleaseFunds(uint256 _releaseId, uint256 _batchSize) external returns (uint256 processed);\n\n    /// @notice Claims funds for a participant of a release with custom slippage\n    /// @param _releaseId The ID of the release\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _slippageBps Slippage tolerance in basis points (100 = 1%, 500 = 5%)\n    function claimFunds(uint256 _releaseId, address _fundParticipant, uint16 _slippageBps) external;\n\n    /// @notice Claims funds for a participant of a release with default slippage (5%)\n    /// @param _releaseId The ID of the release\n    /// @param _fundParticipant The address of the fund participant\n    function claimFunds(uint256 _releaseId, address _fundParticipant) external;\n\n    /// @notice Claims all funds for a participant across all releases with custom slippage\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _slippageBps Slippage tolerance in basis points (100 = 1%, 500 = 5%)\n    function claimAllFunds(address _fundParticipant, uint16 _slippageBps) external;\n\n    /// @notice Claims all funds for a participant across all releases with default slippage (5%)\n    /// @param _fundParticipant The address of the fund participant\n    function claimAllFunds(address _fundParticipant) external;\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/IGildiExchangeOrderBook.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title IGildiExchangeOrderBook\n/// @notice Interface for the Gildi Exchange Order Book, which manages listings and provides order book functionality for the marketplace.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiExchangeOrderBook {\n    /// @notice Represents a listing in the order book for a specific token release.\n    struct Listing {\n        /// @dev A unique identifier for the listing.\n        uint256 id;\n        /// @dev The ID of the token release being listed.\n        uint256 releaseId;\n        /// @dev The address of the seller who created the listing.\n        address seller;\n        /// @dev The price per item in USD.\n        uint256 pricePerItem;\n        /// @dev The currency in which the seller wants to receive payment (if different from the active release marketplace currency, a swap will be performed).\n        address payoutCurrency;\n        /// @dev The quantity of tokens being listed.\n        uint256 quantity;\n        /// @dev Slippage protection in basis points (100 = 1%, 500 = 5%), 0 means no slippage allowed.\n        uint16 slippageBps;\n        /// @dev The block timestamp when the listing was created (UNIX timestamp).\n        uint256 createdAt;\n        /// @dev The block timestamp when the listing was last modified (UNIX timestamp).\n        uint256 modifiedAt;\n        /// @dev The ID of the next listing in the linked list (ordered by price).\n        uint256 nextListingId;\n        /// @dev The ID of the previous listing in the linked list (ordered by price).\n        uint256 prevListingId;\n        /// @dev Optional address to receive funds from the sale.\n        address fundsReceiver; // If address(0), defaults to seller\n    }\n\n    /// @notice Contains preview information for a potential purchase.\n    struct PurchasePreview {\n        /// @dev The total quantity available for purchase.\n        uint256 totalQuantityAvailable;\n        /// @dev The total price in marketplace currency.\n        uint256 totalPriceInCurrency;\n        /// @dev The address of the currency used for the purchase.\n        address currency;\n        /// @dev The total price in USD (using exchange's priceAskDecimals).\n        uint256 totalPriceUsd;\n    }\n\n    // ========== View Functions ==========\n\n    /// @notice Gets a listing by ID\n    /// @param _listingId The listing ID\n    /// @return The listing\n    function getListing(uint256 _listingId) external view returns (Listing memory);\n\n    /// @notice Gets all the listings of a specific seller\n    /// @param _seller The address of the seller\n    /// @return An array of listings for the seller\n    function getListingsOfSeller(address _seller) external view returns (Listing[] memory);\n\n    /// @notice Gets all the listings of a specific release, ordered by price\n    /// @param _releaseId The ID of the release\n    /// @param _cursor The cursor to start from\n    /// @param _limit The limit of listings to return\n    /// @return orderedListings An array of listings for the release\n    /// @return cursor The cursor to continue from\n    function getOrderedListings(\n        uint256 _releaseId,\n        uint256 _cursor,\n        uint256 _limit\n    ) external view returns (Listing[] memory orderedListings, uint256 cursor);\n\n    /// @notice Gets the available buy quantity for a user\n    /// @param _releaseId The release ID\n    /// @param _user The user address\n    /// @return The available quantity to buy\n    function getAvailableBuyQuantity(uint256 _releaseId, address _user) external view returns (uint256);\n\n    /// @notice Preview a purchase\n    /// @param _releaseId The ID of the release to purchase\n    /// @param _buyer The address of the buyer\n    /// @param _amountToBuy The amount of tokens to buy\n    /// @return Preview information for the purchase\n    function previewPurchase(\n        uint256 _releaseId,\n        address _buyer,\n        uint256 _amountToBuy\n    ) external view returns (PurchasePreview memory);\n\n    /// @notice Gets the first listing ID (with lowest price) for a specific release\n    /// @param _releaseId The ID of the release\n    /// @return The ID of the listing with the lowest price for this release\n    function getHeadListingId(uint256 _releaseId) external view returns (uint256);\n\n    /// @notice Gets the next listing ID in the price-ordered linked list\n    /// @param _listingId The current listing ID\n    /// @return The ID of the next listing with a higher price, or 0 if none exists\n    function getNextListingId(uint256 _listingId) external view returns (uint256);\n\n    /// @notice Gets the total quantity listed for a specific release\n    /// @param _releaseId The ID of the release\n    /// @return The total quantity listed\n    function listedQuantities(uint256 _releaseId) external view returns (uint256);\n\n    // ========== Non-View Functions ==========\n\n    /// @notice Creates a listing\n    /// @param _releaseId The ID of the release\n    /// @param _seller The address of the seller\n    /// @param _pricePerItem The price per item\n    /// @param _quantity The quantity being listed\n    /// @param _payoutCurrency The payout currency of the listing\n    /// @param _slippageBps Optional slippage protection in basis points (100 = 1%, 500 = 5%)\n    /// @dev Takes the slippage setting literally, 0 = no slippage, 10000 = 100%, does not make assumptions about the default, caller must know what they are doing\n    function handleCreateListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external;\n\n    /// @notice Modifies an existing listing's price, quantity, and slippage settings\n    /// @param _listingId The ID of the listing to modify\n    /// @param _pricePerItem The new price per item\n    /// @param _quantity The new quantity (if 0, the listing will be removed)\n    /// @param _payoutCurrency The new payout currency\n    /// @param _slippageBps Slippage protection in basis points (100 = 1%, 500 = 5%)\n    /// @dev Takes the slippage setting literally, 0 = no slippage, 10000 = 100%, does not make assumptions about the default, caller must know what they are doing\n    function handleModifyListing(\n        uint256 _listingId,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external;\n\n    /// @notice Removes a listing\n    /// @param _listingId The ID of the listing to cancel\n    function handleRemoveListing(uint256 _listingId) external;\n\n    /// @notice Decreases a listing's quantity after a purchase\n    /// @param _listingId The ID of the listing\n    /// @param _quantityToBuy The amount to reduce from the listing's quantity (if this reduces quantity to 0, the listing will be removed)\n    function handleDecreaseListingQuantity(uint256 _listingId, uint256 _quantityToBuy) external;\n\n    /// @notice Unlists all listings of a release in batches.\n    /// @param _releaseId The ID of the release\n    /// @param _batchSize The batch size\n    /// @return processedListings The number of listings processed\n    function handleUnlistReleaseListings(\n        uint256 _releaseId,\n        uint256 _batchSize\n    ) external returns (uint256 processedListings);\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/IGildiExchangePaymentAggregator.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport './IGildiExchangeSwapAdapter.sol';\nimport './IGildiExchange.sol';\n\n/// @title IGildiExchangePaymentAggregator\n/// @notice Interface for marketplace payment operations including swap functionality\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiExchangePaymentAggregator {\n    /// @notice Executes a swap out operation to convert source tokens to a target token.\n    /// @param _amount The amount of source tokens to swap.\n    /// @param _sourceCurrency The address of the source token.\n    /// @param _targetToken The token to swap to.\n    /// @param _minTargetAmount The minimum amount of target tokens to receive (slippage protection).\n    /// @param _recipient The recipient of the target tokens.\n    /// @return targetReceived The amount of target tokens received.\n    function swapOut(\n        uint256 _amount,\n        address _sourceCurrency,\n        address _targetToken,\n        uint256 _minTargetAmount,\n        address _recipient\n    ) external returns (uint256 targetReceived);\n\n    /// @notice Previews a swap out operation to check if there's a valid route and estimate the output amount.\n    /// @param _amount The amount of source tokens to swap.\n    /// @param _sourceCurrency The address of the source token.\n    /// @param _targetToken The token to swap to.\n    /// @return hasValidRoute Whether there's a valid route for the swap.\n    /// @return expectedTargetAmount The expected amount of target tokens to receive.\n    /// @return bestRoute The best route for the swap.\n    function previewSwapOut(\n        uint256 _amount,\n        address _sourceCurrency,\n        address _targetToken\n    )\n        external\n        view\n        returns (\n            bool hasValidRoute,\n            uint256 expectedTargetAmount,\n            IGildiExchangeSwapAdapter.QuoteRoute memory bestRoute\n        );\n\n    /// @notice Executes the purchase payment flow.\n    /// @param _releaseId The release ID.\n    /// @param _amount The amount to purchase.\n    /// @param _sourceToken The token used for payment (address(0) means native).\n    /// @param _sourceMaxAmount Maximum amount of _sourceToken to spend.\n    /// @return amountUsdSpent The amount spent in USD\n    function purchase(\n        uint256 _releaseId,\n        uint256 _amount,\n        address _sourceToken,\n        uint256 _sourceMaxAmount\n    ) external payable returns (uint256 amountUsdSpent);\n\n    /// @notice Estimates the amount of `_sourceToken` required to get `_amount` of `_releaseId` for `_buyer` of the marketplace token and returns the current best route.\n    /// @param _releaseId The release ID.\n    /// @param _amount The amount of the release.\n    /// @param _buyer The buyer of the release.\n    /// @param _sourceToken The token to swap from.\n    /// @return sourceNeeded The amount of `_sourceToken` required.\n    /// @return releaseCurrency The active martketplace currency of the release.\n    /// @return quoteRoute The route of the quote.\n    /// @return totalPriceUsd The total price in USD (using exchange's priceAskDecimals).\n    function estimatePurchase(\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer,\n        address _sourceToken\n    )\n        external\n        view\n        returns (\n            uint256 sourceNeeded,\n            address releaseCurrency,\n            IGildiExchangeSwapAdapter.QuoteRoute memory quoteRoute,\n            uint256 totalPriceUsd\n        );\n\n    /// @notice Returns the GildiExchange contract instance.\n    /// @return The GildiExchange contract.\n    function getGildiExchange() external view returns (IGildiExchange);\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/IGildiExchangePaymentProcessor.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {IGildiExchange} from './IGildiExchange.sol';\n\n/// @title IGildiExchangePaymentProcessor\n/// @notice Interface for the Gildi Exchange Payment Processor.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiExchangePaymentProcessor {\n    /// @notice Gets the price feed ID for a currency\n    /// @param _currency The currency address\n    /// @return The price feed ID\n    function getPriceFeedId(address _currency) external view returns (bytes32);\n\n    /// @notice Converts a price in USD to the equivalent amount in the specified currency\n    /// @param _priceInUSD The price in USD to convert\n    /// @param _currency The address of the currency to convert to\n    /// @return The equivalent amount in the specified currency\n    function quoteInCurrency(uint256 _priceInUSD, address _currency) external view returns (uint256);\n\n    /// @notice Processes payment with fees.\n    ///      Calculates fees, transfers funds to fee recipients, and optionally creates funds\n    /// @param _releaseId The ID of the release\n    /// @param _buyer The address of the buyer\n    /// @param _seller The address of the seller\n    /// @param _value The value to process fees for\n    /// @param _amountCurrency The currency of the amount\n    /// @param _createFund Whether to create an fund\n    /// @param _operator The address of the operator\n    /// @param _listingId The ID of the listing\n    /// @param _isProxyOperation Whether this is a proxy operation\n    /// @param _listingPayoutCurrency The currency to payout in from the listing\n    function handleProcessPaymentWithFees(\n        uint256 _releaseId,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        address _amountCurrency,\n        bool _createFund,\n        address _operator,\n        bool _isProxyOperation,\n        uint256 _listingId,\n        address _listingPayoutCurrency,\n        uint16 _slippageBps\n    ) external;\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/IGildiExchangeSwapAdapter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title IGildiExchangeSwapAdapter\n/// @notice Interface for a DEX/aggregator adapter that can\n///         quote & swap from a user’s source token -> marketplace token\n///         in an \"exact out\" fashion.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiExchangeSwapAdapter {\n    /// @notice The route of the quote\n    /// @param marketplaceAdapter The address of the marketplace adapter\n    /// @param route The path of the quote\n    /// @param fees The fees of the quote\n    /// @param amounts The amounts of the quote\n    /// @param virtualAmountsWithoutSlippage The virtual amounts of the quote without slippage\n    struct QuoteRoute {\n        address marketplaceAdapter;\n        address[] route;\n        uint128[] fees;\n        uint128[] amounts;\n        uint128[] virtualAmountsWithoutSlippage;\n    }\n\n    /// @notice The quote for a swap in\n    /// @param sourceTokenRequired The amount of source token required\n    /// @param rawQuoteData The raw quote data\n    /// @param quoteRoute The quote route\n    /// @param validRoute Whether the route is valid\n    struct SwapInQuote {\n        uint256 sourceTokenRequired;\n        bytes rawQuoteData;\n        QuoteRoute quoteRoute;\n        bool validRoute;\n    }\n\n    /// @notice The quote for a swap out\n    /// @param targetTokenOut The target token\n    /// @param rawQuoteData The raw quote data\n    /// @param quoteRoute The quote route\n    /// @param validRoute Whether the route is valid\n    struct SwapOutQuote {\n        uint256 targetTokenOut;\n        bytes rawQuoteData;\n        QuoteRoute quoteRoute;\n        bool validRoute;\n    }\n\n    /// @notice Quotes the amount of `_sourceToken` required to get `_marketplaceAmountDesired` of `_marketplaceToken`.\n    /// @param _sourceToken The token to swap from.\n    /// @param _marketplaceToken The token to swap to.\n    /// @param _marketplaceAmountDesired The amount of `_marketplaceToken` desired.\n    /// @return quote The swap in quote containing required source token amount, quote data and route information\n    function quoteSwapIn(\n        address _sourceToken,\n        address _marketplaceToken,\n        uint256 _marketplaceAmountDesired\n    ) external view returns (SwapInQuote memory quote);\n\n    /// @notice Performs an \"exact out\" swap to get `_marketplaceAmount` of `_marketplaceToken`.\n    /// @param _sourceToken The token to swap from.\n    /// @param _marketplaceToken The token to swap to.\n    /// @param _sourceAmountMax The max `_sourceToken` we can spend (slippage buffer).\n    /// @param _marketplaceAmount The exact marketplace tokens we want out.\n    /// @param _to The recipient of the marketplace tokens.\n    /// @param _quoteData The data previously returned by `quoteSwapIn`.\n    function swapIn(\n        address _sourceToken,\n        address _marketplaceToken,\n        uint256 _sourceAmountMax,\n        uint256 _marketplaceAmount,\n        address _to,\n        bytes calldata _quoteData\n    ) external returns (uint256 sourceSpent);\n\n    /// @notice Quotes the amount of `_targetToken` you can get by providing `_sourceAmount` of `_sourceToken`.\n    /// @param _sourceToken The token to swap from.\n    /// @param _targetToken The token to swap to.\n    /// @param _sourceAmount The amount of `_sourceToken` available.\n    /// @return quote The quote.\n    function quoteSwapOut(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmount\n    ) external view returns (SwapOutQuote memory quote);\n\n    /// @notice Performs an \"exact in\" swap to convert `_sourceAmount` of `_sourceToken` into `_targetToken`.\n    /// @param _sourceToken The token to swap from.\n    /// @param _targetToken The token to swap to.\n    /// @param _sourceAmount The exact amount of `_sourceToken` to swap.\n    /// @param _minTargetAmount The minimum amount of `_targetToken` to receive (slippage protection).\n    /// @param _to The recipient of the target tokens.\n    /// @param _quoteData The data previously returned by `quoteSwapOut`.\n    function swapOut(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmount,\n        uint256 _minTargetAmount,\n        address _to,\n        bytes calldata _quoteData\n    ) external returns (uint256 targetReceived);\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/iota/ILBMagicSeaQuoter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport './ILBMagicSeaRouter.sol';\n\n/// @title ILBMagicSeaQuoter\n/// @notice Minimal interface for the LBMagicSea Quoter.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ninterface ILBMagicSeaQuoter {\n    /// @notice The quote struct returned by the quoter\n    /// @param route The address array of the token to go through\n    /// @param pairs The address array of the pairs to go through\n    /// @param binSteps The bin step to use for each pair\n    /// @param versions The version to use for each pair\n    /// @param amounts The amounts of every step of the swap\n    /// @param virtualAmountsWithoutSlippage The virtual amounts of every step of the swap without slippage\n    /// @param fees The fees to pay for every step of the swap\n    struct Quote {\n        address[] route;\n        address[] pairs;\n        uint256[] binSteps;\n        ILBMagicSeaRouter.Version[] versions;\n        uint128[] amounts;\n        uint128[] virtualAmountsWithoutSlippage;\n        uint128[] fees;\n    }\n\n    /// @notice This error is thrown when the length of the route is invalid\n    error LBQuoter_InvalidLength();\n\n    /// @notice Finds the best path given a list of tokens and the input amount wanted from the swap\n    /// @param route List of the tokens to go through\n    /// @param amountIn Swap amount in\n    /// @return quote The Quote structure containing the necessary element to perform the swap\n    function findBestPathFromAmountIn(\n        address[] calldata route,\n        uint128 amountIn\n    ) external view returns (Quote memory quote);\n\n    /// @notice Finds the best path given a list of tokens and the output amount wanted from the swap\n    /// @param route List of the tokens to go through\n    /// @param amountOut Swap amount out\n    /// @return quote The Quote structure containing the necessary element to perform the swap\n    function findBestPathFromAmountOut(\n        address[] calldata route,\n        uint128 amountOut\n    ) external view returns (Quote memory quote);\n}\n"
        },
        "contracts/interfaces/marketplace/exchange/iota/ILBMagicSeaRouter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @title ILBMagicSeaRouter\n/// @notice Minimal interface for the LBMagicSea Router.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface ILBMagicSeaRouter {\n    /// @notice This enum represents the version of the pair requested.\n    /// @dev V1: Joe V1 pair, V2: LB pair V2. Also called legacyPair, V2_1: LB pair V2.1 (current version)\n    enum Version {\n        V1,\n        V2,\n        V2_1\n    }\n\n    /// @notice The liquidity parameters\n    /// @param tokenX The address of token X\n    /// @param tokenY The address of token Y\n    /// @param binStep The bin step of the pair\n    /// @param amountX The amount to send of token X\n    /// @param amountY The amount to send of token Y\n    /// @param amountXMin The min amount of token X added to liquidity\n    /// @param amountYMin The min amount of token Y added to liquidity\n    /// @param activeIdDesired The active id that user wants to add liquidity from\n    /// @param idSlippage The number of id that are allowed to slip\n    /// @param deltaIds The list of delta ids to add liquidity (`deltaId = activeId - desiredId`)\n    /// @param distributionX The distribution of tokenX with sum(distributionX) = 1e18 (100%) or 0 (0%)\n    /// @param distributionY The distribution of tokenY with sum(distributionY) = 1e18 (100%) or 0 (0%)\n    /// @param to The address of the recipient\n    /// @param refundTo The address of the recipient of the refunded tokens if too much tokens are sent\n    /// @param deadline The deadline of the transaction\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        address refundTo;\n        uint256 deadline;\n    }\n\n    /// @notice The path parameters\n    /// @param pairBinSteps The list of bin steps of the pairs to go through\n    /// @param versions The list of versions of the pairs to go through\n    /// @param tokenPath The list of tokens in the path to go through\n    struct Path {\n        uint256[] pairBinSteps;\n        Version[] versions;\n        IERC20[] tokenPath;\n    }\n\n    /// @param amountIn The exact amount of input tokens to send\n    /// @param amountOutMin The minimum amount of output tokens to receive; reverts if not met\n    /// @param path Defines the swap path with pairs' bin steps, versions, and token sequence\n    /// @param to The recipient address of the output tokens\n    /// @param deadline The timestamp by which the transaction must be executed\n    /// @return amountOut The actual amount of output tokens received\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    /// @notice Swaps tokens to receive an exact amount of output tokens along a specified path, using a maximum input limit\n    /// @dev The caller must approve the router to spend up to `amountInMax` of the first token in the path\n    /// @param amountOut The exact amount of output tokens to receive\n    /// @param amountInMax The maximum allowable input tokens to spend; reverts if exceeded\n    /// @param path Defines the swap path with pairs' bin steps, versions, and token sequence\n    /// @param to The recipient address of the output tokens\n    /// @param deadline The timestamp by which the transaction must be executed\n    /// @return amountsIn An array of input amounts used at each swap step in the path\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n}\n"
        },
        "contracts/interfaces/marketplace/vault/IGildiExchangePurchaseVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title IGildiExchangePurchaseVault\n/// @notice Interface for USD Treasury Purchase Vault operations\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiExchangePurchaseVault {\n    /// @notice Execution context used for intent execution with marketplace purchase parameters.\n    /// @param releaseId represents the marketplace token identifier (e.g., releaseId).\n    /// @param amount is the quantity intended to purchase.\n    /// @param buyer is the wallet that will perform the purchase on the marketplace.\n    struct ExecutionContext {\n        uint256 releaseId;\n        uint256 amount;\n        address buyer;\n    }\n\n    /// @notice Gets remaining USD value for an intent\n    /// @param _intentId The intent to query\n    /// @return remaining The remaining USD value in cents\n    function remainingUsd(bytes32 _intentId) external view returns (uint256 remaining);\n\n    /// @notice Executes a purchase intent by sending tokens to beneficiary\n    /// @param _intentId The intent to execute\n    /// @param _tokenHint Preferred token address (optional)\n    /// @param _ctx Execution context including releaseId, amount and buyer for optimal selection\n    /// @return token The token that was sent\n    /// @return tokenAmount The amount of tokens sent\n    function executeIntent(\n        bytes32 _intentId,\n        address _tokenHint,\n        ExecutionContext calldata _ctx\n    ) external returns (address token, uint256 tokenAmount);\n\n    /// @notice Settles a funded intent with actual USD spent and handles token refunds\n    /// @param _intentId The intent to settle\n    /// @param _actualUsdSpentCents Actual USD spent in vault cents (2 decimals)\n    /// @param _refundToken Token address for refunds (address(0) if no refund)\n    /// @param _refundTokenAmount Amount of tokens being refunded\n    function settleIntent(\n        bytes32 _intentId,\n        uint256 _actualUsdSpentCents,\n        address _refundToken,\n        uint256 _refundTokenAmount\n    ) external;\n\n    /// @notice Checks if vault can fund a purchase with current token balances\n    /// @param _intentValueUsdCents Intent value in USD cents\n    /// @param _releaseId Release ID for purchase estimation\n    /// @param _amount Amount of tokens to purchase\n    /// @param _buyer Buyer address for estimation\n    /// @return canFund True if purchase can be funded\n    /// @return bestToken Address of the most cost-effective token (zero if can't fund)\n    /// @return estimatedCost Estimated cost in best token (zero if can't fund)\n    function canFundPurchase(\n        uint256 _intentValueUsdCents,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer\n    ) external view returns (bool canFund, address bestToken, uint256 estimatedCost);\n}\n"
        },
        "contracts/interfaces/oracles/price/IGildiPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport './IGildiPriceResolver.sol';\n\n/// @title Gildi Price Oracle Interface\n/// @notice Interface for the consumer-facing Gildi Price Oracle\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiPriceOracle is IGildiPriceResolver {\n    /// @notice Represents an asset in the system\n    struct Asset {\n        /// @dev Unique identifier for the asset\n        uint256 id;\n        /// @dev The asset's symbol (e.g., BTC, ETH)\n        string symbol;\n        /// @dev The asset's full name\n        string name;\n    }\n\n    /// @notice Information about a trading pair\n    struct PairInfo {\n        /// @dev Unique identifier for the pair\n        bytes32 pairId;\n        /// @dev The base asset in the pair\n        Asset baseAsset;\n        /// @dev The quote asset in the pair\n        Asset quoteAsset;\n    }\n\n    /// @dev Thrown when an invalid pair ID is provided\n    error InvalidPairId();\n\n    /// @notice Adds a pair using asset IDs\n    /// @param _baseAssetId The ID of the base asset\n    /// @param _quoteAssetId The ID of the quote asset\n    /// @param _resolver The resolver contract for the asset pair\n    function addPair(uint256 _baseAssetId, uint256 _quoteAssetId, IGildiPriceResolver _resolver) external;\n\n    /// @notice Retrieves the resolver for a specific asset pair\n    /// @param _pairId The identifier of the asset pair\n    function getResolver(bytes32 _pairId) external view returns (IGildiPriceResolver resolver);\n\n    /// @notice Fetches a list of all registered pairs in \"BASE/QUOTE\" string form\n    /// @return An array of registered pairs\n    function getPairs() external view returns (PairInfo[] memory);\n\n    /// @notice Adds a new asset\n    /// @param _symbol The symbol of the asset\n    /// @param _name The name of the asset\n    /// @return The ID of the newly added asset\n    function addAsset(string memory _symbol, string memory _name) external returns (uint256);\n\n    /// @notice Returns all registered assets\n    /// @return An array of registered assets\n    function getAssets() external view returns (Asset[] memory);\n\n    /// @notice Returns an asset by ID\n    /// @param _assetId The ID of the asset\n    /// @return The asset details\n    function getAssetById(uint256 _assetId) external view returns (Asset memory);\n\n    /// @notice Returns pairs that use the specified asset ID as quote\n    /// @param _quoteAssetId The ID of the quote asset\n    /// @return An array of registered pairs\n    function getPairsByQuoteAsset(uint256 _quoteAssetId) external view returns (string[] memory);\n\n    /// @notice Retrieves price data by numeric IDs\n    /// @param _baseAssetId The ID of the base asset\n    /// @param _quoteAssetId The ID of the quote asset\n    /// @return The price data for the asset pair\n    function getPriceById(uint256 _baseAssetId, uint256 _quoteAssetId) external view returns (PriceData memory);\n\n    /// @notice Checks if a pair with the given ID exists\n    /// @param _pairId The identifier of the asset pair\n    /// @return True if the pair exists\n    function pairExistsById(bytes32 _pairId) external view returns (bool);\n}\n"
        },
        "contracts/interfaces/oracles/price/IGildiPriceResolver.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\n/// @title Gildi Price Resolver Interface\n/// @notice Interface that all price resolvers must implement\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer\ninterface IGildiPriceResolver {\n    /// @notice Price data struct\n    struct PriceData {\n        /// @notice The price of the base asset in terms of the quote asset\n        uint256 price;\n        /// @notice The number of decimals for the price\n        uint8 decimals;\n        /// @notice The UNIX timestamp when the price was last updated\n        uint256 timestamp;\n    }\n\n    /// @notice Retrieves the price data for a given pair ID\n    /// @param pairId The identifier of the asset pair\n    /// @return price The price data for the asset pair\n    function getPrice(bytes32 pairId) external view returns (PriceData memory price);\n\n    /// @notice Retrieves the price data for a given pair ID, with a maximum age\n    /// @param pairId The identifier of the asset pair\n    /// @param age The maximum age of the price data in seconds\n    function getPriceNoOlderThan(bytes32 pairId, uint256 age) external view returns (PriceData memory priceData);\n}\n"
        },
        "contracts/interfaces/token/IERC20Burnable.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\n/// @title IERC20Burnable\n/// @notice Interface for openzeppelin ERC20Burnable\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ninterface IERC20Burnable {\n    /// @notice Destroys a `value` amount of tokens from the caller.\n    /// @param value The amount of tokens to destroy.\n    function burn(uint256 value) external;\n\n    /// @notice Destroys a `value` amount of tokens from `account`, deducting from the caller's allowance.\n    /// @param account The account to destroy the tokens from.\n    /// @param value The amount of tokens to destroy.\n    function burnFrom(address account, uint256 value) external;\n}\n"
        },
        "contracts/interfaces/token/IGildiToken.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\n\n/// @title IGildiToken\n/// @notice Interface for tokens of the Gildi platform.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ninterface IGildiToken is IERC1155 {\n    /// @notice The balance of a specific token for an address.\n    struct TokenBalance {\n        /// @notice The token ID.\n        uint256 tokenId;\n        /// @notice The balance of the token.\n        uint256 balance;\n    }\n\n    struct MintBatch {\n        address to;\n        uint256[] ids;\n        uint256[] amounts;\n        bytes data;\n    }\n\n    /// @notice Pause the contract.\n    function pause() external;\n\n    /// @notice Unpause the contract.\n    function unpause() external;\n\n    /// @notice The name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice The symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Fetch the total supply of a specific token.\n    /// @param _id The ID of the token.\n    /// @return The total supply of the token.\n    function totalSupply(uint256 _id) external view returns (uint256);\n\n    /// @notice Fetch the total supply of all tokens.\n    /// @return The total supply of all tokens.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Check if a token exists.\n    /// @param _id The ID of the token.\n    /// @return True if the token exists, false otherwise.\n    function exists(uint256 _id) external view returns (bool);\n\n    /// @notice Mint a specific amount of a token.\n    /// @param _account The address to mint the token to.\n    /// @param _id The ID of the token.\n    /// @param _amount The amount of the token to mint.\n    /// @param _data The data to pass to the receiver.\n    function mint(address _account, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n    /// @notice Batch mint a specific amount of tokens.\n    /// @param _to The address to mint the tokens to.\n    /// @param _ids The IDs of the tokens.\n    /// @param _amounts The amounts of the tokens to mint.\n    /// @param _data The data to pass to the receiver.\n    function mintBatch(\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external;\n\n    /// @notice Batch mint to many addresses.\n    /// @param _mintBatches The mint batches.\n    function mintBatchMany(MintBatch[] calldata _mintBatches) external;\n\n    /// @notice Burn a specific amount of a token.\n    /// @param _account The address to burn the token from.\n    /// @param _id The ID of the token.\n    /// @param _value The amount of the token to burn.\n    function burn(address _account, uint256 _id, uint256 _value) external;\n\n    /// @notice Burn a specific amount of a token in a batch.\n    /// @param _account The address to burn the token from.\n    /// @param _ids The IDs of the tokens.\n    /// @param _values The amounts of the tokens to burn.\n    function burnBatch(address _account, uint256[] calldata _ids, uint256[] calldata _values) external;\n\n    /// @notice Burn all tokens of a specific ID.\n    /// @param _id The ID of the token.\n    function burnAllById(uint256 _id) external;\n\n    /// @notice Fetch all tokens and their balances of an owner.\n    /// @param _account The address of the owner.\n    function tokensOfOwner(address _account) external view returns (TokenBalance[] memory ownedTokens);\n}\n"
        },
        "contracts/interfaces/wallet/IGildiWalletConfigRegistry.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title IGildiWalletConfigRegistry\n/// @notice Interface for centralized configuration registry for all wallet instances\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ninterface IGildiWalletConfigRegistry {\n    /// @notice Wallet configuration for marketplace integration\n    struct WalletConfig {\n        /// @dev Address of the GildiExchange contract\n        address gildiExchangeV2;\n        /// @dev Address of the RoyaltyDistributor contract\n        address royaltyDistributor;\n        /// @dev Address of the GildiManager contract\n        address gildiManager;\n        /// @dev Address of the PaymentAggregator contract for marketplace operations\n        address paymentAggregator;\n        /// @dev Address of the GildiExchangePurchaseVault contract for USD treasury operations\n        address purchaseVault;\n    }\n\n    /// @dev Emitted when global configuration is updated\n    event GlobalConfigUpdated(uint256 indexed version, WalletConfig config);\n\n    /// @notice Sets configuration for a specific logic contract version\n    /// @dev Only callable by accounts with CONFIG_MANAGER_ROLE. Version 0 is the default config.\n    /// @param _version The logic contract version this config applies to (0 = default)\n    /// @param _config The configuration for this version\n    function setConfigForVersion(uint256 _version, WalletConfig calldata _config) external;\n\n    /// @notice Gets configuration for a specific logic contract version\n    /// @dev Returns the config for the specified version, or version 0 (default) if not found\n    /// @param _version The logic contract version to get config for\n    /// @return The configuration for this version\n    function getConfigForVersion(uint256 _version) external view returns (WalletConfig memory);\n\n    /// @notice Gets the default global configuration (version 0)\n    /// @return config The default global configuration\n    function getDefaultConfig() external view returns (WalletConfig memory config);\n\n    /// @notice Checks if a configuration exists for a specific version\n    /// @param _version The version to check\n    /// @return exists Whether configuration exists for this version\n    function hasConfigForVersion(uint256 _version) external view returns (bool exists);\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/core/FullMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = Math.mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/core/SqrtPriceMath.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {FullMath, Math} from './FullMath.sol';\nimport {SafeCast} from '@uniswap/v3-core/contracts/libraries/SafeCast.sol';\nimport {UnsafeMath} from '@uniswap/v3-core/contracts/libraries/UnsafeMath.sol';\nimport {FixedPoint96} from '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product;\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1)\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : Math.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            unchecked {\n                return uint160(sqrtPX96 - quotient);\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            require(sqrtRatioAX96 > 0);\n\n            return\n                roundUp\n                    ? UnsafeMath.divRoundingUp(\n                        FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n                        sqrtRatioAX96\n                    )\n                    : Math.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            return\n                roundUp\n                    ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n                    : Math.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n        }\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        unchecked {\n            return\n                liquidity < 0\n                    ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                    : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        unchecked {\n            return\n                liquidity < 0\n                    ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                    : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/core/SwapMath.sol": {
            "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport './FullMath.sol';\nimport {SqrtPriceMath} from './SqrtPriceMath.sol';\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n            bool exactIn = amountRemaining >= 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee = Math.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n                else\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtRatioCurrentX96,\n                        liquidity,\n                        amountRemainingLessFee,\n                        zeroForOne\n                    );\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n                if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n                else\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                        sqrtRatioCurrentX96,\n                        liquidity,\n                        uint256(-amountRemaining),\n                        zeroForOne\n                    );\n            }\n\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n            // get the input/output amounts\n            if (zeroForOne) {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n            } else {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n            }\n\n            // cap the output amount to not exceed the remaining output amount\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\n                amountOut = uint256(-amountRemaining);\n            }\n\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n                // we didn't reach the target, so take the remainder of the maximum input as fee\n                feeAmount = uint256(amountRemaining) - amountIn;\n            } else {\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n            }\n        }\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/core/TickMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi\n                ? tickLow\n                : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n                    ? tickHi\n                    : tickLow;\n        }\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/periphery/BytesLib.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.8.0;\n\nlibrary BytesLib {\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/periphery/Path.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport './BytesLib.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path) internal pure returns (address tokenA, address tokenB, uint24 fee) {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/periphery/PoolAddress.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xa598dd2fba360510c5a8f02f44423a4468e902df5857dbce3ca162a43a3a31ff;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {    \n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/periphery/TransferHelper.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/quoter/PoolAddress.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity ^0.8.0;\n\n/// @title PoolAddress Library\n/// @notice Provides functions for computing Uniswap V3 pool addresses\n/// @author Gildi Company\nlibrary PoolAddress {\n    /// @dev The init code hash used in the pool address calculation\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice Represents the identifying key for a Uniswap V3 pool\n    /// @param token0 The first token of the pair\n    /// @param token1 The second token of the pair\n    /// @param fee The fee level of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @dev Creates a pool key for the given tokens and fee\n    /// @param _tokenA The first token of the pair\n    /// @param _tokenB The second token of the pair\n    /// @param _fee The fee level of the pool\n    /// @return key The pool key with tokens sorted by address\n    function getPoolKey(address _tokenA, address _tokenB, uint24 _fee) internal pure returns (PoolKey memory key) {\n        if (_tokenA > _tokenB) (_tokenA, _tokenB) = (_tokenB, _tokenA);\n        return PoolKey({token0: _tokenA, token1: _tokenB, fee: _fee});\n    }\n\n    /// @dev Computes the address of a Uniswap V3 pool from its components\n    /// @param _factory The Uniswap V3 factory contract address\n    /// @param _key The PoolKey for the desired pool\n    /// @return pool The calculated address of the pool\n    function computePoolAddress(address _factory, PoolKey memory _key) internal pure returns (address pool) {\n        (address token0, address token1) = (_key.token0, _key.token1);\n        if (token0 > token1) (token0, token1) = (token1, token0);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            _factory,\n                            keccak256(abi.encode(_key.token0, _key.token1, _key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/quoter/PoolTickBitmap.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity ^0.8.0;\n\nimport {IUniswapV3Pool} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {BitMath} from '@uniswap/v3-core/contracts/libraries/BitMath.sol';\n\n/// @title PoolTickBitmap Library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @author Gildi Company\nlibrary PoolTickBitmap {\n    /// @dev Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param _tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 _tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        unchecked {\n            wordPos = int16(_tick >> 8);\n            bitPos = uint8(int8(_tick % 256));\n        }\n    }\n\n    /// @dev Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param _pool The pool for which to get the tick\n    /// @param _tick The starting tick\n    /// @param _tickSpacing The spacing between usable ticks\n    /// @param _lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        IUniswapV3Pool _pool,\n        int24 _tickSpacing,\n        int24 _tick,\n        bool _lte\n    ) internal view returns (int24 next, bool initialized) {\n        int24 compressed = _tick / _tickSpacing;\n        if (_tick < 0 && _tick % _tickSpacing != 0) compressed--; // round towards negative infinity\n\n        if (_lte) {\n            (int16 wordPos, uint8 bitPos) = position(compressed);\n            uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n            uint256 masked = _pool.tickBitmap(wordPos) & mask;\n\n            initialized = masked != 0;\n            next = initialized\n                ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * _tickSpacing\n                : (compressed - int24(uint24(bitPos))) * _tickSpacing;\n        } else {\n            (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n            uint256 mask = ~((1 << bitPos) - 1);\n            uint256 masked = _pool.tickBitmap(wordPos) & mask;\n\n            initialized = masked != 0;\n            next = initialized\n                ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * _tickSpacing\n                : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * _tickSpacing;\n        }\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/quoter/QuoterMath.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity ^0.8.0;\n\nimport {SwapMath} from '../core/SwapMath.sol';\nimport {TickMath} from '../core/TickMath.sol';\nimport {IUniswapV3Pool} from '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport {LowGasSafeMath} from '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\nimport {SafeCast} from '@uniswap/v3-core/contracts/libraries/SafeCast.sol';\nimport {LiquidityMath} from '@uniswap/v3-core/contracts/libraries/LiquidityMath.sol';\nimport {PoolTickBitmap} from './PoolTickBitmap.sol';\n\n/// @title QuoterMath Library\n/// @notice A library for performing quote calculations for Uniswap V3 pools\n/// @author Gildi Company\nlibrary QuoterMath {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    /// @notice Contains price and tick information for a pool\n    /// @param sqrtPriceX96 The current price as a sqrt price ratio\n    /// @param tick The current tick\n    /// @param tickSpacing The tick spacing configuration for the pool\n    struct Slot0 {\n        uint160 sqrtPriceX96;\n        int24 tick;\n        int24 tickSpacing;\n    }\n\n    /// @notice Parameters for quote calculation, packed to avoid stack limit issues\n    /// @param zeroForOne Whether the swap is from token0 to token1\n    /// @param exactInput Whether the swap is exact input or exact output\n    /// @param fee The fee tier of the pool\n    /// @param sqrtPriceLimitX96 The price limit of the swap in sqrt price\n    struct QuoteParams {\n        bool zeroForOne;\n        bool exactInput;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @dev Fills Slot0 struct with current pool state\n    /// @param _pool The Uniswap V3 pool to query\n    /// @return slot0 The filled Slot0 struct with current price and tick data\n    function fillSlot0(IUniswapV3Pool _pool) private view returns (Slot0 memory slot0) {\n        (slot0.sqrtPriceX96, slot0.tick, , , , , ) = _pool.slot0();\n        slot0.tickSpacing = _pool.tickSpacing();\n\n        return slot0;\n    }\n\n    /// @notice Caches data used during the swap calculation to avoid stack depth issues\n    /// @param feeProtocol The protocol fee for the input token\n    /// @param liquidityStart Liquidity at the beginning of the swap\n    /// @param blockTimestamp The timestamp of the current block\n    /// @param tickCumulative The current value of the tick accumulator, computed only if we cross an initialized tick\n    /// @param secondsPerLiquidityCumulativeX128 The current value of seconds per liquidity accumulator\n    /// @param computedLatestObservation Whether we've computed and cached the above two accumulators\n    struct SwapCache {\n        uint8 feeProtocol;\n        uint128 liquidityStart;\n        uint32 blockTimestamp;\n        int56 tickCumulative;\n        uint160 secondsPerLiquidityCumulativeX128;\n        bool computedLatestObservation;\n    }\n\n    /// @notice The top level state of the swap, tracks the calculation progress\n    /// @param amountSpecifiedRemaining The amount remaining to be swapped in/out of the input/output asset\n    /// @param amountCalculated The amount already swapped out/in of the output/input asset\n    /// @param sqrtPriceX96 Current sqrt(price) of the pool\n    /// @param tick The tick associated with the current price\n    /// @param feeGrowthGlobalX128 The global fee growth of the input token\n    /// @param protocolFee Amount of input token paid as protocol fee\n    /// @param liquidity The current liquidity in range\n    struct SwapState {\n        int256 amountSpecifiedRemaining;\n        int256 amountCalculated;\n        uint160 sqrtPriceX96;\n        int24 tick;\n        uint256 feeGrowthGlobalX128;\n        uint128 protocolFee;\n        uint128 liquidity;\n    }\n\n    /// @notice Intermediate calculations for a single step of a swap\n    /// @param sqrtPriceStartX96 The price at the beginning of the step\n    /// @param tickNext The next tick to swap to from the current tick in the swap direction\n    /// @param initialized Whether tickNext is initialized or not\n    /// @param sqrtPriceNextX96 sqrt(price) for the next tick (1/0)\n    /// @param amountIn How much is being swapped in in this step\n    /// @param amountOut How much is being swapped out\n    /// @param feeAmount How much fee is being paid in\n    struct StepComputations {\n        uint160 sqrtPriceStartX96;\n        int24 tickNext;\n        bool initialized;\n        uint160 sqrtPriceNextX96;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 feeAmount;\n    }\n\n    /// @notice Utility function called by the quote functions to calculate the amounts in/out for a v3 swap\n    /// @dev Returns (0,0,0,0) early if the input amount is zero or the pool does not exist (code size is zero)\n    /// @param _pool The Uniswap v3 pool interface to query for the swap\n    /// @param _amount The amount to swap (positive for exactInput, negative for exactOutput)\n    /// @param _quoteParams A packed struct of parameters used during quote calculation\n    /// @return amount0 The amount of token0 sent in or out of the pool\n    /// @return amount1 The amount of token1 sent in or out of the pool\n    /// @return sqrtPriceAfterX96 The square root price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks crossed during the swap\n    function quote(\n        IUniswapV3Pool _pool,\n        int256 _amount,\n        QuoteParams memory _quoteParams\n    )\n        internal\n        view\n        returns (int256 amount0, int256 amount1, uint160 sqrtPriceAfterX96, uint32 initializedTicksCrossed)\n    {\n        if (_amount == 0 || address(_pool).code.length == 0) {\n            return (0, 0, 0, 0);\n        }\n\n        _quoteParams.exactInput = _amount > 0;\n        initializedTicksCrossed = 1;\n\n        Slot0 memory slot0 = fillSlot0(_pool);\n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: _amount,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0.sqrtPriceX96,\n            tick: slot0.tick,\n            feeGrowthGlobalX128: 0,\n            protocolFee: 0,\n            liquidity: _pool.liquidity()\n        });\n\n        while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != _quoteParams.sqrtPriceLimitX96) {\n            StepComputations memory step;\n\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = PoolTickBitmap.nextInitializedTickWithinOneWord(\n                _pool,\n                slot0.tickSpacing,\n                state.tick,\n                _quoteParams.zeroForOne\n            );\n\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (\n                    _quoteParams.zeroForOne\n                        ? step.sqrtPriceNextX96 < _quoteParams.sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96 > _quoteParams.sqrtPriceLimitX96\n                )\n                    ? _quoteParams.sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                _quoteParams.fee\n            );\n\n            if (_quoteParams.exactInput) {\n                state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n                state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());\n            } else {\n                state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());\n            }\n\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                if (step.initialized) {\n                    (, int128 liquidityNet, , , , , , ) = _pool.ticks(step.tickNext);\n\n                    if (_quoteParams.zeroForOne) liquidityNet = -liquidityNet;\n\n                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);\n\n                    initializedTicksCrossed++;\n                }\n\n                state.tick = _quoteParams.zeroForOne ? step.tickNext - 1 : step.tickNext;\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        (amount0, amount1) = _quoteParams.zeroForOne == _quoteParams.exactInput\n            ? (_amount - state.amountSpecifiedRemaining, state.amountCalculated)\n            : (state.amountCalculated, _amount - state.amountSpecifiedRemaining);\n\n        sqrtPriceAfterX96 = state.sqrtPriceX96;\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/staker/IncentiveId.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '../../../../../interfaces/external/uniswap/v3/staker/IUniswapV3Staker.sol';\n\nlibrary IncentiveId {\n    /// @notice Calculate the key for a staking incentive\n    /// @param key The components used to compute the incentive identifier\n    /// @return incentiveId The identifier for the incentive\n    function compute(IUniswapV3Staker.IncentiveKey memory key) internal pure returns (bytes32 incentiveId) {\n        return keccak256(abi.encode(key));\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/staker/NFTPositionInfo.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '../../../../../interfaces/external/uniswap/v3/INonfungiblePositionManager.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\n\nimport '../periphery/PoolAddress.sol';\n\n/// @notice Encapsulates the logic for getting info about a NFT token ID\nlibrary NFTPositionInfo {\n    /// @param factory The address of the Uniswap V3 Factory used in computing the pool address\n    /// @param nonfungiblePositionManager The address of the nonfungible position manager to query\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @return pool The address of the Uniswap V3 pool\n    /// @return tickLower The lower tick of the Uniswap V3 position\n    /// @return tickUpper The upper tick of the Uniswap V3 position\n    /// @return liquidity The amount of liquidity staked\n    function getPositionInfo(\n        IUniswapV3Factory factory,\n        INonfungiblePositionManager nonfungiblePositionManager,\n        uint256 tokenId\n    ) internal view returns (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) {\n        address token0;\n        address token1;\n        uint24 fee;\n        (, , token0, token1, fee, tickLower, tickUpper, liquidity, , , , ) = nonfungiblePositionManager.positions(\n            tokenId\n        );\n\n        pool = IUniswapV3Pool(\n            PoolAddress.computeAddress(\n                address(factory),\n                PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee})\n            )\n        );\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/staker/RewardMath.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\n/// @title Math for computing rewards\n/// @notice Allows computing rewards given some parameters of stakes and incentives\nlibrary RewardMath {\n    /// @notice Compute the amount of rewards owed given parameters of the incentive and stake\n    /// @param totalRewardUnclaimed The total amount of unclaimed rewards left for an incentive\n    /// @param totalSecondsClaimedX128 How many full liquidity-seconds have been already claimed for the incentive\n    /// @param startTime When the incentive rewards began in epoch seconds\n    /// @param endTime When rewards are no longer being dripped out in epoch seconds\n    /// @param liquidity The amount of liquidity, assumed to be constant over the period over which the snapshots are measured\n    /// @param secondsPerLiquidityInsideInitialX128 The seconds per liquidity of the liquidity tick range as of the beginning of the period\n    /// @param secondsPerLiquidityInsideX128 The seconds per liquidity of the liquidity tick range as of the current block timestamp\n    /// @param currentTime The current block timestamp, which must be greater than or equal to the start time\n    /// @return reward The amount of rewards owed\n    /// @return secondsInsideX128 The total liquidity seconds inside the position's range for the duration of the stake\n    function computeRewardAmount(\n        uint256 totalRewardUnclaimed,\n        uint160 totalSecondsClaimedX128,\n        uint256 startTime,\n        uint256 endTime,\n        uint128 liquidity,\n        uint160 secondsPerLiquidityInsideInitialX128,\n        uint160 secondsPerLiquidityInsideX128,\n        uint256 currentTime\n    ) internal pure returns (uint256 reward, uint160 secondsInsideX128) {\n        // this should never be called before the start time\n        assert(currentTime >= startTime);\n\n        // this operation is safe, as the difference cannot be greater than 1/stake.liquidity\n        secondsInsideX128 = (secondsPerLiquidityInsideX128 - secondsPerLiquidityInsideInitialX128) * liquidity;\n\n        uint256 totalSecondsUnclaimedX128 = ((Math.max(endTime, currentTime) - startTime) << 128) -\n            totalSecondsClaimedX128;\n\n        reward = Math.mulDiv(totalRewardUnclaimed, secondsInsideX128, totalSecondsUnclaimedX128);\n    }\n}\n"
        },
        "contracts/libraries/external/uniswap/v3/staker/TransferHelperExtended.sol": {
            "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '../periphery/TransferHelper.sol';\n\nlibrary TransferHelperExtended {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(_isContract(token), 'TransferHelperExtended::safeTransferFrom: call to non-contract');\n        TransferHelper.safeTransferFrom(token, from, to, value);\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        require(_isContract(token), 'TransferHelperExtended::safeTransfer: call to non-contract');\n        TransferHelper.safeTransfer(token, to, value);\n    }\n\n    /// @notice Unsafe way of checking if a contract exists, but okay for our use case\n    /// @param addr The address to check\n    /// @return Whether the address is a contract\n    function _isContract(address addr) internal view returns (bool) {\n        return addr.code.length > 0;\n    }\n}\n"
        },
        "contracts/libraries/marketplace/exchange/SharedErrors.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title SharedErrors\n/// @notice Common error definitions shared across Gildi Exchange contracts\n/// @dev This library consolidates error definitions to avoid duplication\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\nlibrary SharedErrors {\n    /// @dev Emitted when a function parameter is invalid or out-of-range (e.g. zero batchSize, zero price, etc.)\n    error ParamError();\n\n    /// @dev Emitted when an operation is not allowed for the caller\n    error NotAllowed();\n\n    /// @dev Emitted when the caller is invalid\n    error InvalidCaller();\n\n    /// @dev Emitted when a listing ID is invalid or does not match storage data\n    /// @param listingId The ID that caused the error\n    error ListingError(uint256 listingId);\n}\n"
        },
        "contracts/manager/GildiManager.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/utils/structs/EnumerableMap.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport '../interfaces/manager/IGildiManager.sol';\nimport '../interfaces/token/IGildiToken.sol';\nimport './GildiManagerOwnershipStorage.sol';\n\n/// @title GildiManager\n/// @notice A contract which tracks ownership of ERC1155 RWAs and allows for the transfer of ownership.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract GildiManager is\n    Initializable,\n    AccessControlUpgradeable,\n    ERC1155HolderUpgradeable,\n    IGildiManager,\n    ReentrancyGuardUpgradeable\n{\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /// @notice A role that allows the contract to manage releases.\n    bytes32 public constant RELEASE_MANAGER_ROLE = keccak256('RELEASE_MANAGER_ROLE');\n    /// @notice A role for marketplace contracts.\n    bytes32 public constant MARKETPLACE_ROLE = keccak256('MARKETPLACE_ROLE');\n    /// @notice A role for the admin.\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    enum Roles {\n        RELEASE_MANAGER,\n        MARKETPLACE,\n        ADMIN\n    }\n\n    /// @notice The Gildi token contract.\n    IGildiToken public gildiToken;\n    /// @notice An array of releases.\n    uint256[] public rwaReleaseIds;\n\n    /// @notice Whether a release exists.\n    mapping(uint256 => bool) private existingReleases;\n\n    /// @notice The RWA releases.\n    mapping(uint256 => IGildiManager.RWARelease) public rwaReleases;\n\n    /// @notice The owners of a token.\n    mapping(uint256 => address[]) private tokenOwners;\n\n    /// @notice If a user is the owner of a token.\n    mapping(address => mapping(uint256 => bool)) private isTokenOwner;\n\n    /// @notice How many of a token is owned by a user.\n    mapping(uint256 => mapping(address => TokenBalance)) private userTokenBalance;\n\n    /// @notice Mapping of ownership storages.\n    mapping(uint256 => GildiManagerOwnershipStorage) public releaseOwnershipStorages;\n\n    /// @notice Throws if the caller does not have any of the required roles.\n    error AccessControlUnauthorizedAccountAny(address account, bytes32[] roles);\n    error ReleaseAlreadyExists(uint256 tokenId);\n    error AmountMustBeGreaterThanZero();\n    error ReleaseDoesNotExist(uint256 tokenId);\n    error SharesMustNotBeEmpty();\n    error TooManyShares(uint256 maxShares);\n    error ReleaseIsDeleting(uint256 tokenId);\n    error InsufficientUnassignedShares(uint256 unassignedShares, uint256 requiredAmount);\n    error WrongInitialSaleState(bool expectedState, bool actualState);\n    error InvalidBatchSize(uint256 batchSizeMin, uint256 batchSizeMax);\n    error NotFullyAssignedShares();\n    error InsufficientAvailableBalance(uint256 tokenId, address account);\n    error ReleaseTokenAlreadyExists(uint256 tokenId);\n    error InvalidLockState(bool expectedState, bool actualState);\n    error AddressZeroNotAllowed();\n\n    event ReleaseUnlocked(uint256 indexed releaseId);\n    event ReleaseCreated(uint256 indexed releaseId, uint256 amount);\n    event ShareAssigned(uint256 indexed releaseId, address indexed user, uint256 shares);\n    event SharesAssigned(uint256 indexed releaseId, uint256 totalShares);\n    event InitialSaleStarted(uint256 indexed releaseId);\n    event InitialSaleEnded(uint256 indexed releaseId);\n    event ReleaseMarkedForDeletion(uint256 indexed releaseId);\n    event ReleaseBatchDeleted(uint256 indexed releaseId, uint256 deletedShares, uint256 remainingOwners);\n    event ReleaseDeleted(uint256 indexed releaseId);\n    event TokenDeposited(uint256 indexed tokenId, address indexed account, uint256 amount);\n    event TokenWithdrawn(uint256 indexed tokenId, address indexed account, uint256 amount);\n    event TokenTransferred(uint256 indexed tokenId, address indexed from, address indexed to, uint256 amount);\n    event TokenUnlocked(uint256 indexed tokenId, address indexed account, uint256 amount);\n    event TokenLocked(uint256 indexed tokenId, address indexed account, uint256 amount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract.\n    /// @param _defaultAdmin The default admin.\n    /// @param _initialAdmin The initial admin.\n    /// @param _initialReleaseManager The initial release manager.\n    /// @param _rwaToken The RWA token contract.\n    function initialize(\n        address _defaultAdmin,\n        address _initialAdmin,\n        address _initialReleaseManager,\n        IGildiToken _rwaToken\n    ) public initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        if (_initialAdmin != address(0)) {\n            _grantRole(ADMIN_ROLE, _initialAdmin);\n        }\n        if (_initialReleaseManager != address(0)) {\n            _grantRole(RELEASE_MANAGER_ROLE, _initialReleaseManager);\n        }\n\n        gildiToken = _rwaToken;\n    }\n\n    /// @inheritdoc IGildiManager\n    function unlockRelease(\n        uint256 _releaseId\n    ) public override whenLocked(_releaseId) onlyRoleAny(_rolesReleaseManagerMarketplace()) {\n        RWARelease storage release = rwaReleases[_releaseId];\n\n        if (release.unassignedShares != 0) {\n            revert NotFullyAssignedShares();\n        }\n        if (release.deleting) {\n            revert ReleaseIsDeleting(_releaseId);\n        }\n        if (release.inInitialSale) {\n            revert WrongInitialSaleState(!release.inInitialSale, release.inInitialSale);\n        }\n\n        release.locked = false;\n        release.unlockedAt = block.timestamp;\n\n        emit ReleaseUnlocked(_releaseId);\n    }\n\n    /// @inheritdoc IGildiManager\n    function getAllReleaseIds() external view returns (uint256[] memory) {\n        return rwaReleaseIds;\n    }\n\n    /// @inheritdoc IGildiManager\n    function releaseExists(uint256 _releaseId) public view override returns (bool) {\n        return existingReleases[_releaseId];\n    }\n\n    /// @inheritdoc IGildiManager\n    function getAvailableBalance(uint256 _tokenId, address _account) public view override returns (uint256) {\n        TokenBalance memory balance = userTokenBalance[_tokenId][_account];\n        return balance.amount - balance.lockedAmount;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) public view override(AccessControlUpgradeable, ERC1155HolderUpgradeable, IERC165) returns (bool) {\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(IGildiManager).interfaceId;\n    }\n\n    /// @inheritdoc IGildiManager\n    function createNewRelease(\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _ownershipTrackingTimePeriod\n    ) external override onlyRole(RELEASE_MANAGER_ROLE) {\n        if (_ownershipTrackingTimePeriod == 0) {\n            _ownershipTrackingTimePeriod = 30 minutes;\n        }\n\n        if (releaseExists(_tokenId) || gildiToken.exists(_tokenId)) {\n            revert ReleaseAlreadyExists(_tokenId);\n        }\n\n        if (_amount == 0) {\n            revert AmountMustBeGreaterThanZero();\n        }\n\n        gildiToken.mint(address(this), _tokenId, _amount, '');\n\n        rwaReleases[_tokenId] = RWARelease(_tokenId, true, 0, false, _amount, _amount, 0, false, 0, block.timestamp);\n        rwaReleaseIds.push(_tokenId);\n        existingReleases[_tokenId] = true;\n\n        releaseOwnershipStorages[_tokenId] = new GildiManagerOwnershipStorage(_tokenId, _ownershipTrackingTimePeriod);\n\n        emit ReleaseCreated(_tokenId, _amount);\n    }\n\n    /// @inheritdoc IGildiManager\n    function assignShares(\n        uint256 _releaseId,\n        UserShare[] calldata _sharesBatch\n    ) external override whenLocked(_releaseId) onlyRole(RELEASE_MANAGER_ROLE) {\n        if (_sharesBatch.length == 0) {\n            revert SharesMustNotBeEmpty();\n        }\n        if (_sharesBatch.length > 100) {\n            revert TooManyShares(100);\n        }\n\n        RWARelease storage release = rwaReleases[_releaseId];\n        if (release.deleting) {\n            revert ReleaseIsDeleting(_releaseId);\n        }\n\n        uint256 totalShares = 0;\n        for (uint i = 0; i < _sharesBatch.length; i++) {\n            totalShares += _sharesBatch[i].shares;\n\n            _creditToken(_releaseId, _sharesBatch[i].user, _sharesBatch[i].shares);\n\n            emit ShareAssigned(_releaseId, _sharesBatch[i].user, _sharesBatch[i].shares);\n        }\n\n        if (totalShares > release.unassignedShares) {\n            revert InsufficientUnassignedShares(release.unassignedShares, totalShares);\n        }\n\n        release.unassignedShares -= totalShares;\n\n        emit SharesAssigned(_releaseId, totalShares);\n    }\n\n    /// @inheritdoc IGildiManager\n    function startInitialSale(uint256 _releaseId) external override whenLocked(_releaseId) onlyRole(MARKETPLACE_ROLE) {\n        RWARelease storage release = rwaReleases[_releaseId];\n\n        if (release.inInitialSale) {\n            revert WrongInitialSaleState(!release.inInitialSale, release.inInitialSale);\n        }\n        if (release.deleting) {\n            revert ReleaseIsDeleting(_releaseId);\n        }\n        if (release.unassignedShares != 0) {\n            revert NotFullyAssignedShares();\n        }\n\n        release.inInitialSale = true;\n\n        emit InitialSaleStarted(_releaseId);\n    }\n\n    /// @inheritdoc IGildiManager\n    function endInitialSale(uint256 _releaseId) external override whenLocked(_releaseId) onlyRole(MARKETPLACE_ROLE) {\n        RWARelease storage release = rwaReleases[_releaseId];\n\n        if (!release.inInitialSale) {\n            revert WrongInitialSaleState(release.inInitialSale, !release.inInitialSale);\n        }\n\n        release.inInitialSale = false;\n        unlockRelease(_releaseId);\n\n        emit InitialSaleEnded(_releaseId);\n    }\n\n    /// @inheritdoc IGildiManager\n    function cancelInitialSale(uint256 _releaseId) external override whenLocked(_releaseId) onlyRole(MARKETPLACE_ROLE) {\n        RWARelease storage release = rwaReleases[_releaseId];\n\n        if (!release.inInitialSale) {\n            revert WrongInitialSaleState(release.inInitialSale, !release.inInitialSale);\n        }\n\n        release.inInitialSale = false;\n\n        emit InitialSaleEnded(_releaseId);\n    }\n\n    /// @inheritdoc IGildiManager\n    function batchDeleteRelease(\n        uint256 _releaseId,\n        uint256 _batchSizeOwners\n    ) external override whenLocked(_releaseId) onlyRole(RELEASE_MANAGER_ROLE) {\n        RWARelease storage release = rwaReleases[_releaseId];\n        if (_batchSizeOwners == 0 || _batchSizeOwners > 100) {\n            revert InvalidBatchSize(1, 100);\n        }\n        if (release.inInitialSale) {\n            revert WrongInitialSaleState(!release.inInitialSale, release.inInitialSale);\n        }\n\n        release.deleting = true;\n        emit ReleaseMarkedForDeletion(_releaseId);\n\n        // Delete the shares in batches. + Cleanup the ownership mapping.\n        for (uint i = 0; i < _batchSizeOwners; i++) {\n            if (tokenOwners[_releaseId].length == 0) {\n                break;\n            }\n\n            address user = tokenOwners[_releaseId][0];\n            uint256 amount = userTokenBalance[_releaseId][user].amount;\n\n            // Cleanup the ownership mapping.\n            releaseOwnershipStorages[_releaseId].deleteOwnerships(user);\n            delete userTokenBalance[_releaseId][user];\n            delete isTokenOwner[user][_releaseId];\n\n            // Remove the user from the tokenOwners array.\n            tokenOwners[_releaseId][0] = tokenOwners[_releaseId][tokenOwners[_releaseId].length - 1];\n            tokenOwners[_releaseId].pop();\n\n            release.deletedShares += amount;\n        }\n\n        // If we have deleted all shares, burn the token and delete the release.\n        if (tokenOwners[_releaseId].length == 0) {\n            gildiToken.burnAllById(_releaseId);\n            delete rwaReleases[_releaseId];\n            delete existingReleases[_releaseId];\n            for (uint i = 0; i < rwaReleaseIds.length; i++) {\n                if (rwaReleaseIds[i] == _releaseId) {\n                    rwaReleaseIds[i] = rwaReleaseIds[rwaReleaseIds.length - 1];\n                    rwaReleaseIds.pop();\n                    break;\n                }\n            }\n            delete releaseOwnershipStorages[_releaseId];\n            emit ReleaseDeleted(_releaseId);\n        }\n\n        emit ReleaseBatchDeleted(_releaseId, release.deletedShares, tokenOwners[_releaseId].length);\n    }\n\n    /// @inheritdoc IGildiManager\n    function deposit(\n        uint256 _tokenId,\n        address _account,\n        uint256 _amount\n    ) external override nonReentrant whenNotLocked(_tokenId) {\n        if (!releaseExists(_tokenId)) {\n            revert ReleaseDoesNotExist(_tokenId);\n        }\n        if (gildiToken.balanceOf(_account, _tokenId) < _amount) {\n            revert InsufficientAvailableBalance(_tokenId, _account);\n        }\n        if (_amount == 0) {\n            revert AmountMustBeGreaterThanZero();\n        }\n        if (_msgSender() != _account && !hasRole(ADMIN_ROLE, _msgSender())) {\n            revert AccessControlUnauthorizedAccount(_msgSender(), ADMIN_ROLE);\n        }\n\n        gildiToken.safeTransferFrom(_account, address(this), _tokenId, _amount, '');\n\n        _creditToken(_tokenId, _account, _amount);\n\n        emit TokenDeposited(_tokenId, _account, _amount);\n    }\n\n    /// @inheritdoc IGildiManager\n    function withdraw(\n        uint256 _tokenId,\n        address _account,\n        uint256 _amount\n    ) external override nonReentrant whenNotLocked(_tokenId) {\n        if (!releaseExists(_tokenId)) {\n            revert ReleaseDoesNotExist(_tokenId);\n        }\n        if (_msgSender() != _account && !hasRole(ADMIN_ROLE, _msgSender())) {\n            revert AccessControlUnauthorizedAccount(_msgSender(), ADMIN_ROLE);\n        }\n        if (getAvailableBalance(_tokenId, _account) < _amount) {\n            revert InsufficientAvailableBalance(_tokenId, _account);\n        }\n        if (_amount == 0) {\n            revert AmountMustBeGreaterThanZero();\n        }\n\n        gildiToken.safeTransferFrom(address(this), _account, _tokenId, _amount, '');\n\n        _debitToken(_tokenId, _account, _amount);\n\n        emit TokenWithdrawn(_tokenId, _account, _amount);\n    }\n\n    /// @inheritdoc IGildiManager\n    function transferOwnership(\n        uint256 _tokenId,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override nonReentrant whenNotLocked(_tokenId) {\n        if (_msgSender() != _from && !hasRole(ADMIN_ROLE, _msgSender()) && !hasRole(MARKETPLACE_ROLE, _msgSender())) {\n            bytes32[] memory roles = new bytes32[](2);\n            roles[0] = ADMIN_ROLE;\n            roles[1] = MARKETPLACE_ROLE;\n            revert AccessControlUnauthorizedAccountAny(_msgSender(), roles);\n        }\n\n        _transferOwnership(_tokenId, _from, _to, _amount);\n\n        emit TokenTransferred(_tokenId, _from, _to, _amount);\n    }\n\n    /// @inheritdoc IGildiManager\n    function transferOwnershipInitialSale(\n        uint256 _tokenId,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override nonReentrant onlyRole(MARKETPLACE_ROLE) {\n        RWARelease storage release = rwaReleases[_tokenId];\n        if (!release.inInitialSale) {\n            revert WrongInitialSaleState(release.inInitialSale, !release.inInitialSale);\n        }\n\n        _transferOwnership(_tokenId, _from, _to, _amount);\n\n        emit TokenTransferred(_tokenId, _from, _to, _amount);\n    }\n\n    /// @inheritdoc IGildiManager\n    function unlockTokens(\n        address _account,\n        uint256 _tokenId,\n        uint256 _amountToUnlock\n    ) external onlyRole(MARKETPLACE_ROLE) {\n        uint256 lockedAmount = userTokenBalance[_tokenId][_account].lockedAmount;\n        if (lockedAmount < _amountToUnlock) {\n            revert InsufficientAvailableBalance(_tokenId, _account);\n        }\n\n        userTokenBalance[_tokenId][_account].lockedAmount -= _amountToUnlock;\n\n        emit TokenUnlocked(_tokenId, _account, _amountToUnlock);\n    }\n\n    /// @inheritdoc IGildiManager\n    function lockTokens(address _account, uint256 _tokenId, uint256 _amountToLock) external onlyRole(MARKETPLACE_ROLE) {\n        uint256 availableBalance = getAvailableBalance(_tokenId, _account);\n        if (availableBalance < _amountToLock) {\n            revert InsufficientAvailableBalance(_tokenId, _account);\n        }\n\n        userTokenBalance[_tokenId][_account].lockedAmount += _amountToLock;\n\n        emit TokenLocked(_tokenId, _account, _amountToLock);\n    }\n\n    /// @notice Get the owners of a token.\n    /// @return The token owners.\n    function ownersOfToken(uint256 _tokenId) public view returns (address[] memory) {\n        return tokenOwners[_tokenId];\n    }\n\n    /// @inheritdoc IGildiManager\n    function getReleaseById(uint256 _releaseId) external view returns (RWARelease memory) {\n        return rwaReleases[_releaseId];\n    }\n\n    /// @inheritdoc IGildiManager\n    function isLocked(uint256 _releaseId) external view returns (bool) {\n        return rwaReleases[_releaseId].locked;\n    }\n\n    /// @inheritdoc IGildiManager\n    function isInInitialSale(uint256 _releaseId) external view returns (bool) {\n        return rwaReleases[_releaseId].inInitialSale;\n    }\n\n    /// @inheritdoc IGildiManager\n    function balanceOf(address _account) external view override returns (TokenBalance[] memory) {\n        TokenBalance[] memory balances = new TokenBalance[](rwaReleaseIds.length);\n\n        for (uint i = 0; i < rwaReleaseIds.length; i++) {\n            uint256 tokenId = rwaReleaseIds[i];\n            TokenBalance memory balance = userTokenBalance[tokenId][_account];\n            if (balance.tokenId != tokenId) {\n                balances[i] = TokenBalance(tokenId, 0, 0);\n            } else {\n                balances[i] = balance;\n            }\n        }\n\n        return balances;\n    }\n\n    /// @inheritdoc IGildiManager\n    function balanceOf(uint256 _tokenId, address _account) external view override returns (TokenBalance memory) {\n        TokenBalance memory balance = userTokenBalance[_tokenId][_account];\n        if (balance.tokenId != _tokenId) {\n            return TokenBalance(_tokenId, 0, 0);\n        }\n        return balance;\n    }\n\n    /// @inheritdoc IGildiManager\n    function isFullyAssigned(uint256 _releaseId) external view override returns (bool) {\n        RWARelease storage release = rwaReleases[_releaseId];\n        return releaseExists(_releaseId) && release.unassignedShares == 0;\n    }\n\n    /// @inheritdoc IGildiManager\n    function fetchSharesInPeriod(\n        uint256 _tokenId,\n        uint256 _start,\n        uint256 _end,\n        uint256 _cursor,\n        uint256 _limit\n    ) external view override returns (SharesReport memory) {\n        if (!releaseExists(_tokenId)) {\n            revert ReleaseDoesNotExist(_tokenId);\n        }\n\n        GildiManagerOwnershipStorage gildiOwnershipTracker = releaseOwnershipStorages[_tokenId];\n        uint256 TIME_PERIOD = gildiOwnershipTracker.TIME_PERIOD();\n\n        RWARelease storage release = rwaReleases[_tokenId];\n        uint256 releaseUnlockedAtNormalized = (release.unlockedAt / TIME_PERIOD) * TIME_PERIOD;\n\n        _start = (_start / TIME_PERIOD) * TIME_PERIOD;\n        _end = (_end / TIME_PERIOD) * TIME_PERIOD;\n\n        if (_start < releaseUnlockedAtNormalized) {\n            _start = releaseUnlockedAtNormalized;\n        }\n\n        if (_end <= _start) {\n            _end = _start + TIME_PERIOD; // Fetch at least one period.\n        }\n\n        uint256 totalShares = 0;\n\n        // Dynamic array for user shares\n        UserShare[] memory tempUserShares = new UserShare[](_limit);\n        bool hasMore = false;\n        uint256 nextCursor = _cursor;\n        uint256 count = 0;\n\n        address[] memory ownersByTokenId = gildiOwnershipTracker.fetchUsers();\n\n        // Iterate through each ownership and calculate the total number of shares.\n        for (uint256 i = _cursor; i < ownersByTokenId.length; i++) {\n            if (count >= _limit) {\n                hasMore = true;\n                break;\n            }\n\n            address user = ownersByTokenId[i];\n            GildiManagerOwnershipStorage.Ownership[] memory ownerships = gildiOwnershipTracker.fetchOwnerships(user);\n\n            // Iterate through each ownership and calculate the total number of shares, fill gaps with the last value.\n            uint256 shares = 0;\n            uint256 lastShares = ownerships.length > 0 ? ownerships[ownerships.length - 1].amount : 0;\n            uint256 lastTimestamp = (_start < releaseUnlockedAtNormalized ? releaseUnlockedAtNormalized : _start) -\n                TIME_PERIOD;\n\n            for (uint256 j = 0; j < ownerships.length; j++) {\n                GildiManagerOwnershipStorage.Ownership memory ownership = ownerships[j];\n\n                uint256 timestamp = ownership.timestamp;\n                if (timestamp == 0 && release.unlockedAt != 0) {\n                    timestamp = (release.unlockedAt / TIME_PERIOD) * TIME_PERIOD;\n                }\n                if (timestamp >= _start && timestamp < _end) {\n                    uint256 gapsToFill = ((timestamp - lastTimestamp) / TIME_PERIOD) - 1;\n                    if (gapsToFill > 0) {\n                        uint256 sharesToAdd = gapsToFill * lastShares;\n                        shares += sharesToAdd;\n                    }\n\n                    shares += ownership.amount;\n\n                    lastShares = ownership.amount;\n                    lastTimestamp = timestamp;\n                }\n            }\n\n            uint256 gapsToEnd = ((_end - lastTimestamp) / TIME_PERIOD) - 1;\n            if (gapsToEnd > 0) {\n                uint256 sharesToAdd = gapsToEnd * lastShares;\n                shares += sharesToAdd;\n            }\n\n            if (shares > 0) {\n                tempUserShares[count] = UserShare(user, shares);\n                totalShares += shares;\n                count++;\n            }\n\n            nextCursor++;\n        }\n\n        // Resize the array to the actual count\n        UserShare[] memory userShares = new UserShare[](count);\n        for (uint256 k = 0; k < count; k++) {\n            userShares[k] = tempUserShares[k];\n        }\n\n        return SharesReport(_tokenId, _start, _end, totalShares, userShares, hasMore, nextCursor);\n    }\n\n    function _transferOwnership(uint256 _tokenId, address _from, address _to, uint256 _amount) internal {\n        if (!releaseExists(_tokenId)) {\n            revert ReleaseDoesNotExist(_tokenId);\n        }\n\n        if (_to == address(0)) {\n            revert AddressZeroNotAllowed();\n        }\n\n        if (_amount == 0) {\n            revert AmountMustBeGreaterThanZero();\n        }\n\n        if (_from == _to) {\n            return;\n        }\n\n        if (getAvailableBalance(_tokenId, _from) < _amount) {\n            revert InsufficientAvailableBalance(_tokenId, _from);\n        }\n\n        _debitToken(_tokenId, _from, _amount);\n        _creditToken(_tokenId, _to, _amount);\n    }\n\n    function _creditToken(uint256 _tokenId, address _account, uint256 _amount) private {\n        GildiManagerOwnershipStorage gildiOwnershipTracker = releaseOwnershipStorages[_tokenId];\n        uint256 TIME_PERIOD = gildiOwnershipTracker.TIME_PERIOD();\n        GildiManagerOwnershipStorage.Ownership[] memory ownerships = gildiOwnershipTracker.fetchOwnerships(_account);\n\n        RWARelease storage release = rwaReleases[_tokenId];\n        uint256 timestamp = !release.locked ? (block.timestamp / TIME_PERIOD) * TIME_PERIOD : 0;\n\n        /// First balance processing, then ownership processing.\n        if (!isTokenOwner[_account][_tokenId]) {\n            tokenOwners[_tokenId].push(_account);\n            isTokenOwner[_account][_tokenId] = true;\n            userTokenBalance[_tokenId][_account] = TokenBalance(_tokenId, _amount, 0);\n        } else {\n            userTokenBalance[_tokenId][_account].amount += _amount;\n        }\n\n        // Now we process the ownerships.\n        if (ownerships.length == 0) {\n            gildiOwnershipTracker.pushOwnership(_account, GildiManagerOwnershipStorage.Ownership(_amount, timestamp));\n        } else {\n            GildiManagerOwnershipStorage.Ownership memory lastOwnership = ownerships[ownerships.length - 1];\n            bool lastOwnershipChanged = false;\n            if (lastOwnership.timestamp == 0 && !release.locked) {\n                lastOwnership.timestamp = (release.unlockedAt / TIME_PERIOD) * TIME_PERIOD;\n                lastOwnershipChanged = true;\n            }\n\n            uint256 newAmount = lastOwnership.amount + _amount;\n            if (lastOwnership.timestamp == timestamp) {\n                lastOwnership.amount = newAmount;\n                lastOwnershipChanged = true;\n            } else {\n                gildiOwnershipTracker.pushOwnership(\n                    _account,\n                    GildiManagerOwnershipStorage.Ownership(newAmount, timestamp)\n                );\n            }\n\n            if (lastOwnershipChanged) {\n                gildiOwnershipTracker.updateOwnershipEntry(_account, ownerships.length - 1, lastOwnership);\n            }\n        }\n    }\n\n    function _debitToken(uint256 _tokenId, address _account, uint256 _amount) private {\n        GildiManagerOwnershipStorage ownershipTracker = releaseOwnershipStorages[_tokenId];\n        uint256 TIME_PERIOD = ownershipTracker.TIME_PERIOD();\n        GildiManagerOwnershipStorage.Ownership[] memory ownerships = ownershipTracker.fetchOwnerships(_account);\n\n        RWARelease storage release = rwaReleases[_tokenId];\n        uint256 newAmount = userTokenBalance[_tokenId][_account].amount - _amount;\n        uint256 timestamp = !release.locked ? (block.timestamp / TIME_PERIOD) * TIME_PERIOD : 0;\n\n        // First balance processing\n        if (newAmount != 0) {\n            userTokenBalance[_tokenId][_account].amount = newAmount;\n        } else {\n            delete userTokenBalance[_tokenId][_account];\n            delete isTokenOwner[_account][_tokenId];\n            for (uint i = 0; i < tokenOwners[_tokenId].length; i++) {\n                if (tokenOwners[_tokenId][i] == _account) {\n                    tokenOwners[_tokenId][i] = tokenOwners[_tokenId][tokenOwners[_tokenId].length - 1];\n                    tokenOwners[_tokenId].pop();\n                    break;\n                }\n            }\n        }\n\n        // Now ownership processing\n        bool lastOwnershipChanged = false;\n        GildiManagerOwnershipStorage.Ownership memory lastOwnership = ownerships[ownerships.length - 1];\n\n        if (lastOwnership.timestamp == 0 && !release.locked) {\n            lastOwnership.timestamp = (release.unlockedAt / TIME_PERIOD) * TIME_PERIOD;\n            lastOwnershipChanged = true;\n        }\n\n        if (lastOwnership.timestamp == timestamp) {\n            lastOwnership.amount -= _amount;\n            lastOwnershipChanged = true;\n        } else {\n            ownershipTracker.pushOwnership(_account, GildiManagerOwnershipStorage.Ownership(newAmount, timestamp));\n        }\n\n        if (lastOwnershipChanged) {\n            ownershipTracker.updateOwnershipEntry(_account, ownerships.length - 1, lastOwnership);\n        }\n    }\n\n    function _releaseIsDeleting(uint256 _tokenId) private view returns (bool) {\n        return rwaReleases[_tokenId].deleting;\n    }\n\n    function _rolesReleaseManagerMarketplace() internal pure returns (bytes32[] memory) {\n        bytes32[] memory roles = new bytes32[](2);\n        roles[0] = RELEASE_MANAGER_ROLE;\n        roles[1] = MARKETPLACE_ROLE;\n        return roles;\n    }\n\n    modifier whenNotLocked(uint256 _tokenId) {\n        if (rwaReleases[_tokenId].locked) {\n            revert InvalidLockState(false, true);\n        }\n        _;\n    }\n\n    modifier whenLocked(uint256 _tokenId) {\n        if (!rwaReleases[_tokenId].locked) {\n            revert InvalidLockState(true, false);\n        }\n        _;\n    }\n\n    modifier onlyRoles(bytes32[] memory _roles) {\n        for (uint i = 0; i < _roles.length; i++) {\n            if (!hasRole(_roles[i], _msgSender())) {\n                revert AccessControlUnauthorizedAccount(_msgSender(), _roles[i]);\n            }\n        }\n        _;\n    }\n\n    modifier onlyRoleAny(bytes32[] memory _roles) {\n        bool anyRole = false;\n        for (uint i = 0; i < _roles.length; i++) {\n            if (hasRole(_roles[i], _msgSender())) {\n                anyRole = true;\n                break;\n            }\n        }\n        if (!anyRole) {\n            revert AccessControlUnauthorizedAccountAny(_msgSender(), _roles);\n        }\n        _;\n    }\n}\n"
        },
        "contracts/manager/GildiManagerOwnershipStorage.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../storage/AddressKeyValueStore.sol';\n\n/// @title GildiManagerOwnershipStorage\n/// @notice A seperate contract to store the ownership inside the Gildi Manager.\n/// @dev Deployed by the Gildi Manager. Might be switched to an off-chain solution in the future.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract GildiManagerOwnershipStorage is AddressKeyValueStore {\n    constructor(uint256 releaseId, uint256 timePeriod) AddressKeyValueStore(_msgSender()) {\n        TIME_PERIOD = timePeriod < 10 minutes ? 10 minutes : timePeriod;\n        RELEASE_ID = releaseId;\n    }\n\n    /// @notice The time period in which we calculate the shares owned by a user.\n    uint256 public immutable TIME_PERIOD;\n    /// @notice The ID of the Royalty Rights Token / release.\n    uint256 immutable RELEASE_ID;\n\n    /// @notice The ownership of a user for a specific RWA.\n    struct Ownership {\n        /// @notice The amount owned by the user.\n        uint256 amount;\n        /// @notice The timestamp of the last update.\n        uint256 timestamp;\n    }\n\n    event OwnershipUpdated(uint256 indexed releaseId, address indexed user, uint256 amount, uint256 timestamp);\n    event OwnershipDeleted(uint256 indexed releaseId, address indexed user);\n    event OwnershipPushed(uint256 indexed releaseId, address indexed user, uint256 amount, uint256 timestamp);\n\n    /// @notice Delete the ownerships of a user.\n    /// @param _user The user address.\n    function deleteOwnerships(address _user) external {\n        del(_user);\n        emit OwnershipDeleted(RELEASE_ID, _user);\n    }\n\n    /// @notice Push a new ownership entry for a user.\n    /// @param _user The user address.\n    /// @param _ownership The new ownership entry.\n    function pushOwnership(address _user, Ownership calldata _ownership) external {\n        // Check if the user already has ownerships\n        Ownership[] memory oldOwnerships = new Ownership[](0);\n        if (containsKey(_user)) {\n            oldOwnerships = bytesToOwnerships(get(_user));\n        }\n\n        Ownership[] memory newOwnerships = new Ownership[](oldOwnerships.length + 1);\n        for (uint256 i = 0; i < oldOwnerships.length; i++) {\n            newOwnerships[i] = oldOwnerships[i];\n        }\n        newOwnerships[oldOwnerships.length] = _ownership;\n        set(_user, ownershipsToBytes(newOwnerships));\n\n        emit OwnershipPushed(RELEASE_ID, _user, _ownership.amount, _ownership.timestamp);\n    }\n\n    /// @notice Update an ownership entry for a user at a specific index.\n    /// @param _user The user address.\n    /// @param _index The index of the ownership entry.\n    /// @param _ownership The updated ownership entry.\n    function updateOwnershipEntry(address _user, uint256 _index, Ownership calldata _ownership) external {\n        Ownership[] memory ownerships = new Ownership[](0);\n\n        if (containsKey(_user)) {\n            ownerships = bytesToOwnerships(get(_user));\n        }\n        if (_index >= ownerships.length) {\n            revert IndexOutOfBounds(_index);\n        }\n        ownerships[_index] = _ownership;\n        set(_user, ownershipsToBytes(ownerships));\n\n        emit OwnershipUpdated(RELEASE_ID, _user, _ownership.amount, _ownership.timestamp);\n    }\n\n    /// @notice Fetch the ownership of a user.\n    /// @param _user The user address.\n    function fetchOwnerships(address _user) external view returns (Ownership[] memory) {\n        if (!containsKey(_user)) {\n            return new Ownership[](0);\n        }\n        bytes memory allData = get(_user);\n        return bytesToOwnerships(allData);\n    }\n\n    /// @notice Fetch the users.\n    function fetchUsers() external view returns (address[] memory) {\n        return getAllKeys();\n    }\n\n    function ownershipsToBytes(Ownership[] memory _ownership) private pure returns (bytes memory) {\n        return abi.encode(_ownership);\n    }\n\n    function bytesToOwnerships(bytes memory _data) private pure returns (Ownership[] memory) {\n        Ownership[] memory res = abi.decode(_data, (Ownership[]));\n        return res;\n    }\n}\n"
        },
        "contracts/marketplace/exchange/adapters/uniswap/v3/UniswapV3SwapAdapter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../../../../../interfaces/marketplace/exchange/IGildiExchangeSwapAdapter.sol';\nimport '../../../../../interfaces/external/uniswap/v3/IUniswapV3SwapRouter02.sol';\nimport '../../../../../interfaces/external/uniswap/v3/quoter/IUniswapV3ViewQuoter.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @title UniswapV3SwapAdapter\n/// @notice An adapter for interfacing with Uniswap V3 liquidity pools\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract UniswapV3SwapAdapter is\n    IGildiExchangeSwapAdapter,\n    Initializable,\n    ContextUpgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    address public quoter; // Uniswap V3 Quoter address\n    address public router; // Uniswap V3 Router address\n\n    /// @dev Emitted when a route has invalid length\n    error InvalidRouteLength();\n    /// @dev Emitted when the route does not start with the input token\n    error RouteMustStartWithTokenIn();\n    /// @dev Emitted when the route does not end with the output token\n    error RouteMustEndWithTokenOut();\n    /// @dev Emitted when an index is out of array bounds\n    error IndexOutOfBounds();\n    /// @dev Emitted when a maximum amount is exceeded\n    error ExceededMaxAmount();\n    /// @dev Emitted when the output amount is insufficient\n    error InsufficientOutputAmount();\n    /// @dev Emitted when no valid route is found\n    error NoValidRoute();\n\n    /// @notice Struct to represent a Uniswap V3 route\n    /// @dev Combines token path and fees as a single unit\n    struct UniswapRoute {\n        address[] path; // The tokens in the route\n        uint24[] fees; // The fees for each hop (length = path.length - 1)\n    }\n\n    /// @dev Stores custom routes for token pairs\n    mapping(address => mapping(address => UniswapRoute[])) private customRoutes;\n\n    /// @notice QuoteData structure to store Uniswap V3 quote information\n    /// @param route The token path for the swap\n    /// @param fees The fee tiers for each hop\n    /// @param sqrtPriceX96AfterList The sqrt prices after each hop\n    /// @param initializedTicksCrossedList The number of initialized ticks crossed for each hop\n    struct QuoteData {\n        address[] route;\n        uint24[] fees;\n        uint160[] sqrtPriceX96AfterList;\n        uint32[] initializedTicksCrossedList;\n    }\n\n    /// @dev BestInQuote structure for internal stack depth optimization (quoteSwapIn)\n    struct BestInQuote {\n        uint256 cost;\n        address[] route;\n        uint24[] fees;\n        uint160[] sqrtPriceAfterList;\n        uint32[] ticksCrossed;\n        bool found;\n    }\n\n    /// @dev BestOutQuote structure for internal stack depth optimization (quoteSwapOut)\n    struct BestOutQuote {\n        uint256 output;\n        address[] route;\n        uint24[] fees;\n        uint160[] sqrtPriceAfterList;\n        uint32[] ticksCrossed;\n        bool found;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the UniswapV3SwapAdapter\n    /// @param _quoter The address of the IUniswapV3ViewQuoter contract\n    /// @param _router The address of the IUniswapV3SwapRouter contract\n    /// @param _initialDefaultAdmin The address of the initial default admin\n    /// @param _initialContractAdmin The address of the initial contract admin\n    function initialize(\n        address _quoter,\n        address _router,\n        address _initialDefaultAdmin,\n        address _initialContractAdmin\n    ) public initializer {\n        __AccessControl_init();\n        quoter = _quoter;\n        router = _router;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialDefaultAdmin);\n        _grantRole(ADMIN_ROLE, _initialContractAdmin);\n    }\n\n    /// @notice Sets the IUniswapV3ViewQuoter contract address\n    /// @param _quoter The address of the IUniswapV3ViewQuoter contract\n    function setQuoter(address _quoter) external onlyRole(ADMIN_ROLE) {\n        quoter = _quoter;\n    }\n\n    /// @notice Sets the IUniswapV3SwapRouter contract address\n    /// @param _router The address of the IUniswapV3SwapRouter contract\n    function setRouter(address _router) external onlyRole(ADMIN_ROLE) {\n        router = _router;\n    }\n\n    /// @notice Adds a custom route for swapping tokens\n    /// @param _tokenIn The token to swap from\n    /// @param _tokenOut The token to swap to\n    /// @param _route The route to swap through\n    /// @param _fees The fee tiers for each hop in the route (must be one less than route length)\n    function addRoute(\n        address _tokenIn,\n        address _tokenOut,\n        address[] calldata _route,\n        uint24[] calldata _fees\n    ) external onlyRole(ADMIN_ROLE) {\n        if (_route.length < 2) {\n            revert InvalidRouteLength();\n        }\n        if (_route[0] != _tokenIn) {\n            revert RouteMustStartWithTokenIn();\n        }\n        if (_route[_route.length - 1] != _tokenOut) {\n            revert RouteMustEndWithTokenOut();\n        }\n        if (_route.length - 1 != _fees.length) {\n            revert InvalidRouteLength();\n        }\n\n        // Create and store a new UniswapRoute\n        UniswapRoute memory newRoute = UniswapRoute({path: _route, fees: _fees});\n\n        customRoutes[_tokenIn][_tokenOut].push(newRoute);\n    }\n\n    /// @notice Removes a custom route for swapping tokens\n    /// @param _tokenIn The token to swap from\n    /// @param _tokenOut The token to swap to\n    /// @param _routeIndex The index of the route to remove\n    function removeRoute(address _tokenIn, address _tokenOut, uint256 _routeIndex) external onlyRole(ADMIN_ROLE) {\n        if (_routeIndex >= customRoutes[_tokenIn][_tokenOut].length) {\n            revert IndexOutOfBounds();\n        }\n\n        uint256 lastIndex = customRoutes[_tokenIn][_tokenOut].length - 1;\n        if (_routeIndex < lastIndex) {\n            // Copy the last element to the removed position\n            customRoutes[_tokenIn][_tokenOut][_routeIndex] = customRoutes[_tokenIn][_tokenOut][lastIndex];\n        }\n\n        // Remove the last element\n        customRoutes[_tokenIn][_tokenOut].pop();\n    }\n\n    /// @notice Clears all custom routes for swapping tokens.\n    /// @param _tokenIn The token to swap from.\n    /// @param _tokenOut The token to swap to.\n    function clearRoutes(address _tokenIn, address _tokenOut) external onlyRole(ADMIN_ROLE) {\n        delete customRoutes[_tokenIn][_tokenOut];\n    }\n\n    /// @notice Lists all custom routes for swapping tokens\n    /// @param _tokenIn The token to swap from\n    /// @param _tokenOut The token to swap to\n    /// @return routes Array of UniswapRoute structs containing path and fees\n    function listRoutes(address _tokenIn, address _tokenOut) external view returns (UniswapRoute[] memory) {\n        return customRoutes[_tokenIn][_tokenOut];\n    }\n\n    /// @notice Encodes path for Uniswap V3 router\n    /// @param _route The token route\n    /// @param _fees The fee tiers for each hop\n    /// @return encodedPath The encoded path bytes for the Uniswap router\n    function _encodePath(address[] memory _route, uint24[] memory _fees) private pure returns (bytes memory) {\n        bytes memory encodedPath = abi.encodePacked(_route[0]);\n        for (uint256 i = 0; i < _fees.length; i++) {\n            encodedPath = abi.encodePacked(encodedPath, _fees[i], _route[i + 1]);\n        }\n        return encodedPath;\n    }\n\n    /// @dev Encodes a path for a reverse-calculation (exact output) swap by starting from the end\n    /// and prepending each hop. This is required for quoteExactOutput.\n    function _encodeReversePath(address[] memory _route, uint24[] memory _fees) private pure returns (bytes memory) {\n        bytes memory path = abi.encodePacked(_route[0]);\n        for (uint256 i = 0; i < _fees.length; i++) {\n            path = abi.encodePacked(_route[i + 1], _fees[i], path);\n        }\n        return path;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function quoteSwapIn(\n        address _sourceToken,\n        address _marketplaceToken,\n        uint256 _marketplaceAmountDesired\n    ) public view override returns (SwapInQuote memory quote) {\n        UniswapRoute[] storage routes = customRoutes[_sourceToken][_marketplaceToken];\n\n        // Store best quote data in a struct to reduce stack usage\n        BestInQuote memory best;\n        best.cost = type(uint256).max;\n        best.found = false;\n\n        if (routes.length == 0) {\n            // Default single-hop route if no custom routes\n            address[] memory defaultRoute = new address[](2);\n            defaultRoute[0] = _sourceToken;\n            defaultRoute[1] = _marketplaceToken;\n\n            uint24[] memory uniDefaultFees = _getDefaultFees();\n\n            for (uint256 i = 0; i < uniDefaultFees.length; i++) {\n                uint24 poolFee = uniDefaultFees[i];\n\n                uint24[] memory defaultFees = new uint24[](1);\n                defaultFees[0] = poolFee;\n\n                (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed) = IUniswapV3ViewQuoter(\n                    quoter\n                ).quoteExactOutputSingle(\n                        IUniswapV3ViewQuoter.QuoteExactOutputSingleParams({\n                            tokenIn: _sourceToken,\n                            tokenOut: _marketplaceToken,\n                            amount: _marketplaceAmountDesired,\n                            fee: defaultFees[0],\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n                // Only consider this a valid quote if amountIn is non-zero\n                // Zero can be returned if the pool doesn't exist\n                if (amountIn > 0 && (amountIn < best.cost || !best.found)) {\n                    best.cost = amountIn;\n                    best.route = defaultRoute;\n                    best.fees = defaultFees;\n\n                    best.sqrtPriceAfterList = new uint160[](1);\n                    best.sqrtPriceAfterList[0] = sqrtPriceX96After;\n\n                    best.ticksCrossed = new uint32[](1);\n                    best.ticksCrossed[0] = initializedTicksCrossed;\n\n                    best.found = true;\n                }\n            }\n        } else {\n            // Try all custom routes\n            for (uint256 i = 0; i < routes.length; i++) {\n                UniswapRoute storage route = routes[i];\n\n                if (route.path.length == 2) {\n                    // Single hop route\n                    (\n                        uint256 amountIn,\n                        uint160 sqrtPriceX96After,\n                        uint32 initializedTicksCrossed\n                    ) = IUniswapV3ViewQuoter(quoter).quoteExactOutputSingle(\n                            IUniswapV3ViewQuoter.QuoteExactOutputSingleParams({\n                                tokenIn: route.path[0],\n                                tokenOut: route.path[1],\n                                amount: _marketplaceAmountDesired,\n                                fee: route.fees[0],\n                                sqrtPriceLimitX96: 0\n                            })\n                        );\n                    // Only consider non-zero quotes as valid\n                    if (amountIn > 0 && (amountIn < best.cost || !best.found)) {\n                        best.cost = amountIn;\n                        best.route = route.path;\n                        best.fees = route.fees;\n\n                        best.sqrtPriceAfterList = new uint160[](1);\n                        best.sqrtPriceAfterList[0] = sqrtPriceX96After;\n\n                        best.ticksCrossed = new uint32[](1);\n                        best.ticksCrossed[0] = initializedTicksCrossed;\n\n                        best.found = true;\n                    }\n                } else {\n                    // Multi-hop route\n                    bytes memory path = _encodeReversePath(route.path, route.fees);\n\n                    (\n                        uint256 amountIn,\n                        uint160[] memory sqrtPriceX96AfterList,\n                        uint32[] memory initializedTicksCrossedList\n                    ) = IUniswapV3ViewQuoter(quoter).quoteExactOutput(path, _marketplaceAmountDesired);\n                    // Only consider non-zero quotes as valid\n                    if (amountIn > 0 && (amountIn < best.cost || !best.found)) {\n                        best.cost = amountIn;\n                        best.route = route.path;\n                        best.fees = route.fees;\n                        best.sqrtPriceAfterList = sqrtPriceX96AfterList;\n                        best.ticksCrossed = initializedTicksCrossedList;\n                        best.found = true;\n                    }\n                }\n            }\n        }\n\n        // If we found a valid quote\n        if (best.found) {\n            // Package the quote data\n            QuoteData memory quoteData = QuoteData({\n                route: best.route,\n                fees: best.fees,\n                sqrtPriceX96AfterList: best.sqrtPriceAfterList,\n                initializedTicksCrossedList: best.ticksCrossed\n            });\n\n            bytes memory rawQuoteData = abi.encode(quoteData);\n\n            // Build the quoteRoute for return\n            uint128[] memory amounts = new uint128[](best.route.length);\n            amounts[0] = uint128(best.cost); // Input amount\n            amounts[best.route.length - 1] = uint128(_marketplaceAmountDesired); // Output amount\n\n            uint128[] memory feesArr = new uint128[](best.fees.length);\n            for (uint256 i = 0; i < best.fees.length; i++) {\n                feesArr[i] = uint128(best.fees[i]);\n            }\n\n            QuoteRoute memory quoteRoute = QuoteRoute({\n                marketplaceAdapter: address(this),\n                route: best.route,\n                fees: feesArr,\n                amounts: amounts,\n                virtualAmountsWithoutSlippage: new uint128[](best.route.length) // Not used in Uniswap V3\n            });\n\n            // Build the final quote struct\n            quote = SwapInQuote({\n                sourceTokenRequired: best.cost,\n                rawQuoteData: rawQuoteData,\n                quoteRoute: quoteRoute,\n                validRoute: true\n            });\n        } else {\n            // No valid quote found\n            quote.validRoute = false;\n        }\n\n        return quote;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function swapIn(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmountMax,\n        uint256 _marketplaceAmount,\n        address _to,\n        bytes memory _quoteData\n    ) external override returns (uint256 sourceSpent) {\n        if (_quoteData.length == 0) {\n            // Get the quote data by calling quoteSwapIn\n            SwapInQuote memory quote = quoteSwapIn(_sourceToken, _targetToken, _marketplaceAmount);\n\n            // Check if the quote is valid\n            if (!quote.validRoute) {\n                revert NoValidRoute();\n            }\n\n            _quoteData = quote.rawQuoteData;\n        }\n\n        // Decode the quote data\n        QuoteData memory quoteData = abi.decode(_quoteData, (QuoteData));\n\n        // Pull tokens from sender\n        IERC20(_sourceToken).safeTransferFrom(msg.sender, address(this), _sourceAmountMax);\n\n        // Approve router to spend tokens if needed\n        uint256 allowance = IERC20(_sourceToken).allowance(address(this), router);\n        if (allowance < _sourceAmountMax) {\n            IERC20(_sourceToken).forceApprove(router, type(uint256).max);\n        }\n\n        if (quoteData.route.length == 2) {\n            // Single hop swap\n            IUniswapV3SwapRouter02.ExactOutputSingleParams memory params = IUniswapV3SwapRouter02\n                .ExactOutputSingleParams({\n                    tokenIn: quoteData.route[0],\n                    tokenOut: quoteData.route[1],\n                    fee: quoteData.fees[0],\n                    recipient: _to,\n                    amountOut: _marketplaceAmount,\n                    amountInMaximum: _sourceAmountMax,\n                    sqrtPriceLimitX96: 0\n                });\n\n            // Execute the swap\n            sourceSpent = IUniswapV3SwapRouter02(router).exactOutputSingle(params);\n        } else {\n            // Multi-hop swap\n            bytes memory path = _encodeReversePath(quoteData.route, quoteData.fees);\n\n            IUniswapV3SwapRouter02.ExactOutputParams memory params = IUniswapV3SwapRouter02.ExactOutputParams({\n                path: path,\n                recipient: _to,\n                amountOut: _marketplaceAmount,\n                amountInMaximum: _sourceAmountMax\n            });\n\n            // Execute the swap\n            sourceSpent = IUniswapV3SwapRouter02(router).exactOutput(params);\n        }\n\n        // Return unused tokens\n        if (sourceSpent < _sourceAmountMax) {\n            IERC20(_sourceToken).safeTransfer(_to, _sourceAmountMax - sourceSpent);\n        }\n\n        if (sourceSpent > _sourceAmountMax) {\n            revert ExceededMaxAmount();\n        }\n\n        return sourceSpent;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function quoteSwapOut(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmount\n    ) public view override returns (SwapOutQuote memory quote) {\n        UniswapRoute[] storage routes = customRoutes[_sourceToken][_targetToken];\n\n        // Store best quote data in a struct to reduce stack usage\n        BestOutQuote memory best;\n        best.output = 0;\n        best.found = false;\n\n        if (routes.length == 0) {\n            // Default single-hop route if no custom routes\n            address[] memory defaultRoute = new address[](2);\n            defaultRoute[0] = _sourceToken;\n            defaultRoute[1] = _targetToken;\n\n            uint24[] memory uniDefaultFees = _getDefaultFees();\n\n            for (uint256 i = 0; i < uniDefaultFees.length; i++) {\n                uint24 poolFee = uniDefaultFees[i];\n\n                // Default fee tier for the pool (0.3%)\n                uint24[] memory defaultFees = new uint24[](1);\n                defaultFees[0] = poolFee;\n\n                (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed) = IUniswapV3ViewQuoter(\n                    quoter\n                ).quoteExactInputSingle(\n                        IUniswapV3ViewQuoter.QuoteExactInputSingleParams({\n                            tokenIn: _sourceToken,\n                            tokenOut: _targetToken,\n                            amountIn: _sourceAmount,\n                            fee: defaultFees[0],\n                            sqrtPriceLimitX96: 0\n                        })\n                    );\n                // Only consider this a valid quote if amountOut is non-zero\n                // Zero can be returned if the pool doesn't exist\n                if (amountOut > 0 && (amountOut > best.output || !best.found)) {\n                    best.output = amountOut;\n                    best.route = defaultRoute;\n                    best.fees = defaultFees;\n\n                    best.sqrtPriceAfterList = new uint160[](1);\n                    best.sqrtPriceAfterList[0] = sqrtPriceX96After;\n\n                    best.ticksCrossed = new uint32[](1);\n                    best.ticksCrossed[0] = initializedTicksCrossed;\n\n                    best.found = true;\n                }\n            }\n        } else {\n            // Try all custom routes\n            for (uint256 i = 0; i < routes.length; i++) {\n                UniswapRoute storage route = routes[i];\n\n                if (route.path.length == 2) {\n                    // Single hop route\n                    (\n                        uint256 amountOut,\n                        uint160 sqrtPriceX96After,\n                        uint32 initializedTicksCrossed\n                    ) = IUniswapV3ViewQuoter(quoter).quoteExactInputSingle(\n                            IUniswapV3ViewQuoter.QuoteExactInputSingleParams({\n                                tokenIn: _sourceToken,\n                                tokenOut: _targetToken,\n                                amountIn: _sourceAmount,\n                                fee: route.fees[0],\n                                sqrtPriceLimitX96: 0\n                            })\n                        );\n\n                    // Only consider non-zero quotes as valid\n                    if (amountOut > 0 && (amountOut > best.output || !best.found)) {\n                        best.output = amountOut;\n                        best.route = route.path;\n                        best.fees = route.fees;\n\n                        best.sqrtPriceAfterList = new uint160[](1);\n                        best.sqrtPriceAfterList[0] = sqrtPriceX96After;\n\n                        best.ticksCrossed = new uint32[](1);\n                        best.ticksCrossed[0] = initializedTicksCrossed;\n                        best.found = true;\n                    }\n                } else {\n                    // Multi-hop route\n                    bytes memory path = _encodePath(route.path, route.fees);\n                    (\n                        uint256 amountOut,\n                        uint160[] memory sqrtPriceX96AfterList,\n                        uint32[] memory initializedTicksCrossedList\n                    ) = IUniswapV3ViewQuoter(quoter).quoteExactInput(path, _sourceAmount);\n                    // Only consider non-zero quotes as valid\n                    if (amountOut > 0 && (amountOut > best.output || !best.found)) {\n                        best.output = amountOut;\n                        best.route = route.path;\n                        best.fees = route.fees;\n                        best.sqrtPriceAfterList = sqrtPriceX96AfterList;\n                        best.ticksCrossed = initializedTicksCrossedList;\n                        best.found = true;\n                    }\n                }\n            }\n        }\n\n        // If we found a valid quote\n        if (best.found) {\n            // Package the quote data\n            QuoteData memory quoteData = QuoteData({\n                route: best.route,\n                fees: best.fees,\n                sqrtPriceX96AfterList: best.sqrtPriceAfterList,\n                initializedTicksCrossedList: best.ticksCrossed\n            });\n\n            // Build the quoteRoute for return\n            uint128[] memory amounts = new uint128[](best.route.length);\n            amounts[0] = uint128(_sourceAmount); // Input amount\n            amounts[best.route.length - 1] = uint128(best.output); // Output amount\n\n            uint128[] memory feesArr = new uint128[](best.fees.length);\n            for (uint256 i = 0; i < best.fees.length; i++) {\n                feesArr[i] = uint128(best.fees[i]);\n            }\n\n            QuoteRoute memory quoteRoute = QuoteRoute({\n                marketplaceAdapter: address(this),\n                route: best.route,\n                fees: feesArr,\n                amounts: amounts,\n                virtualAmountsWithoutSlippage: new uint128[](best.route.length) // Not used in Uniswap V3\n            });\n\n            quote = SwapOutQuote({\n                targetTokenOut: best.output,\n                rawQuoteData: abi.encode(quoteData),\n                quoteRoute: quoteRoute,\n                validRoute: true\n            });\n        } else {\n            // Return invalid route if no quote found\n            quote.validRoute = false;\n        }\n\n        return quote;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function swapOut(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmount,\n        uint256 _minimumAmountOut,\n        address _to,\n        bytes memory _quoteData\n    ) external override returns (uint256 targetTokenReceived) {\n        if (_quoteData.length == 0) {\n            // Get the quote data by calling quoteSwapOut\n            SwapOutQuote memory quote = quoteSwapOut(_sourceToken, _targetToken, _sourceAmount);\n\n            // Check if the quote is valid\n            if (!quote.validRoute) {\n                revert NoValidRoute();\n            }\n\n            _quoteData = quote.rawQuoteData;\n        }\n\n        // Decode the quote data\n        QuoteData memory quoteData = abi.decode(_quoteData, (QuoteData));\n\n        // Pull tokens from sender\n        IERC20(_sourceToken).safeTransferFrom(msg.sender, address(this), _sourceAmount);\n\n        // Approve router to spend tokens if needed\n        uint256 allowance = IERC20(_sourceToken).allowance(address(this), router);\n        if (allowance < _sourceAmount) {\n            IERC20(_sourceToken).forceApprove(router, type(uint256).max);\n        }\n\n        if (quoteData.route.length == 2) {\n            // Single hop swap\n            IUniswapV3SwapRouter02.ExactInputSingleParams memory params = IUniswapV3SwapRouter02\n                .ExactInputSingleParams({\n                    tokenIn: _sourceToken,\n                    tokenOut: _targetToken,\n                    fee: quoteData.fees[0],\n                    recipient: _to,\n                    amountIn: _sourceAmount,\n                    amountOutMinimum: _minimumAmountOut,\n                    sqrtPriceLimitX96: 0\n                });\n\n            // Execute the swap\n            targetTokenReceived = IUniswapV3SwapRouter02(router).exactInputSingle(params);\n        } else {\n            // Multi-hop swap\n            bytes memory path = _encodePath(quoteData.route, quoteData.fees);\n\n            IUniswapV3SwapRouter02.ExactInputParams memory params = IUniswapV3SwapRouter02.ExactInputParams({\n                path: path,\n                recipient: _to,\n                amountIn: _sourceAmount,\n                amountOutMinimum: _minimumAmountOut\n            });\n\n            // Execute the swap\n            targetTokenReceived = IUniswapV3SwapRouter02(router).exactInput(params);\n        }\n\n        if (targetTokenReceived < _minimumAmountOut) {\n            revert InsufficientOutputAmount();\n        }\n\n        return targetTokenReceived;\n    }\n\n    /// @dev Returns the default fee tiers for Uniswap V3\n    function _getDefaultFees() private pure returns (uint24[] memory defaultFees) {\n        defaultFees = new uint24[](4);\n        defaultFees[0] = 3000; // 0.30%\n        defaultFees[1] = 500; // 0.05%\n        defaultFees[2] = 10000; // 1.00%\n        defaultFees[3] = 100; // 0.01%\n        return defaultFees;\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchange.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport {SharedErrors} from '../../libraries/marketplace/exchange/SharedErrors.sol';\nimport {IERC20Burnable} from '../../interfaces/token/IERC20Burnable.sol';\nimport {IGildiPriceResolver} from '../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {PausableUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol';\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\n/// @title Gildi Exchange\n/// @notice Marketplace of the Gildi platform.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiExchange is\n    Initializable,\n    PausableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IGildiExchange\n{\n    using SafeERC20 for IERC20;\n\n    // ========== Constants ==========\n    /// @notice Role identifier for admin access\n    bytes32 private constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    /// @notice Role identifier for marketplace manager access\n    bytes32 private constant MARKETPLACE_MANAGER_ROLE = keccak256('MARKETPLACE_MANAGER_ROLE');\n\n    /// @notice Role identifier for fund claimer access\n    bytes32 private constant CLAIMER_ROLE = keccak256('CLAIMER_ROLE');\n\n    /// @notice Basis points denominator for percentage calculations (100% = 10000)\n    uint16 private constant BASIS_POINTS = 10000;\n\n    /// @notice Default slippage tolerance in basis points (5%)\n    uint16 public constant DEFAULT_SLIPPAGE_BPS = 500;\n\n    // ========== Storage Variables ==========\n    /// @notice Application settings for the exchange\n    AppSettings private appSettings;\n\n    /// @notice Array of all release IDs in the exchange\n    uint256[] private releaseIds;\n    /// @notice Mapping from release ID to Release struct\n    mapping(uint256 => Release) public releases;\n\n    /// @notice Mapping from release ID to InitialSale struct\n    mapping(uint256 => InitialSale) private initialSales;\n    /// @notice Mapping from release ID to array of whitelist buyer addresses\n    mapping(uint256 => address[]) private initialSaleWhitelistBuyers;\n    /// @notice Mapping from release ID to buyer address to whitelist status\n    mapping(uint256 => mapping(address => bool)) public isInitialSaleWhitelistBuyer;\n    /// @notice Mapping from release ID to buyer address to maximum buy count\n    mapping(uint256 => mapping(address => uint256)) private initialSaleMaxBuyCounts;\n    /// @notice Mapping from release ID to total quantity listed in initial sale\n    mapping(uint256 => uint256) private initialSaleListedQuantities;\n\n    // ========== Structs ==========\n\n    /// @notice Parameters for creating an initial sale\n    struct InitialSaleParams {\n        /// @dev The ID of the release\n        uint256 releaseId;\n        /// @dev The quantities of the asset\n        uint256[] assetQuantities;\n        /// @dev The prices of the asset for the quantity bracket\n        uint256[] assetPrices;\n        /// @dev The addresses of the whitelist\n        address[] whitelistAddresses;\n        /// @dev The fee distribution structure for the initial sale\n        FeeDistribution[] fees;\n        /// @dev The address of the seller (owner of the shares)\n        address seller;\n        /// @dev Overrides the marketplace currency for the initial sale\n        address initialSaleCurrency;\n        /// @dev The currency to pay out in\n        address payoutCurrency;\n        /// @dev The address to receive funds from the sale (if address(0), defaults to seller)\n        address fundsReceiver;\n        /// @dev The start time of the initial sale\n        uint64 start;\n        /// @dev The duration of the initial sale (default 1 week)\n        uint64 duration;\n        /// @dev The duration the whitelist is enforced (default 0 = forever)\n        uint64 whitelistDuration;\n        /// @dev The maximum amount of tokens a buyer can buy in the initial sale\n        uint32 maxBuy;\n        /// @dev If the initial sale is a whitelist sale\n        bool whitelist;\n    }\n\n    /// @notice A marketplace release\n    struct Release {\n        /// @dev The ID of the release\n        uint256 releaseId;\n        /// @dev Additional fees for this release\n        FeeDistribution[] additionalFees;\n        /// @dev If the release is initialized (set)\n        bool initialized;\n        /// @dev If the release is active = can be traded\n        bool active;\n        /// @dev If the release is in the process of being cancelled\n        bool isCancelling;\n    }\n\n    /// @notice Initial sale related data\n    struct InitialSale {\n        /// @dev The fee distribution structure for the initial sale\n        FeeDistribution[] fees;\n        /// @dev The sale currency of the initial sale\n        address saleCurrency;\n        /// @dev When the initial sale starts\n        uint64 startTime;\n        /// @dev When the initial sale ends\n        uint64 endTime;\n        /// @dev Until when the whitelist is enforced (0 = unlimited)\n        uint64 whitelistUntil;\n        /// @dev Maximum amount of tokens a buyer can buy in the initial sale\n        uint32 maxBuy;\n        /// @dev If the release is in initial sale state\n        bool active;\n        /// @dev If the initial sale is a whitelist sale\n        bool whitelist;\n    }\n\n    // ========== Events ==========\n\n    /// @notice Emitted when a purchase is made\n    /// @param releaseId The ID of the release being purchased\n    /// @param buyer The address of the buyer\n    /// @param seller The address of the seller\n    /// @param operator The address of the operator\n    /// @param listingId The ID of the listing\n    /// @param priceInUSD The price per item in USD\n    /// @param quantity The quantity of the release being purchased\n    event Purchased(\n        uint256 indexed releaseId,\n        address indexed buyer,\n        address indexed seller,\n        address operator,\n        uint256 listingId,\n        uint256 priceInUSD,\n        uint256 quantity,\n        uint256 priceInAsset,\n        address asset\n    );\n\n    /// @notice Emitted when a release cancellation is started\n    /// @param releaseId The ID of the release being cancelled\n    event ReleaseCancellationStarted(uint256 indexed releaseId);\n\n    /// @notice Emitted when a release is fully cancelled\n    /// @param releaseId The ID of the release being cancelled\n    event ReleaseCancelled(uint256 indexed releaseId);\n\n    /// @notice Emitted when an initial sale is created\n    /// @param releaseId The ID of the release\n    /// @param seller The address of the seller\n    /// @param assetQuantities The quantities of the asset\n    /// @param assetPrices The prices of the asset for the quantity bracket\n    /// @param maxBuy The maximum amount of tokens a buyer can buy in the initial sale\n    /// @param startTime The start time of the initial sale\n    /// @param duration The duration of the initial sale\n    /// @param whitelistEnabled If the initial sale is a whitelist sale\n    /// @param whitelistDuration The duration the whitelist is enforced\n    /// @param saleCurrency The currency of the initial sale\n    /// @param payoutCurrency The currency of the payout\n    /// @param saleFees The fees for the initial sale\n    event InitialSaleCreated(\n        uint256 indexed releaseId,\n        address indexed seller,\n        uint256[] assetQuantities,\n        uint256[] assetPrices,\n        uint256 maxBuy,\n        uint256 startTime,\n        uint256 duration,\n        bool whitelistEnabled,\n        uint256 whitelistDuration,\n        address saleCurrency,\n        address payoutCurrency,\n        FeeDistribution[] saleFees\n    );\n\n    /// @notice Emitted when the initial sale ends\n    /// @param releaseId The ID of the release\n    event InitialSaleEnded(uint256 indexed releaseId);\n\n    /// @notice Emitted when a release is initialized\n    /// @param releaseId The ID of the release\n    event ReleaseInitialized(uint256 indexed releaseId);\n\n    /// @notice Emitted when a release's active state is changed\n    /// @param releaseId The ID of the release\n    /// @param isActive The new active state\n    event ReleaseActiveStateChanged(uint256 indexed releaseId, bool isActive);\n\n    /// @notice Emitted when a release's fees are updated\n    /// @param releaseId The ID of the release\n    event FeesUpdated(uint256 indexed releaseId);\n\n    /// @notice Emitted when the ask decimals are set\n    /// @param askDecimals The new ask decimals\n    event AskDecimalsSet(uint8 askDecimals);\n\n    /// @notice Emitted when the marketplace currency is set\n    /// @param marketplaceCurrency The new marketplace currency\n    event MarketplaceCurrencySet(address marketplaceCurrency);\n\n    // ========== Errors ==========\n\n    /// @dev Emitted when the requested quantity exceeds available inventory.\n    /// @dev The quantity that was requested.\n    /// @dev The quantity that was available.\n    error InsufficientQuantity(uint256 requested, uint256 available);\n\n    /// @dev Emitted when a purchase cannot proceed (e.g. buyer not whitelisted, amount exceeds max buy, not enough tokens).\n    error PurchaseError();\n\n    /// @dev Emitted when there is a setup/configuration issue (e.g. oracle decimals not set, invalid fee distribution).\n    error SetupError();\n\n    /// @dev Emitted when a release is not found in the manager (e.g. gildiManager.releaseExists(...) fails).\n    /// @dev The ID that could not be found.\n    error ReleaseNotFound(uint256 releaseId);\n\n    /// @dev Emitted when the requested number of tokens to buy cannot be fulfilled by the available listings.\n    /// @dev The total amount of tokens requested\n    /// @dev The amount of tokens actually found in listings\n    error NotEnoughTokensInListings(uint256 requested, uint256 available);\n\n    /// @dev Emitted when a release is in a wrong state (e.g. uninitialized, cancelling when it should not be, or active/inactive mismatch).\n    /// @dev The ID of the release in question.\n    error ReleaseStateError(uint256 releaseId);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    // ========== Constructor and Initializer ==========\n\n    /// @notice Initializes the contract\n    /// @param _initialDefaultAdmin The address of the initial default admin\n    /// @param _initialAdmin The address of the initial admin\n    /// @param _initialMarketplaceManager The address of the initial marketplace manager\n    /// @param _gildiManager The address of the Gildi Manager\n    /// @param _marketplaceCurrency The address of the marketplace currency\n    function initialize(\n        address _initialDefaultAdmin,\n        address _initialAdmin,\n        address _initialMarketplaceManager,\n        IGildiManager _gildiManager,\n        IERC20 _marketplaceCurrency\n    ) public initializer {\n        AppSettings storage $ = appSettings;\n\n        __Pausable_init();\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        if (_initialDefaultAdmin == address(0)) {\n            _initialDefaultAdmin = _msgSender();\n        }\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialDefaultAdmin);\n\n        if (_initialAdmin != address(0)) {\n            _grantRole(ADMIN_ROLE, _initialAdmin);\n        }\n\n        if (_initialMarketplaceManager != address(0)) {\n            _grantRole(MARKETPLACE_MANAGER_ROLE, _initialMarketplaceManager);\n        }\n\n        $.maxBuyPerTransaction = 15;\n\n        $.gildiManager = _gildiManager;\n        _setMarketplaceCurrency(address(_marketplaceCurrency));\n    }\n\n    // ========== Main Marketplace Logic ==========\n\n    /// @notice Creates an initial sale.\n    /// @param _params The parameters for creating the initial sale\n    function createInitialSale(\n        InitialSaleParams calldata _params\n    ) external whenNotPaused onlyRole(MARKETPLACE_MANAGER_ROLE) {\n        AppSettings storage $ = appSettings;\n\n        // Validate release state - combine multiple checks\n        uint256 releaseId = _params.releaseId;\n        Release storage release = releases[releaseId];\n        if (\n            !release.initialized ||\n            release.active ||\n            release.isCancelling ||\n            !$.gildiManager.isLocked(releaseId) ||\n            $.gildiManager.isInInitialSale(releaseId) ||\n            isInInitialSale(releaseId)\n        ) {\n            revert ReleaseStateError(releaseId);\n        }\n\n        // Validate function parameters\n        uint256 quantitiesLength = _params.assetQuantities.length;\n        uint256 whitelistLength = _params.whitelistAddresses.length;\n        if (\n            quantitiesLength != _params.assetPrices.length ||\n            (_params.whitelist && whitelistLength == 0) ||\n            (!_params.whitelist && whitelistLength > 0)\n        ) {\n            revert SharedErrors.ParamError();\n        }\n\n        // Check if we have a feed for the initial sale currency\n        if (\n            _params.initialSaleCurrency != address(0) &&\n            $.paymentProcessor.getPriceFeedId(_params.initialSaleCurrency) == bytes32(0)\n        ) {\n            revert SharedErrors.ParamError();\n        }\n\n        // Adjust start time and duration if needed\n        uint64 startTime = _params.start < uint64(block.timestamp) ? uint64(block.timestamp) : _params.start;\n        uint64 duration = _params.duration == 0 ? 1 weeks : _params.duration;\n\n        // Calculate whitelist end time\n        uint64 whitelistUntil = (_params.whitelist && _params.whitelistDuration != 0)\n            ? startTime + _params.whitelistDuration\n            : 0;\n\n        // Setup initial sale\n        InitialSale storage initialSale = initialSales[_params.releaseId];\n        initialSale.whitelist = _params.whitelist;\n        initialSale.whitelistUntil = whitelistUntil;\n        initialSale.maxBuy = _params.maxBuy;\n        initialSale.saleCurrency = _params.initialSaleCurrency;\n\n        _enforceValidFeeDistribution(_params.fees);\n        initialSale.fees = _params.fees;\n\n        // Process whitelist addresses in a single loop\n        for (uint256 i; i < whitelistLength; ++i) {\n            address buyer = _params.whitelistAddresses[i];\n            if (!isInitialSaleWhitelistBuyer[_params.releaseId][buyer]) {\n                isInitialSaleWhitelistBuyer[_params.releaseId][buyer] = true;\n                initialSaleWhitelistBuyers[_params.releaseId].push(buyer);\n            }\n        }\n\n        release.active = true;\n        initialSale.active = true;\n        initialSale.startTime = startTime;\n        initialSale.endTime = startTime + duration;\n\n        $.gildiManager.startInitialSale(_params.releaseId);\n\n        for (uint256 i; i < quantitiesLength; ++i) {\n            initialSaleListedQuantities[_params.releaseId] += _params.assetQuantities[i];\n\n            // Use the orderBook to create the listing\n            $.orderBook.handleCreateListing(\n                _params.releaseId,\n                _params.seller,\n                _params.assetPrices[i],\n                _params.assetQuantities[i],\n                _params.payoutCurrency,\n                _params.fundsReceiver,\n                DEFAULT_SLIPPAGE_BPS\n            );\n        }\n\n        emit InitialSaleCreated(\n            _params.releaseId,\n            _params.seller,\n            _params.assetQuantities,\n            _params.assetPrices,\n            _params.maxBuy,\n            _params.start,\n            _params.duration,\n            _params.whitelist,\n            _params.whitelistDuration,\n            _params.initialSaleCurrency,\n            _params.payoutCurrency,\n            _params.fees\n        );\n    }\n\n    /// @notice Cancels a release in batches.\n    /// @param _releaseId The ID of the release\n    /// @param _batchSize The batch size (min 1, max 100)\n    function cancelRelease(uint256 _releaseId, uint256 _batchSize) external onlyRole(MARKETPLACE_MANAGER_ROLE) {\n        AppSettings storage $ = appSettings;\n\n        if (_batchSize > 100 || _batchSize == 0) {\n            revert SharedErrors.ParamError();\n        }\n\n        Release storage release = releases[_releaseId];\n        InitialSale storage initialSale = initialSales[_releaseId];\n\n        if (!release.initialized) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        if (release.active) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        if (!release.isCancelling) {\n            release.isCancelling = true;\n            emit ReleaseCancellationStarted(_releaseId);\n        }\n\n        if (initialSale.active) {\n            $.gildiManager.cancelInitialSale(_releaseId);\n        }\n\n        uint256 i = 0;\n\n        // Process batch of listings\n        uint256 batchToProcess = _batchSize > 100 ? 100 : _batchSize;\n\n        try $.orderBook.handleUnlistReleaseListings(_releaseId, batchToProcess) returns (uint256 processedCount) {\n            i += processedCount;\n        } catch {}\n        // Process funds using the fund manager\n        uint256 fundsProcessed = 0;\n        if (i < _batchSize) {\n            try $.fundManager.handleCancelReleaseFunds(_releaseId, _batchSize - i) returns (uint256 processedCount) {\n                fundsProcessed = processedCount;\n                i += fundsProcessed;\n            } catch {}\n        } else {\n            return;\n        }\n\n        if ($.orderBook.listedQuantities(_releaseId) == 0 && !$.fundManager.releaseHasFunds(_releaseId)) {\n            // Clean up initial sale mappings in batch constraints\n            if (initialSale.active) {\n                for (; i < initialSaleWhitelistBuyers[_releaseId].length && i < _batchSize; i++) {\n                    address buyer = initialSaleWhitelistBuyers[_releaseId][i];\n                    delete isInitialSaleWhitelistBuyer[_releaseId][buyer];\n                    delete initialSaleMaxBuyCounts[_releaseId][buyer];\n                }\n                if (initialSaleWhitelistBuyers[_releaseId].length > 0) {\n                    return;\n                }\n\n                delete initialSaleWhitelistBuyers[_releaseId];\n                delete initialSaleListedQuantities[_releaseId];\n            }\n\n            delete releases[_releaseId];\n            delete initialSales[_releaseId];\n\n            uint256 length = releaseIds.length;\n            for (uint256 j; j < length; ++j) {\n                if (releaseIds[j] == _releaseId) {\n                    releaseIds[j] = releaseIds[length - 1];\n                    releaseIds.pop();\n                    break;\n                }\n            }\n            emit ReleaseCancelled(_releaseId);\n        }\n    }\n\n    /// @inheritdoc IGildiExchange\n    function createListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver\n    ) external whenNotPaused {\n        _createListing(\n            _releaseId,\n            _seller,\n            _pricePerItem,\n            _quantity,\n            _payoutCurrency,\n            _fundsReceiver,\n            DEFAULT_SLIPPAGE_BPS\n        );\n    }\n\n    /// @inheritdoc IGildiExchange\n    function createListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external whenNotPaused {\n        _createListing(_releaseId, _seller, _pricePerItem, _quantity, _payoutCurrency, _fundsReceiver, _slippageBps);\n    }\n\n    /// @inheritdoc IGildiExchange\n    function modifyListing(\n        uint256 _listingId,\n        uint256 _newPricePerItem,\n        uint256 _newQuantity,\n        address _payoutCurrency,\n        address _fundsReceiver\n    ) external whenNotPaused {\n        _modifyListing(\n            _listingId,\n            _newPricePerItem,\n            _newQuantity,\n            _payoutCurrency,\n            _fundsReceiver,\n            DEFAULT_SLIPPAGE_BPS\n        );\n    }\n\n    /// @inheritdoc IGildiExchange\n    function modifyListing(\n        uint256 _listingId,\n        uint256 _newPricePerItem,\n        uint256 _newQuantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external whenNotPaused {\n        _modifyListing(_listingId, _newPricePerItem, _newQuantity, _payoutCurrency, _fundsReceiver, _slippageBps);\n    }\n\n    /// @notice Cancels a listing by ID\n    /// @param _listingId The ID of the listing\n    function cancelListing(uint256 _listingId) external nonReentrant whenNotPaused {\n        AppSettings storage $ = appSettings;\n\n        // Get the listing from the order book\n        IGildiExchangeOrderBook.Listing memory listing = $.orderBook.getListing(_listingId);\n\n        // Only the listing owner or someone with ADMIN_ROLE can cancel a listing\n        if (listing.seller != _msgSender() && !hasRole(ADMIN_ROLE, _msgSender())) {\n            revert SharedErrors.NotAllowed();\n        }\n\n        if ($.gildiManager.isInInitialSale(listing.releaseId) && isInInitialSale(listing.releaseId)) {\n            revert ReleaseStateError(listing.releaseId);\n        }\n\n        // Delegate to the order book to remove the listing\n        $.orderBook.handleRemoveListing(_listingId);\n    }\n\n    /// @notice Unlists all listings of a release in batches.\n    /// @param _releaseId The ID of the release (0 = all)\n    /// @param _batchSize The batch size (0 = unlimited)\n    function unlistAllListings(uint256 _releaseId, uint256 _batchSize) external onlyRole(ADMIN_ROLE) {\n        AppSettings storage $ = appSettings;\n\n        if (_batchSize == 0) {\n            _batchSize = type(uint256).max;\n        }\n\n        uint256 totalProcessed = 0;\n\n        // For each release\n        for (uint256 i = 0; i < releaseIds.length && totalProcessed < _batchSize; i++) {\n            uint256 releaseId = releaseIds[i];\n\n            if (releaseId != _releaseId && _releaseId != 0) {\n                continue;\n            }\n\n            uint256 remaining = _batchSize - totalProcessed;\n            uint256 batchToProcess = remaining > 100 ? 100 : remaining; // Process in chunks of max 100\n\n            // Delegate to the order book\n            uint256 processed = $.orderBook.handleUnlistReleaseListings(releaseId, batchToProcess);\n\n            totalProcessed += processed;\n\n            // If we processed less than the batch size, we're done with this release\n            if (processed < batchToProcess) {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IGildiExchange\n    function purchase(\n        uint256 _releaseId,\n        uint256 _amount,\n        uint256 _maxTotalPrice,\n        address _beneficiary,\n        bool _isProxyOperation\n    ) external override nonReentrant whenNotPaused returns (uint256 amountSpent, uint256 amountUsdSpent) {\n        address beneficiary = _beneficiary == address(0) ? _msgSender() : _beneficiary;\n        (bool buyAllowed, uint256 maxBuy) = canBuy(_releaseId, beneficiary);\n        if (!buyAllowed) {\n            revert PurchaseError();\n        }\n\n        if (maxBuy != 0 && _amount > maxBuy) {\n            revert PurchaseError();\n        }\n\n        // Default to non-proxy operation when called directly\n        (amountSpent, amountUsdSpent) = _performPurchase(\n            _releaseId,\n            _msgSender(),\n            _maxTotalPrice,\n            _amount,\n            beneficiary,\n            _isProxyOperation\n        );\n    }\n\n    // ========== Admin Functions ==========\n\n    /// @notice Sets the max buy per transaction\n    /// @param _maxBuyPerTransaction The maximum buy per transaction (0 = unlimited)\n    function setMaxBuyPerTransaction(uint256 _maxBuyPerTransaction) external onlyRole(ADMIN_ROLE) {\n        appSettings.maxBuyPerTransaction = _maxBuyPerTransaction;\n    }\n\n    /// @notice Pauses the contract\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /// @notice Initializes the release\n    /// @param _tokenId The ID of the release\n    /// @param _additionalFees Additional fees for the release\n    function initializeRelease(\n        uint256 _tokenId,\n        FeeDistribution[] calldata _additionalFees\n    ) external onlyRole(ADMIN_ROLE) {\n        AppSettings storage $ = appSettings;\n        if (releases[_tokenId].initialized) {\n            revert ReleaseStateError(_tokenId);\n        }\n\n        if (!$.gildiManager.releaseExists(_tokenId)) {\n            revert ReleaseNotFound(_tokenId);\n        }\n\n        FeeDistribution[] memory feesToCheck = new FeeDistribution[]($.fees.length + _additionalFees.length);\n        uint256 toCheckIndex = 0;\n\n        for (uint256 i = 0; i < $.fees.length; i++) {\n            feesToCheck[toCheckIndex] = $.fees[i];\n            toCheckIndex++;\n        }\n\n        for (uint256 i = 0; i < _additionalFees.length; i++) {\n            feesToCheck[toCheckIndex] = _additionalFees[i];\n            toCheckIndex++;\n        }\n\n        _enforceValidFeeDistribution(feesToCheck);\n\n        releases[_tokenId] = Release({\n            releaseId: _tokenId,\n            initialized: true,\n            additionalFees: _additionalFees,\n            active: false,\n            isCancelling: false\n        });\n\n        releaseIds.push(_tokenId);\n\n        emit ReleaseInitialized(_tokenId);\n    }\n\n    /// @notice Sets the active state of a release\n    /// @param _releaseId The ID of the release\n    /// @param _active The active state\n    function setReleaseActive(uint256 _releaseId, bool _active) external onlyRole(ADMIN_ROLE) {\n        Release storage release = releases[_releaseId];\n\n        if (!release.initialized) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        if (_active && release.isCancelling) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        release.active = _active;\n\n        emit ReleaseActiveStateChanged(_releaseId, _active);\n    }\n\n    /// @notice Sets the fees for a specific release\n    /// @param _releaseId The ID of the release\n    /// @param _additionalFees The additional fees for the release\n    function setReleaseFees(\n        uint256 _releaseId,\n        FeeDistribution[] calldata _additionalFees\n    ) external onlyRole(ADMIN_ROLE) {\n        AppSettings storage $ = appSettings;\n        Release storage release = releases[_releaseId];\n\n        if (!release.initialized) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        FeeDistribution[] memory feesToCheck = new FeeDistribution[]($.fees.length + _additionalFees.length);\n        uint256 toCheckIndex = 0;\n\n        for (uint256 i = 0; i < $.fees.length; i++) {\n            feesToCheck[toCheckIndex] = $.fees[i];\n            toCheckIndex++;\n        }\n\n        for (uint256 i = 0; i < _additionalFees.length; i++) {\n            feesToCheck[toCheckIndex] = _additionalFees[i];\n            toCheckIndex++;\n        }\n\n        _enforceValidFeeDistribution(feesToCheck);\n        release.additionalFees = _additionalFees;\n\n        emit FeesUpdated(_releaseId);\n    }\n\n    /// @notice Sets the marketplace fees\n    function setFees(FeeDistribution[] calldata _fees) external onlyRole(ADMIN_ROLE) {\n        AppSettings storage $ = appSettings;\n\n        _enforceValidFeeDistribution(_fees);\n        $.fees = _fees;\n\n        emit FeesUpdated(0);\n    }\n\n    /// @notice Sets the number of decimals for price asks\n    /// @param _askDecimals The number of decimals for price asks (max 8)\n    function setAskDecimals(uint8 _askDecimals) public onlyRole(ADMIN_ROLE) {\n        AppSettings storage $ = appSettings;\n        if (_askDecimals == $.priceAskDecimals) {\n            return;\n        }\n\n        if (_askDecimals > 8) {\n            revert SharedErrors.ParamError();\n        }\n\n        // If the decimals changed, we need to make sure there are no listings, if there are, throw error\n        for (uint256 i = 0; i < releaseIds.length; i++) {\n            uint256 releaseId = releaseIds[i];\n            // Check if there are any listings for this release using the OrderBook\n            if ($.orderBook.listedQuantities(releaseId) > 0) {\n                revert SetupError();\n            }\n        }\n\n        $.priceAskDecimals = _askDecimals;\n        emit AskDecimalsSet(_askDecimals);\n    }\n\n    /// @notice Sets the marketplace currency\n    /// @param _marketplaceCurrency The address of the marketplace currency\n    function setMarketplaceCurrency(address _marketplaceCurrency) public onlyRole(ADMIN_ROLE) {\n        _setMarketplaceCurrency(_marketplaceCurrency);\n    }\n\n    /// @inheritdoc IGildiExchange\n    function transferTokenInContext(\n        address _from,\n        address _to,\n        uint256 _value,\n        address _amountCurrency\n    ) external override {\n        AppSettings storage $ = appSettings;\n\n        if (_amountCurrency == address(0) || _from == address(0) || _to == address(0)) {\n            revert SharedErrors.ParamError();\n        }\n\n        // Make sure caller is payment processor or fund manager\n        if (_msgSender() != address($.paymentProcessor) && _msgSender() != address($.fundManager)) {\n            revert SharedErrors.InvalidCaller();\n        }\n\n        if (_from == _to || _value == 0) {\n            return;\n        }\n\n        IERC20 token = IERC20(_amountCurrency);\n        if (_from == address(this)) {\n            token.safeTransfer(_to, _value);\n        } else {\n            token.safeTransferFrom(_from, _to, _value);\n        }\n    }\n\n    /// @inheritdoc IGildiExchange\n    function tryBurnTokenInContext(\n        address _from,\n        uint256 _value,\n        address _amountCurrency\n    ) external override returns (bool) {\n        AppSettings storage $ = appSettings;\n\n        if (_amountCurrency == address(0) || _from == address(0)) {\n            revert SharedErrors.ParamError();\n        }\n\n        // Make sure caller is payment processor\n        if (_msgSender() != address($.paymentProcessor)) {\n            revert SharedErrors.InvalidCaller();\n        }\n\n        IERC20Burnable burnable = IERC20Burnable(_amountCurrency);\n\n        // Try to burn based on source of funds\n        try burnable.burnFrom(_from, _value) {\n            return true;\n        } catch {}\n        return false;\n    }\n\n    /// @notice Sets up the exchange with required dependencies\n    /// @param _gildiPriceOracle The price oracle for currency conversions\n    /// @param _askDecimals The number of decimals for price asks\n    /// @param _orderBook The order book contract for managing listings\n    /// @param _fundManager The fund manager contract for handling funds\n    /// @param _paymentAggregator The payment aggregator for handling payments\n    function setup(\n        IGildiPriceOracle _gildiPriceOracle,\n        uint8 _askDecimals,\n        IGildiExchangeOrderBook _orderBook,\n        IGildiExchangeFundManager _fundManager,\n        IGildiExchangePaymentProcessor _paymentProcessor,\n        IGildiExchangePaymentAggregator _paymentAggregator\n    ) external onlyRole(ADMIN_ROLE) {\n        AppSettings storage $ = appSettings;\n        setAskDecimals(_askDecimals);\n\n        if (\n            address(_gildiPriceOracle) == address(0) ||\n            address(_orderBook) == address(0) ||\n            address(_fundManager) == address(0) ||\n            address(_paymentAggregator) == address(0) ||\n            address(_paymentProcessor) == address(0)\n        ) {\n            revert SharedErrors.ParamError();\n        }\n\n        $.gildiPriceOracle = _gildiPriceOracle;\n        $.orderBook = _orderBook;\n        $.fundManager = _fundManager;\n        $.paymentProcessor = _paymentProcessor;\n        $.paymentAggregator = _paymentAggregator;\n    }\n\n    // ========== View Functions ==========\n\n    /// @notice Gets the whitelist of a release.\n    /// @param _releaseId The ID of the release\n    /// @return whitelist The whitelist of the release\n    function getWhitelist(uint256 _releaseId) external view returns (address[] memory) {\n        return initialSaleWhitelistBuyers[_releaseId];\n    }\n\n    /// @inheritdoc IGildiExchange\n    function quotePricePreview(\n        uint256 _releaseId,\n        uint256 _amountToBuy,\n        address _buyer\n    ) external view override returns (uint256, address, uint256) {\n        AppSettings storage $ = appSettings;\n        Release storage release = releases[_releaseId];\n\n        // Combine multiple state checks into a single condition\n        if ((initialSales[_releaseId].active && !release.initialized) || release.isCancelling || !release.active) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        // Get the preview information from the OrderBook\n        IGildiExchangeOrderBook.PurchasePreview memory preview = $.orderBook.previewPurchase(\n            _releaseId,\n            _buyer,\n            _amountToBuy\n        );\n\n        // Check if there are enough tokens available\n        if (preview.totalQuantityAvailable < _amountToBuy) {\n            revert InsufficientQuantity(_amountToBuy, preview.totalQuantityAvailable);\n        }\n\n        // Use USD price from OrderBook's extended PurchasePreview\n        return (preview.totalPriceInCurrency, preview.currency, preview.totalPriceUsd);\n    }\n\n    /// @inheritdoc IGildiExchange\n    function getReleaseFees(uint256 _releaseId) public view override returns (FeeDistribution[] memory) {\n        AppSettings storage $ = appSettings;\n        Release storage release = releases[_releaseId];\n\n        // If initial sale is active, return initial sale fees\n        if (initialSales[_releaseId].active) {\n            return initialSales[_releaseId].fees;\n        }\n\n        // If no additional fees, just return global fees\n        if (release.additionalFees.length == 0) {\n            return $.fees;\n        }\n\n        uint256 globalLength = $.fees.length;\n        uint256 additionalLength = release.additionalFees.length;\n        FeeDistribution[] memory combinedFees = new FeeDistribution[](globalLength + additionalLength);\n\n        // Copy global fees first\n        for (uint256 i = 0; i < globalLength; i++) {\n            combinedFees[i] = $.fees[i];\n        }\n\n        // Copy additional fees at offset\n        for (uint256 i = 0; i < additionalLength; i++) {\n            combinedFees[globalLength + i] = release.additionalFees[i];\n        }\n\n        return combinedFees;\n    }\n\n    /// @inheritdoc IGildiExchange\n    function isInInitialSale(uint256 _releaseId) public view override returns (bool) {\n        InitialSale storage initialSale = initialSales[_releaseId];\n        return\n            initialSale.active && block.timestamp < initialSale.endTime && initialSaleListedQuantities[_releaseId] > 0;\n    }\n\n    /// @notice Whether or not the release is in a whitelist sale state\n    /// @param _releaseId The ID of the release\n    function isWhitelistSale(uint256 _releaseId) public view returns (bool) {\n        // First check if it's in initial sale at all\n        if (!isInInitialSale(_releaseId)) {\n            return false;\n        }\n\n        // Check whitelist settings\n        InitialSale storage initialSale = initialSales[_releaseId];\n        if (!initialSale.whitelist) {\n            return false;\n        }\n\n        // Check whitelist timing\n        return initialSale.whitelistUntil == 0 || block.timestamp < initialSale.whitelistUntil;\n    }\n\n    /// @notice Checks if a user can buy a release and determines the maximum amount they can buy\n    /// @dev Considers whitelist status, initial sale status, and transaction limits\n    /// @param _releaseId The ID of the release\n    /// @param _address The address of the buyer\n    /// @return buyAllowed True if the user can buy the release, false otherwise\n    /// @return maxBuyAmount The maximum amount the user can buy (0 if not allowed)\n    function canBuy(uint256 _releaseId, address _address) public view returns (bool buyAllowed, uint256 maxBuyAmount) {\n        AppSettings storage $ = appSettings;\n        Release storage release = releases[_releaseId];\n\n        // Check release is active\n        if (!release.active) {\n            return (false, 0);\n        }\n\n        // Check whitelist requirements\n        bool isWhitelist = isWhitelistSale(_releaseId);\n        if (isWhitelist && !isInitialSaleWhitelistBuyer[_releaseId][_address]) {\n            return (false, 0);\n        }\n\n        bool inInitialSale = isInInitialSale(_releaseId);\n        if (!inInitialSale) {\n            // Regular sale case - always allowed up to transaction limit\n            return (true, $.maxBuyPerTransaction);\n        }\n\n        // Initial sale timing check\n        InitialSale storage initialSale = initialSales[_releaseId];\n        if (block.timestamp < initialSale.startTime) {\n            return (false, 0);\n        }\n\n        // Initial sale without limit\n        if (initialSale.maxBuy == 0) {\n            return (true, $.maxBuyPerTransaction);\n        }\n\n        // Check user buy limit\n        uint256 userBought = initialSaleMaxBuyCounts[_releaseId][_address];\n        if (userBought >= initialSale.maxBuy) {\n            return (false, 0);\n        }\n\n        // User can buy the remaining amount up to transaction limit\n        return (true, Math.min(initialSale.maxBuy - userBought, $.maxBuyPerTransaction));\n    }\n\n    /// @notice Checks whether or not a list of releases can be sold.\n    /// @param _releaseIds The IDs of the releases\n    /// @return result An array containing whether or not each release can be sold\n    function canSell(uint256[] calldata _releaseIds) external view returns (bool[] memory) {\n        bool[] memory result = new bool[](_releaseIds.length);\n        for (uint256 i = 0; i < _releaseIds.length; i++) {\n            uint256 releaseId = _releaseIds[i];\n            Release storage release = releases[releaseId];\n            result[i] = release.initialized && release.active && !release.isCancelling && !isInInitialSale(releaseId);\n        }\n        return result;\n    }\n\n    /// @notice Gets a release by ID\n    /// @param _releaseId The ID of the release\n    /// @return release The release\n    function getReleaseById(uint256 _releaseId) external view returns (Release memory) {\n        return releases[_releaseId];\n    }\n\n    /// @notice Gets the initial sale by release ID\n    /// @param _releaseId The ID of the release\n    /// @return initialSale The initial sale\n    function getInitialSaleByReleaseId(uint256 _releaseId) external view returns (InitialSale memory) {\n        return initialSales[_releaseId];\n    }\n\n    /// @inheritdoc IGildiExchange\n    function getReleaseIds(bool _activeOnly) external view override returns (uint256[] memory) {\n        if (!_activeOnly) {\n            return releaseIds;\n        }\n\n        // Single-pass algorithm to count and collect active releases simultaneously\n        uint256[] memory tempReleaseIds = new uint256[](releaseIds.length);\n        uint256 activeCount = 0;\n\n        // Store length to avoid multiple storage reads\n        uint256 totalLength = releaseIds.length;\n\n        for (uint256 i = 0; i < totalLength; i++) {\n            uint256 releaseId = releaseIds[i];\n            if (releases[releaseId].active || initialSales[releaseId].active) {\n                tempReleaseIds[activeCount] = releaseId;\n                activeCount++;\n            }\n        }\n\n        // Copy to exactly-sized result array\n        uint256[] memory result = new uint256[](activeCount);\n        for (uint256 i = 0; i < activeCount; i++) {\n            result[i] = tempReleaseIds[i];\n        }\n\n        return result;\n    }\n\n    /// @inheritdoc IGildiExchange\n    function getAppEnvironment() external view override returns (AppEnvironment memory) {\n        return AppEnvironment(appSettings, BASIS_POINTS, ADMIN_ROLE, MARKETPLACE_MANAGER_ROLE, CLAIMER_ROLE);\n    }\n\n    /// @inheritdoc IGildiExchange\n    function getActiveMarketplaceReleaseAsset(uint256 _releaseId) public view override returns (address) {\n        InitialSale storage initialSale = initialSales[_releaseId];\n\n        if (isInInitialSale(_releaseId) && initialSale.saleCurrency != address(0)) {\n            return initialSale.saleCurrency;\n        }\n\n        return address(appSettings.marketplaceCurrency);\n    }\n\n    /// @inheritdoc IGildiExchange\n    function quotePrice(address _asset, uint256 _priceInUsd) public view override returns (uint256) {\n        AppSettings storage $ = appSettings;\n        return $.paymentProcessor.quoteInCurrency(_priceInUsd, _asset);\n    }\n\n    /// @notice Converts a price in USD to the equivalent amount in the release's active marketplace asset\n    /// @param _releaseId The ID of the release\n    /// @param _priceInUsd The price in USD to convert\n    /// @return activeMarketplaceReleaseAsset The address of the active marketplace asset for the release\n    /// @return priceInAsset The equivalent amount in the active marketplace asset\n    function quotePrice(\n        uint256 _releaseId,\n        uint256 _priceInUsd\n    ) external view returns (address activeMarketplaceReleaseAsset, uint256 priceInAsset) {\n        AppSettings storage $ = appSettings;\n        activeMarketplaceReleaseAsset = getActiveMarketplaceReleaseAsset(_releaseId);\n        priceInAsset = $.paymentProcessor.quoteInCurrency(_priceInUsd, activeMarketplaceReleaseAsset);\n    }\n\n    // ========== Internal Functions ==========\n\n    /// @dev Validates that a release is in a valid state for operations\n    /// @dev Reverts with ReleaseStateError if the release is not initialized, is cancelling, or is not active\n    /// @param _releaseId The ID of the release to validate\n    function _validateReleaseState(uint256 _releaseId) internal view {\n        Release storage release = releases[_releaseId];\n        if (!release.initialized || release.isCancelling || !release.active) {\n            revert ReleaseStateError(_releaseId);\n        }\n    }\n\n    /// @dev Validates that a release is initialized\n    /// @dev Reverts with ReleaseStateError if the release is not initialized\n    /// @param _releaseId The ID of the release to validate\n    function _validateReleaseInitialized(uint256 _releaseId) internal view {\n        if (!releases[_releaseId].initialized) {\n            revert ReleaseStateError(_releaseId);\n        }\n    }\n\n    /// @dev Performs the purchase of tokens from a release\n    /// @dev Handles the entire purchase flow including finding listings, transferring funds, and updating state\n    /// @param _releaseId The ID of the release to purchase\n    /// @param _operator The address performing the purchase operation\n    /// @param _maxTotalPrice The maximum total price the buyer is willing to pay\n    /// @param _amount The amount of tokens to purchase\n    /// @param _buyer The address of the buyer receiving the tokens\n    /// @param _isProxyOperation Whether this is a proxy operation\n    /// @return amountSpent The total amount spent on the purchase\n    /// @return amountUsdSpent The total amount spent in USD\n    function _performPurchase(\n        uint256 _releaseId,\n        address _operator,\n        uint256 _maxTotalPrice,\n        uint256 _amount,\n        address _buyer,\n        bool _isProxyOperation\n    ) internal returns (uint256 amountSpent, uint256 amountUsdSpent) {\n        _endInitialSaleIfNecessary(_releaseId);\n\n        AppSettings storage $ = appSettings;\n        address releaseAsset = getActiveMarketplaceReleaseAsset(_releaseId);\n\n        // Validate release state\n        _validateReleaseState(_releaseId);\n\n        // Check available buy quantity using the order book\n        uint256 availableQuantity = $.orderBook.getAvailableBuyQuantity(_releaseId, _buyer);\n        if (availableQuantity < _amount) {\n            revert NotEnoughTokensInListings(_amount, availableQuantity);\n        }\n\n        bool releaseIsInInitialSale = isInInitialSale(_releaseId);\n\n        // Initialize tracking variables\n        uint256 remainingAmount = _amount;\n        uint256 totalBought = 0;\n        uint256 totalPriceInMarketplaceCurrency = 0;\n        uint256 totalPriceInUsd = 0;\n\n        // Process listings in order of price\n        uint256 current = $.orderBook.getHeadListingId(_releaseId);\n        while (current != 0 && remainingAmount > 0) {\n            // Get the listing details\n            IGildiExchangeOrderBook.Listing memory listing = $.orderBook.getListing(current);\n\n            // Skip self-listings\n            if (listing.seller == _buyer) {\n                current = $.orderBook.getNextListingId(current);\n                continue;\n            }\n\n            // Calculate quantity to buy from this listing\n            uint256 boughtQuantity = listing.quantity >= remainingAmount ? remainingAmount : listing.quantity;\n            remainingAmount -= boughtQuantity;\n\n            // Calculate price and process payment\n            uint256 marketplaceCurrencyPricePerItem = quotePrice(releaseAsset, listing.pricePerItem);\n            uint256 listingPrice = marketplaceCurrencyPricePerItem * boughtQuantity;\n            uint256 listingUsdPrice = listing.pricePerItem * boughtQuantity;\n            _handlePaymentFlow(\n                _operator,\n                _buyer,\n                listing.fundsReceiver == address(0) ? listing.seller : listing.fundsReceiver,\n                _releaseId,\n                listingPrice,\n                releaseAsset,\n                _isProxyOperation,\n                listing.id,\n                listing.payoutCurrency,\n                listing.slippageBps\n            );\n            totalPriceInMarketplaceCurrency += listingPrice;\n            totalPriceInUsd += listingUsdPrice;\n\n            // Unlock tokens\n            $.gildiManager.unlockTokens(listing.seller, listing.releaseId, boughtQuantity);\n\n            // Transfer ownership using appropriate method based on sale state\n            if (releaseIsInInitialSale) {\n                $.gildiManager.transferOwnershipInitialSale(_releaseId, listing.seller, _buyer, boughtQuantity);\n            } else {\n                $.gildiManager.transferOwnership(_releaseId, listing.seller, _buyer, boughtQuantity);\n            }\n\n            // Log events\n            emit Purchased(\n                _releaseId,\n                _buyer,\n                listing.seller,\n                _operator,\n                listing.id,\n                listing.pricePerItem,\n                boughtQuantity,\n                marketplaceCurrencyPricePerItem,\n                releaseAsset\n            );\n\n            // Update totals\n            totalBought += boughtQuantity;\n\n            // Get next listing before modifying current one\n            uint256 nextId = $.orderBook.getNextListingId(current);\n\n            // Update the orderbook\n            $.orderBook.handleDecreaseListingQuantity(current, boughtQuantity);\n\n            current = nextId;\n        }\n\n        // Ensure price limit wasn't exceeded\n        if (totalPriceInMarketplaceCurrency > _maxTotalPrice) {\n            revert PurchaseError();\n        }\n\n        // Ensure all requested tokens were purchased\n        if (remainingAmount > 0) {\n            revert NotEnoughTokensInListings(_amount, _amount - remainingAmount);\n        }\n\n        // Handle initial sale bookkeeping if needed\n        if (releaseIsInInitialSale) {\n            initialSaleListedQuantities[_releaseId] -= totalBought;\n            initialSaleMaxBuyCounts[_releaseId][_buyer] += _amount;\n\n            if ($.orderBook.listedQuantities(_releaseId) == 0) {\n                _endInitialSale(_releaseId);\n            }\n        }\n\n        return (totalPriceInMarketplaceCurrency, totalPriceInUsd);\n    }\n\n    /// @dev Ends the initial sale for a release\n    /// @dev Cleans up all initial sale data including whitelist information\n    /// @param _releaseId The ID of the release to end initial sale for\n    function _endInitialSale(uint256 _releaseId) internal {\n        AppSettings storage $ = appSettings;\n        address[] storage buyers = initialSaleWhitelistBuyers[_releaseId];\n        uint256 buyersLength = buyers.length;\n\n        // Reset all initial sale data in one go\n        delete initialSales[_releaseId];\n\n        // Clean up whitelist data - use single loop\n        for (uint256 i = 0; i < buyersLength; i++) {\n            address buyer = buyers[i];\n            delete isInitialSaleWhitelistBuyer[_releaseId][buyer];\n            delete initialSaleMaxBuyCounts[_releaseId][buyer];\n        }\n\n        delete initialSaleWhitelistBuyers[_releaseId];\n        delete initialSaleListedQuantities[_releaseId];\n\n        if ($.gildiManager.isInInitialSale(_releaseId)) {\n            $.gildiManager.endInitialSale(_releaseId);\n        }\n\n        emit InitialSaleEnded(_releaseId);\n    }\n\n    /// @dev Creates a new listing\n    /// @param _releaseId The ID of the release\n    /// @param _seller The address of the seller\n    /// @param _pricePerItem The price per item (in USD)\n    /// @param _quantity The quantity of the listing\n    /// @param _payoutCurrency The currency to payout in\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _slippageBps The slippage tolerance in basis points\n    function _createListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) internal nonReentrant {\n        _endInitialSaleIfNecessary(_releaseId);\n\n        AppSettings storage $ = appSettings;\n        Release storage release = releases[_releaseId];\n\n        // Only the seller or someone with ADMIN_ROLE can create a listing\n        if (_seller != _msgSender() && !hasRole(ADMIN_ROLE, _msgSender())) {\n            revert SharedErrors.NotAllowed();\n        }\n\n        // Validation\n        if (release.isCancelling || !release.active) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        if ($.gildiManager.isLocked(_releaseId)) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        if ($.gildiManager.isInInitialSale(_releaseId) && isInInitialSale(_releaseId)) {\n            revert ReleaseStateError(_releaseId);\n        }\n\n        if (_slippageBps > BASIS_POINTS) {\n            revert SharedErrors.ParamError();\n        }\n\n        // Delegate to the order book\n        $.orderBook.handleCreateListing(\n            _releaseId,\n            _seller,\n            _pricePerItem,\n            _quantity,\n            _payoutCurrency,\n            _fundsReceiver,\n            _slippageBps\n        );\n    }\n\n    /// @dev Modifies an existing listing\n    /// @param _listingId The ID of the listing\n    /// @param _newPricePerItem The new price per item (in USD)\n    /// @param _newQuantity The new quantity of the listing\n    /// @param _payoutCurrency The new payout currency\n    /// @param _fundsReceiver The new address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _slippageBps The new slippage tolerance in basis points\n    function _modifyListing(\n        uint256 _listingId,\n        uint256 _newPricePerItem,\n        uint256 _newQuantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) internal nonReentrant {\n        _endInitialSaleIfNecessary(_listingId);\n\n        AppSettings storage $ = appSettings;\n\n        // Get the listing from the order book\n        IGildiExchangeOrderBook.Listing memory listing = $.orderBook.getListing(_listingId);\n\n        // Only the listing owner or someone with ADMIN_ROLE can modify a listing\n        if (listing.seller != _msgSender() && !hasRole(ADMIN_ROLE, _msgSender())) {\n            revert SharedErrors.NotAllowed();\n        }\n\n        if ($.gildiManager.isInInitialSale(listing.releaseId) && isInInitialSale(listing.releaseId)) {\n            revert ReleaseStateError(listing.releaseId);\n        }\n\n        if (_slippageBps > BASIS_POINTS) {\n            revert SharedErrors.ParamError();\n        }\n\n        // Delegate to the order book\n        $.orderBook.handleModifyListing(\n            _listingId,\n            _newPricePerItem,\n            _newQuantity,\n            _payoutCurrency,\n            _fundsReceiver,\n            _slippageBps\n        );\n    }\n\n    /// @dev Handles currency transfers between buyers and sellers\n    /// @dev Determines whether to use fund or direct transfer based on initial sale status\n    /// @param _operator The address of the operator\n    /// @param _buyer The address of the buyer\n    /// @param _seller The address of the seller\n    /// @param _releaseId The ID of the release\n    /// @param _value The value to transfer\n    /// @param _currencyAddress The address of the currency to transfer\n    /// @param _isProxyOperation Whether this is a proxy operation\n    /// @param _listingId The ID of the listing\n    /// @param _payoutCurrency The currency to payout in\n    /// @param _slippageBps The slippage tolerance in basis points\n    function _handlePaymentFlow(\n        address _operator,\n        address _buyer,\n        address _seller,\n        uint256 _releaseId,\n        uint256 _value,\n        address _currencyAddress,\n        bool _isProxyOperation,\n        uint256 _listingId,\n        address _payoutCurrency,\n        uint16 _slippageBps\n    ) internal {\n        _validateReleaseInitialized(_releaseId);\n\n        AppSettings storage $ = appSettings;\n\n        bool isFund = isInInitialSale(_releaseId);\n\n        if (isFund) {\n            // Process fees and create funds, passing the proxy operation flag\n            $.paymentProcessor.handleProcessPaymentWithFees(\n                _releaseId,\n                _buyer,\n                _seller,\n                _value,\n                _currencyAddress,\n                true,\n                _operator,\n                _isProxyOperation,\n                _listingId,\n                _payoutCurrency,\n                _slippageBps\n            );\n        } else {\n            // Process fees and make direct transfers\n            // For direct transfers we don't need to track the proxy operation flag\n            $.paymentProcessor.handleProcessPaymentWithFees(\n                _releaseId,\n                _buyer,\n                _seller,\n                _value,\n                _currencyAddress,\n                false, // _createFund\n                _operator, // Use the actual operator, not the buyer\n                false, // _isProxyOperation\n                _listingId,\n                _payoutCurrency,\n                _slippageBps\n            );\n        }\n    }\n\n    /// @dev Validates that fee distributions are valid\n    /// @dev Ensures that fee percentages don't exceed 100% (BASIS_POINTS) for both parent and sub-fees\n    /// @param _feeDistributions Array of fee distributions to validate\n    function _enforceValidFeeDistribution(FeeDistribution[] memory _feeDistributions) internal pure {\n        uint256 sum = 0;\n        uint256 feeLength = _feeDistributions.length;\n\n        for (uint256 i = 0; i < feeLength; i++) {\n            // Add parent fee, check immediately\n            sum += _feeDistributions[i].feeReceiver.value;\n            if (sum > BASIS_POINTS) {\n                revert SetupError();\n            }\n\n            // Check sub fees in a separate loop\n            uint256 subSum = 0;\n            uint256 subLength = _feeDistributions[i].subFeeReceivers.length;\n\n            for (uint256 j = 0; j < subLength; j++) {\n                subSum += _feeDistributions[i].subFeeReceivers[j].value;\n            }\n\n            if (subSum > BASIS_POINTS) {\n                revert SetupError();\n            }\n        }\n    }\n\n    /// @dev Checks if an initial sale should be ended and ends it if necessary\n    /// @dev Ends the initial sale if it's active but no longer in the initial sale period\n    /// @param _releaseId The ID of the release to check\n    function _endInitialSaleIfNecessary(uint256 _releaseId) internal {\n        if (initialSales[_releaseId].active && !isInInitialSale(_releaseId)) {\n            _endInitialSale(_releaseId);\n        }\n    }\n\n    /// @dev Sets the marketplace currency\n    /// @param _marketplaceCurrency The address of the marketplace currency\n    function _setMarketplaceCurrency(address _marketplaceCurrency) private {\n        AppSettings storage $ = appSettings;\n        $.marketplaceCurrency = IERC20(_marketplaceCurrency);\n\n        emit MarketplaceCurrencySet(_marketplaceCurrency);\n    }\n\n    // ---------------------------------------------------------------------------\n    // End of contract logic\n    // ---------------------------------------------------------------------------\n\n    // ---------------------------------------------------------------------------\n    // Fallback functions\n    // ---------------------------------------------------------------------------\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    fallback() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    receive() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangeFundManager.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport {\n    IGildiExchange,\n    IGildiExchangePaymentAggregator\n} from '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport {IGildiExchangeFundManager} from '../../interfaces/marketplace/exchange/IGildiExchangeFundManager.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {SharedErrors} from '../../libraries/marketplace/exchange/SharedErrors.sol';\n\n/// @title Gildi Exchange Fund Manager\n/// @notice Manages fund functionality for the Gildi Exchange marketplace.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiExchangeFundManager is Initializable, ReentrancyGuardUpgradeable, IGildiExchangeFundManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20 for IERC20;\n\n    // ========== Events ==========\n    /// @notice Emitted when a user claims funds\n    /// @param releaseId The ID of the release\n    /// @param fundParticipant The fund participant (seller or fee participant) claiming funds\n    /// @param amount The amount claimed\n    /// @param currency The currency of the fund\n    event FundClaimed(uint256 indexed releaseId, address indexed fundParticipant, uint256 amount, address currency);\n\n    /// @notice Emitted when an fund is cancelled and funds are returned\n    /// @param releaseId The ID of the release\n    /// @param fundParticipant The fund participant (seller or fee participant)\n    /// @param returnedTo The address that received the returned funds\n    /// @param amount The amount returned\n    /// @param currency The currency of the fund\n    event FundCancelled(\n        uint256 indexed releaseId,\n        address indexed fundParticipant,\n        address indexed returnedTo,\n        uint256 amount,\n        address currency\n    );\n\n    /// @notice Emitted when an fund is added\n    /// @param releaseId The ID of the release\n    /// @param fundParticipant The fund participant (seller or fee participant)\n    /// @param amount The amount added\n    /// @param amountCurrency The currency of the fund amount\n    /// @param payoutCurrency The currency to payout in\n    event FundAdded(\n        uint256 indexed releaseId,\n        address indexed fundParticipant,\n        uint256 amount,\n        address amountCurrency,\n        address payoutCurrency\n    );\n\n    /// @notice Emitted when funds are transferred to a participant\n    /// @param releaseId The ID of the release\n    /// @param from The contract address (normally this contract)\n    /// @param to The fund participant receiving the funds\n    /// @param sourceToken The source token used for payment\n    /// @param amount The amount of source token\n    /// @param payoutToken The token received by the recipient (may differ from sourceToken if swapped)\n    /// @param swapAmount The amount received after swap (if performed)\n    /// @param swapRequested Whether a token swap was requested\n    /// @param swapSuccessful Whether the swap was successful (if requested)\n    /// @param slippageBps The slippage tolerance in basis points used for swaps\n    event FundTransferred(\n        uint256 indexed releaseId,\n        address indexed from,\n        address indexed to,\n        address sourceToken,\n        uint256 amount,\n        address payoutToken,\n        uint256 swapAmount,\n        bool swapRequested,\n        bool swapSuccessful,\n        uint16 slippageBps\n    );\n\n    // ========== Errors ==========\n    /// @dev Error thrown when an incompatible currency is provided\n    error InvalidCurrency();\n\n    /// @dev Error thrown when a fund is not found\n    /// @param releaseId The ID of the release\n    /// @param participant The address of the fund participant\n    error FundNotFound(uint256 releaseId, address participant);\n\n    // ========== Structs ==========\n    /// @notice Structure to hold pending fund amounts for a release\n    struct PendingFundAmounts {\n        /// @dev The ID of the release\n        uint256 releaseId;\n        /// @dev The list of participants with funds\n        address[] participants;\n        /// @dev The fund amounts for each participant\n        FundAmount[] amounts;\n        /// @dev Whether the funds are claimable\n        bool claimable;\n    }\n\n    // ========== Constants ==========\n    /// @notice Default slippage tolerance in basis points (5%)\n    uint16 public constant DEFAULT_SLIPPAGE_BPS = 500;\n\n    // ========== Storage Variables ==========\n\n    /// @notice The GildiExchange contract that calls this contract\n    IGildiExchange public gildiExchange;\n\n    /// @notice A set of release IDs that have funds\n    EnumerableSet.UintSet private releaseIdsWithFunds;\n\n    /// @notice Maps release IDs to the funds for each participant\n    /// @dev releaseId => participant => funds[]\n    mapping(uint256 => mapping(address => Fund[])) private releaseFundsByParticipant;\n\n    /// @notice Maps release IDs to all fund participants\n    /// @dev releaseId => participants[]\n    mapping(uint256 => address[]) private releaseFundParticipants;\n\n    /// @notice Maps release IDs to the total fund amount for each participant\n    /// @dev releaseId => participant => amount\n    mapping(uint256 => mapping(address => FundAmount)) private releaseFundAmountByParticipant;\n\n    /// @notice Ensures that only the GildiExchange contract can call this function\n    modifier onlyGildiExchange() {\n        if (msg.sender != address(gildiExchange)) {\n            revert SharedErrors.InvalidCaller();\n        }\n        _;\n    }\n\n    /// @notice Ensures that only the payment processor can call this function\n    modifier onlyPaymentProcessor() {\n        IGildiExchange.AppEnvironment memory env = gildiExchange.getAppEnvironment();\n        if (msg.sender != address(env.settings.paymentProcessor)) {\n            revert SharedErrors.InvalidCaller();\n        }\n        _;\n    }\n\n    modifier onlyClaimer() {\n        IGildiExchange.AppEnvironment memory env = gildiExchange.getAppEnvironment();\n        bytes32 claimerRole = env.claimerRole;\n        if (!gildiExchange.hasRole(claimerRole, msg.sender)) {\n            revert SharedErrors.InvalidCaller();\n        }\n        _;\n    }\n\n    // ========== Constructor and Initializer ==========\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param _gildiExchange The address of the GildiExchange contract\n    function initialize(address _gildiExchange) external initializer {\n        __ReentrancyGuard_init();\n\n        gildiExchange = IGildiExchange(_gildiExchange);\n    }\n\n    // ========== External View Functions ==========\n\n    /// @notice Gets all fund participants for a release\n    /// @param _releaseId The ID of the release\n    /// @return An array of participant addresses\n    function getReleaseFundParticipants(uint256 _releaseId) external view returns (address[] memory) {\n        return releaseFundParticipants[_releaseId];\n    }\n\n    /// @notice Gets the total fund amount for a participant of a release\n    /// @param _releaseId The ID of the release\n    /// @param _participant The address of the fund participant\n    /// @return The fund amount details\n    function getReleaseFundAmount(uint256 _releaseId, address _participant) external view returns (FundAmount memory) {\n        return releaseFundAmountByParticipant[_releaseId][_participant];\n    }\n\n    /// @notice Retrieves funds for a participant of a release\n    /// @param _releaseId The ID of the release\n    /// @param _participant The address of the fund participant\n    /// @param _cursor The starting index for pagination\n    /// @param _length The number of funds to retrieve\n    /// @return funds An array of funds\n    /// @return nextCursor The next cursor for pagination\n    function getReleaseFunds(\n        uint256 _releaseId,\n        address _participant,\n        uint256 _cursor,\n        uint256 _length\n    ) external view returns (Fund[] memory funds, uint256 nextCursor) {\n        Fund[] storage participantFunds = releaseFundsByParticipant[_releaseId][_participant];\n        if (_cursor >= participantFunds.length) {\n            return (new Fund[](0), participantFunds.length);\n        }\n\n        // Default length: 100\n        if (_length == 0) {\n            _length = 100;\n        }\n\n        // Return the funds starting from the cursor and limited by length\n        uint256 start = _cursor;\n        uint256 end = start + _length;\n        if (end > participantFunds.length) {\n            end = participantFunds.length;\n        }\n\n        // Return the funds\n        funds = new Fund[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            funds[i - start] = participantFunds[i];\n        }\n\n        nextCursor = end;\n    }\n\n    /// @inheritdoc IGildiExchangeFundManager\n    function releaseHasFunds(uint256 _releaseId) external view returns (bool) {\n        return releaseIdsWithFunds.contains(_releaseId);\n    }\n\n    /// @notice Gets all release IDs that have funds\n    /// @return An array of release IDs that currently have active funds\n    function getReleaseIdsWithFunds() external view returns (uint256[] memory) {\n        uint256 length = releaseIdsWithFunds.length();\n        uint256[] memory ids = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            ids[i] = releaseIdsWithFunds.at(i);\n        }\n\n        return ids;\n    }\n\n    // ========== External Non-View Functions ==========\n\n    /// @inheritdoc IGildiExchangeFundManager\n    function handleAddToFund(\n        uint256 _releaseId,\n        address _participant,\n        address _buyer,\n        address _operator,\n        bool _isProxyOperation,\n        uint256 _amount,\n        address _amountCurrency,\n        address _payoutCurrency\n    ) external onlyPaymentProcessor {\n        // Create or add to fund\n        if (releaseFundsByParticipant[_releaseId][_participant].length == 0) {\n            releaseFundParticipants[_releaseId].push(_participant);\n            // Add release to releaseIdsWithFunds if not already added\n            if (!releaseIdsWithFunds.contains(_releaseId)) {\n                releaseIdsWithFunds.add(_releaseId);\n            }\n        }\n\n        releaseFundsByParticipant[_releaseId][_participant].push(\n            Fund({\n                buyer: _buyer,\n                operator: _operator,\n                fundParticipant: _participant,\n                isProxyOperation: _isProxyOperation,\n                amount: FundAmount(_amount, _amountCurrency),\n                payoutCurrency: _payoutCurrency\n            })\n        );\n\n        // Update total fund amount\n        FundAmount storage fundAmount = releaseFundAmountByParticipant[_releaseId][_participant];\n        fundAmount.value += _amount;\n\n        if (fundAmount.currencyAddress == address(0)) {\n            fundAmount.currencyAddress = _amountCurrency;\n        } else if (fundAmount.currencyAddress != _amountCurrency) {\n            revert InvalidCurrency();\n        }\n\n        // Emit event for fund added\n        emit FundAdded(_releaseId, _participant, _amount, _amountCurrency, _payoutCurrency);\n    }\n\n    /// @notice Claims funds for a participant of a release\n    /// @param _releaseId The ID of the release\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _slippageBps Optional slippage tolerance in basis points (100 = 1%, 500 = 5%)\n    function claimFunds(uint256 _releaseId, address _fundParticipant, uint16 _slippageBps) external nonReentrant {\n        _claimFunds(_releaseId, _fundParticipant, _slippageBps);\n    }\n\n    /// @notice Claims funds for a participant of a release with default slippage (5%)\n    /// @param _releaseId The ID of the release\n    /// @param _fundParticipant The address of the fund participant\n    function claimFunds(uint256 _releaseId, address _fundParticipant) external nonReentrant {\n        _claimFunds(_releaseId, _fundParticipant, DEFAULT_SLIPPAGE_BPS);\n    }\n\n    /// @notice Claims all funds for a participant across all releases\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _slippageBps Optional slippage tolerance in basis points (100 = 1%, 500 = 5%)\n    function claimAllFunds(address _fundParticipant, uint16 _slippageBps) external nonReentrant {\n        _claimAllFunds(_fundParticipant, _slippageBps);\n    }\n\n    /// @notice Claims all funds for a participant across all releases with default slippage (5%)\n    /// @param _fundParticipant The address of the fund participant\n    function claimAllFunds(address _fundParticipant) external nonReentrant {\n        _claimAllFunds(_fundParticipant, DEFAULT_SLIPPAGE_BPS);\n    }\n\n    /// @notice Claims all funds for all participants of a specific release\n    /// @param _releaseId The ID of the release\n    function claimAllFundsByReleaseId(uint256 _releaseId) external nonReentrant {\n        if (!_isClaimable(_releaseId)) {\n            revert SharedErrors.NotAllowed();\n        }\n\n        _claimAllFundsByReleaseId(_releaseId);\n    }\n\n    /// @notice Claims all funds for all participants across all releases\n    function claimAllFunds() external nonReentrant {\n        for (uint256 i = releaseIdsWithFunds.length(); i > 0; i--) {\n            uint256 releaseId = releaseIdsWithFunds.at(i - 1);\n\n            if (_isClaimable(releaseId)) {\n                _claimAllFundsByReleaseId(releaseId);\n            }\n        }\n    }\n\n    /// @inheritdoc IGildiExchangeFundManager\n    function handleCancelReleaseFunds(\n        uint256 _releaseId,\n        uint256 _batchSize\n    ) external onlyGildiExchange returns (uint256 processed) {\n        uint256 i = 0;\n\n        // Process funds\n        while (releaseFundParticipants[_releaseId].length > 0 && i < _batchSize) {\n            uint256 length = releaseFundParticipants[_releaseId].length;\n            address fundParticipant = releaseFundParticipants[_releaseId][length - 1];\n            Fund[] storage funds = releaseFundsByParticipant[_releaseId][fundParticipant];\n\n            while (funds.length > 0 && i < _batchSize) {\n                Fund storage fund = funds[funds.length - 1];\n\n                // Determine the correct refund participant based on operation type\n                address refundParticipant = fund.isProxyOperation ? fund.buyer : fund.operator;\n\n                try IERC20(fund.amount.currencyAddress).transfer(refundParticipant, fund.amount.value) returns (\n                    bool success\n                ) {\n                    if (!success) continue; // Skip if transfer failed, silently fail, token might be locked\n                    emit FundCancelled(\n                        _releaseId,\n                        fund.fundParticipant,\n                        refundParticipant,\n                        fund.amount.value,\n                        fund.amount.currencyAddress\n                    );\n                    funds.pop();\n                } catch {}\n                i++;\n            }\n\n            if (funds.length == 0) {\n                delete releaseFundsByParticipant[_releaseId][fundParticipant];\n                delete releaseFundAmountByParticipant[_releaseId][fundParticipant];\n                releaseFundParticipants[_releaseId].pop();\n\n                // Remove release ID from set if no more participants\n                if (releaseFundParticipants[_releaseId].length == 0) {\n                    releaseIdsWithFunds.remove(_releaseId);\n                }\n            }\n        }\n\n        return i;\n    }\n\n    // ========== Public View Functions ==========\n\n    /// @notice Fetches pending fund amounts for a participant and release\n    /// @dev if releaseId is 0, fetches for all releases, if participant is 0, fetches for all participants\n    /// @param _releaseId The ID of the release\n    /// @param _participant The address of the fund participant\n    /// @return An array of pending fund amounts with claimable status\n    function fetchPendingFundAmounts(\n        uint256 _releaseId,\n        address _participant\n    ) public view returns (PendingFundAmounts[] memory) {\n        uint256[] memory releaseIds;\n\n        if (_releaseId != 0) {\n            releaseIds = new uint256[](1);\n            releaseIds[0] = _releaseId;\n        } else {\n            uint256 length = releaseIdsWithFunds.length();\n            releaseIds = new uint256[](length);\n\n            for (uint256 i = 0; i < length; i++) {\n                releaseIds[i] = releaseIdsWithFunds.at(i);\n            }\n        }\n\n        PendingFundAmounts[] memory tempPendingReleaseAmounts = new PendingFundAmounts[](releaseIds.length);\n\n        uint256 countRelease = 0;\n        for (uint256 i = 0; i < releaseIds.length; i++) {\n            uint256 releaseId = releaseIds[i];\n            address[] storage participants = releaseFundParticipants[releaseId];\n            if (participants.length == 0) {\n                // Release has no funds\n                continue;\n            }\n\n            uint256 countParticipants = 0;\n            address[] memory tempParticipants = new address[](participants.length);\n            FundAmount[] memory tempFundAmounts = new FundAmount[](participants.length);\n\n            for (uint256 j = 0; j < participants.length; j++) {\n                address participant = participants[j];\n                if (_participant != address(0) && participant != _participant) {\n                    continue;\n                }\n\n                FundAmount storage fundAmount = releaseFundAmountByParticipant[releaseId][participant];\n                if (fundAmount.value == 0) {\n                    continue;\n                }\n\n                tempParticipants[countParticipants] = participant;\n                tempFundAmounts[countParticipants] = fundAmount;\n                countParticipants++;\n            }\n\n            if (countParticipants == 0) {\n                continue;\n            }\n\n            // Resize participants and amounts arrays\n            address[] memory resizedParticipants = new address[](countParticipants);\n            FundAmount[] memory resizedFundAmounts = new FundAmount[](countParticipants);\n            for (uint256 k = 0; k < countParticipants; k++) {\n                resizedParticipants[k] = tempParticipants[k];\n                resizedFundAmounts[k] = tempFundAmounts[k];\n            }\n\n            tempPendingReleaseAmounts[countRelease] = PendingFundAmounts({\n                releaseId: releaseId,\n                participants: resizedParticipants,\n                amounts: resizedFundAmounts,\n                claimable: _isClaimable(releaseId)\n            });\n            countRelease++;\n        }\n\n        // Resize pending release amounts array\n        PendingFundAmounts[] memory pendingReleaseAmounts = new PendingFundAmounts[](countRelease);\n        for (uint256 i = 0; i < countRelease; i++) {\n            pendingReleaseAmounts[i] = tempPendingReleaseAmounts[i];\n        }\n\n        return pendingReleaseAmounts;\n    }\n\n    // ========== Internal Functions ==========\n\n    /// @dev Claims funds for a specific participant of a release\n    /// @param _releaseId The ID of the release\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _slippageBps Slippage tolerance in basis points (100 = 1%, 500 = 5%)\n    function _claimFunds(uint256 _releaseId, address _fundParticipant, uint16 _slippageBps) internal {\n        if (_fundParticipant == address(0)) {\n            revert SharedErrors.ParamError();\n        }\n\n        if (gildiExchange.isInInitialSale(_releaseId)) {\n            revert SharedErrors.NotAllowed();\n        }\n\n        bytes32 claimerRole = gildiExchange.getAppEnvironment().claimerRole;\n        // If the caller does not have CLAIMER_ROLE he is only allowed to claim funds for himself\n        if (!gildiExchange.hasRole(claimerRole, msg.sender) && msg.sender != _fundParticipant) {\n            revert SharedErrors.NotAllowed();\n        }\n\n        // Check if there's an fund to claim\n        FundAmount storage fundAmount = releaseFundAmountByParticipant[_releaseId][_fundParticipant];\n        if (fundAmount.value == 0) revert FundNotFound(_releaseId, _fundParticipant);\n\n        // Get the fund details to determine the payout currency\n        Fund[] storage funds = releaseFundsByParticipant[_releaseId][_fundParticipant];\n        if (funds.length == 0) revert FundNotFound(_releaseId, _fundParticipant);\n\n        // Cache these values to reduce stack depth\n        uint256 amountValue = fundAmount.value;\n        address currencyAddress = fundAmount.currencyAddress;\n        address payoutCurrency = funds[0].payoutCurrency;\n\n        // Transfer logic\n        _handleFundTransfer(_releaseId, _fundParticipant, amountValue, currencyAddress, payoutCurrency, _slippageBps);\n\n        // Clean up fund data\n        delete releaseFundsByParticipant[_releaseId][_fundParticipant];\n        delete releaseFundAmountByParticipant[_releaseId][_fundParticipant];\n\n        // Remove fund participant from array using swap-and-pop pattern\n        address[] storage fundParticipants = releaseFundParticipants[_releaseId];\n        uint256 length = fundParticipants.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            if (fundParticipants[i] == _fundParticipant) {\n                // Replace with last element and pop\n                fundParticipants[i] = fundParticipants[length - 1];\n                fundParticipants.pop();\n                break;\n            }\n        }\n\n        // Remove release ID from set if no more participants\n        if (fundParticipants.length == 0) {\n            releaseIdsWithFunds.remove(_releaseId);\n        }\n\n        emit FundClaimed(_releaseId, _fundParticipant, amountValue, currencyAddress);\n    }\n\n    /// @dev Claims all funds for a participant across all releases. Iterates backwards\n    /// over releases and participants to safely handle state modifications during claims.\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _slippageBps Slippage tolerance in basis points (100 = 1%, 500 = 5%)\n    function _claimAllFunds(address _fundParticipant, uint16 _slippageBps) internal {\n        for (uint256 i = releaseIdsWithFunds.length(); i > 0; i--) {\n            uint256 releaseId = releaseIdsWithFunds.at(i - 1);\n\n            if (!_isClaimable(releaseId)) {\n                continue;\n            }\n\n            address[] storage participants = releaseFundParticipants[releaseId];\n            // Iterate backwards to avoid skipping elements on mutation\n            for (uint256 j = participants.length; j > 0; j--) {\n                if (_fundParticipant != address(0) && _fundParticipant == participants[j - 1]) {\n                    _claimFunds(releaseId, _fundParticipant, _slippageBps);\n                }\n            }\n        }\n    }\n\n    /// @dev Claims all funds for all participants of a specific release\n    /// @param _releaseId The ID of the release\n    function _claimAllFundsByReleaseId(uint256 _releaseId) internal onlyClaimer {\n        address[] storage participants = releaseFundParticipants[_releaseId];\n        for (uint256 i = participants.length; i > 0; i--) {\n            address fundParticipant = participants[i - 1];\n            _claimFunds(_releaseId, fundParticipant, DEFAULT_SLIPPAGE_BPS);\n        }\n    }\n\n    // ========== Private Functions ==========\n\n    /// @dev Checks if a release is claimable\n    /// @param _releaseId The ID of the release\n    /// @return True if the release is claimable, false otherwise\n    function _isClaimable(uint256 _releaseId) private view returns (bool) {\n        if (gildiExchange.isInInitialSale(_releaseId) || !releaseIdsWithFunds.contains(_releaseId)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Handles the transfer logic for a fund claim\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _amount The amount to transfer\n    /// @param _currencyAddress The currency address of the fund\n    /// @param _payoutCurrency The preferred payout currency\n    /// @param _slippageBps Slippage tolerance in basis points\n    function _handleFundTransfer(\n        uint256 _releaseId,\n        address _fundParticipant,\n        uint256 _amount,\n        address _currencyAddress,\n        address _payoutCurrency,\n        uint16 _slippageBps\n    ) private {\n        uint16 basisPoints = gildiExchange.getAppEnvironment().basisPoints;\n\n        if (_slippageBps > basisPoints) {\n            revert SharedErrors.ParamError();\n        }\n\n        bool swapRequested = false;\n        bool swapSuccessful = false;\n        address finalPayoutCurrency = _payoutCurrency;\n        uint256 finalAmount = _amount; // Initialize to original amount, will be updated if swap is successful\n\n        // If payout currency is the same as the fund currency or not specified, direct transfer\n        if (_payoutCurrency == address(0) || _payoutCurrency == _currencyAddress) {\n            IERC20(_currencyAddress).safeTransfer(_fundParticipant, _amount);\n            finalPayoutCurrency = _currencyAddress;\n        } else {\n            swapRequested = true;\n\n            // Get the payment aggregator from the exchange\n            IGildiExchangePaymentAggregator paymentAggregator = gildiExchange\n                .getAppEnvironment()\n                .settings\n                .paymentAggregator;\n\n            // If payment aggregator is not set, fallback to direct transfer\n            if (address(paymentAggregator) == address(0)) {\n                IERC20(_currencyAddress).safeTransfer(_fundParticipant, _amount);\n                finalPayoutCurrency = _currencyAddress;\n            } else {\n                // Approve the payment aggregator to spend the tokens\n                IERC20 sourceToken = IERC20(_currencyAddress);\n                uint256 allowance = sourceToken.allowance(address(this), address(paymentAggregator));\n                if (allowance < _amount) {\n                    sourceToken.forceApprove(address(paymentAggregator), type(uint256).max);\n                }\n\n                // Preview the swap to get expected amount\n                (bool hasValidRoute, uint256 expectedAmount, ) = paymentAggregator.previewSwapOut(\n                    _amount,\n                    _currencyAddress,\n                    _payoutCurrency\n                );\n                if (hasValidRoute && expectedAmount > 0) {\n                    // Calculate minimum amount based on slippage (10000 - slippageBps) / 10000\n                    uint256 minAmount = (expectedAmount * (basisPoints - _slippageBps)) / basisPoints;\n                    try\n                        paymentAggregator.swapOut(\n                            _amount,\n                            _currencyAddress,\n                            _payoutCurrency,\n                            minAmount,\n                            _fundParticipant\n                        )\n                    returns (uint256 swapAmount) {\n                        // Swap successful\n                        swapSuccessful = true;\n                        finalPayoutCurrency = _payoutCurrency;\n                        finalAmount = swapAmount;\n                    } catch {\n                        // Swap failed, fallback to direct transfer\n                        sourceToken.safeTransfer(_fundParticipant, _amount);\n                        finalPayoutCurrency = _currencyAddress;\n                    }\n                } else {\n                    // No valid route, fallback to direct transfer\n                    sourceToken.safeTransfer(_fundParticipant, _amount);\n                    finalPayoutCurrency = _currencyAddress;\n                }\n            }\n        }\n\n        // Emit fund transferred event\n        emit FundTransferred(\n            _releaseId,\n            address(this),\n            _fundParticipant,\n            _currencyAddress,\n            _amount,\n            finalPayoutCurrency,\n            finalAmount,\n            swapRequested,\n            swapSuccessful,\n            _slippageBps\n        );\n    }\n\n    // ---------------------------------------------------------------------------\n    // Fallback functions\n    // ---------------------------------------------------------------------------\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    fallback() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    receive() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangeOrderBook.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {IGildiExchange} from '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport {IGildiExchangeOrderBook} from '../../interfaces/marketplace/exchange/IGildiExchangeOrderBook.sol';\nimport {IGildiManager} from '../../interfaces/manager/IGildiManager.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {SharedErrors} from '../../libraries/marketplace/exchange/SharedErrors.sol';\n\n/// @title Gildi Exchange Order Book\n/// @notice Manages listings and order book functionality for the Gildi Exchange marketplace.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiExchangeOrderBook is Initializable, Context, IGildiExchangeOrderBook {\n    // ========== Events ==========\n    /// @notice Emitted when a new listing is created\n    /// @param listingId The ID of the listing\n    /// @param releaseId The ID of the release\n    /// @param seller The address of the seller\n    /// @param price The price per item\n    /// @param quantity The quantity listed\n    event Listed(\n        uint256 indexed listingId,\n        uint256 indexed releaseId,\n        address indexed seller,\n        uint256 price,\n        uint256 quantity\n    );\n\n    /// @notice Emitted when a listing is removed\n    /// @param listingId The ID of the listing\n    /// @param releaseId The ID of the release\n    /// @param seller The address of the seller\n    /// @param quantity The quantity unlisted\n    event Unlisted(uint256 indexed listingId, uint256 indexed releaseId, address indexed seller, uint256 quantity);\n\n    /// @notice Emitted when a listing is modified\n    /// @param listingId The ID of the listing\n    /// @param releaseId The ID of the release\n    /// @param seller The address of the seller\n    /// @param price The new price per item\n    /// @param quantity The new quantity\n    event Modified(\n        uint256 indexed listingId,\n        uint256 indexed releaseId,\n        address indexed seller,\n        uint256 price,\n        uint256 quantity\n    );\n\n    // ========== Errors ==========\n    /// @dev Error thrown when the caller is not the GildiExchange\n    error NotGildiExchange();\n\n    // ========== Storage Variables ==========\n    /// @notice The GildiExchange contract that this order book is associated with\n    IGildiExchange public gildiExchange;\n    /// @notice The GildiManager contract used for token management\n    IGildiManager public gildiManager;\n\n    /// @dev The next available listing ID to assign\n    uint256 private nextListingId;\n    /// @dev Mapping from listing ID to Listing struct\n    mapping(uint256 => Listing) private listings;\n    /// @dev Mapping from release ID to an array of listing IDs for that release\n    mapping(uint256 => uint256[]) private tokenListings;\n    /// @dev Mapping from seller address to an array of their listing IDs\n    mapping(address => uint256[]) private sellerListings;\n    /// @dev Mapping from release ID to the ID of the listing with the lowest price for that release\n    mapping(uint256 => uint256) private headListingIds;\n    /// @dev Mapping from release ID to the ID of the listing with the highest price for that release\n    mapping(uint256 => uint256) private tailListingIds;\n    /// @dev Mapping from release ID to the total quantity of tokens listed for that release\n    mapping(uint256 => uint256) private listedQuantitiesMap;\n\n    /// @notice Ensures that only the GildiExchange contract can call this function\n    modifier onlyGildiExchange() {\n        if (msg.sender != address(gildiExchange)) {\n            revert NotGildiExchange();\n        }\n        _;\n    }\n\n    // ========== Constructor and Initializer ==========\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param _gildiExchange The address of the GildiExchange contract\n    /// @param _gildiManager The address of the GildiManager contract\n    function initialize(address _gildiExchange, address _gildiManager) external initializer {\n        gildiExchange = IGildiExchange(_gildiExchange);\n        gildiManager = IGildiManager(_gildiManager);\n        nextListingId = 1;\n    }\n\n    // ========== External View Functions ==========\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function getListing(uint256 _listingId) external view override returns (Listing memory) {\n        return listings[_listingId];\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function getListingsOfSeller(address _seller) external view override returns (Listing[] memory) {\n        uint256[] storage listingIds = sellerListings[_seller];\n        Listing[] memory result = new Listing[](listingIds.length);\n\n        for (uint256 i = 0; i < listingIds.length; i++) {\n            result[i] = listings[listingIds[i]];\n        }\n\n        return result;\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function getOrderedListings(\n        uint256 _releaseId,\n        uint256 _cursor,\n        uint256 _limit\n    ) external view override returns (Listing[] memory orderedListings, uint256 cursor) {\n        // 1. Sort the listings\n        uint256[] memory sortedListingIds = new uint256[](tokenListings[_releaseId].length);\n        uint256 count = 0;\n        uint256 currentId = headListingIds[_releaseId];\n\n        while (currentId != 0) {\n            sortedListingIds[count] = currentId;\n            count++;\n            currentId = listings[currentId].nextListingId;\n        }\n\n        // 2. Determine the number of listings to return\n        uint256 remaining = (count > _cursor) ? count - _cursor : 0;\n        uint256 resultSize = remaining < _limit ? remaining : _limit;\n\n        // 3. Get the listings\n        Listing[] memory result = new Listing[](resultSize);\n        uint256 resultIndex = 0;\n\n        for (uint256 i = _cursor; i < count && resultIndex < resultSize; i++) {\n            result[resultIndex] = listings[sortedListingIds[i]];\n            resultIndex++;\n        }\n\n        // If all listings are retrieved, set nextCursor to the sortedIndex\n        uint256 nextCursor = _cursor + resultSize;\n        if (nextCursor >= count) {\n            nextCursor = count;\n        }\n\n        return (result, nextCursor);\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function getAvailableBuyQuantity(uint256 _releaseId, address _user) external view override returns (uint256) {\n        // Subtract user's listed tokens from the total available to avoid self-purchases\n        uint256 qty = listedQuantitiesMap[_releaseId];\n\n        for (uint256 i = 0; i < sellerListings[_user].length; i++) {\n            if (listings[sellerListings[_user][i]].releaseId == _releaseId) {\n                qty -= listings[sellerListings[_user][i]].quantity;\n            }\n        }\n\n        return qty;\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function previewPurchase(\n        uint256 _releaseId,\n        address _buyer,\n        uint256 _amountToBuy\n    ) external view override returns (PurchasePreview memory) {\n        uint256 remainingToBuy = _amountToBuy;\n        uint256 totalPriceInMarketplaceCurrency = 0;\n        uint256 totalPriceUsd = 0;\n        uint256 totalAvailable = 0;\n\n        uint256 current = headListingIds[_releaseId];\n\n        address releaseAsset = gildiExchange.getActiveMarketplaceReleaseAsset(_releaseId);\n        while (current != 0 && remainingToBuy > 0) {\n            Listing storage listing = listings[current];\n\n            // Skip listing if the seller *is* the buyer\n            if (listing.seller == _buyer) {\n                current = listing.nextListingId;\n                continue;\n            }\n\n            // Take as many tokens from this listing as we can\n            uint256 localQty = listing.quantity;\n            if (localQty == 0) {\n                // listing is empty; move on\n                current = listing.nextListingId;\n                continue;\n            }\n\n            // chunk = min(remainingToBuy, localQty)\n            uint256 chunk = (localQty >= remainingToBuy) ? remainingToBuy : localQty;\n\n            uint256 mcPricePerItem = gildiExchange.quotePrice(releaseAsset, listing.pricePerItem);\n\n            // add this chunk's cost to totals\n            totalPriceInMarketplaceCurrency += (mcPricePerItem * chunk);\n            totalPriceUsd += (listing.pricePerItem * chunk); // pricePerItem is in USD with priceAskDecimals\n            totalAvailable += chunk;\n\n            // reduce remaining\n            remainingToBuy -= chunk;\n\n            // Move on to next listing\n            current = listing.nextListingId;\n        }\n\n        return\n            PurchasePreview({\n                totalQuantityAvailable: totalAvailable,\n                totalPriceInCurrency: totalPriceInMarketplaceCurrency,\n                currency: releaseAsset,\n                totalPriceUsd: totalPriceUsd\n            });\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function getHeadListingId(uint256 _releaseId) external view override returns (uint256) {\n        return headListingIds[_releaseId];\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function getNextListingId(uint256 _listingId) external view override returns (uint256) {\n        return listings[_listingId].nextListingId;\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function listedQuantities(uint256 _releaseId) external view override returns (uint256) {\n        return listedQuantitiesMap[_releaseId];\n    }\n\n    // ========== External Non-View Functions ==========\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function handleCreateListing(\n        uint256 _releaseId,\n        address _seller,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external override onlyGildiExchange {\n        if (_quantity == 0) {\n            revert SharedErrors.ParamError();\n        }\n\n        gildiManager.lockTokens(_seller, _releaseId, _quantity);\n\n        uint256 listingId = nextListingId;\n        nextListingId++;\n\n        Listing memory newListing = Listing({\n            id: listingId,\n            releaseId: _releaseId,\n            seller: _seller,\n            pricePerItem: _pricePerItem,\n            payoutCurrency: _payoutCurrency,\n            quantity: _quantity,\n            createdAt: block.timestamp,\n            modifiedAt: block.timestamp,\n            nextListingId: 0,\n            prevListingId: 0,\n            slippageBps: _slippageBps,\n            fundsReceiver: _fundsReceiver\n        });\n\n        listings[listingId] = newListing;\n\n        // Insert the listing into the correct position based on price\n        _insertListingInOrder(_releaseId, listingId, _pricePerItem);\n\n        listedQuantitiesMap[_releaseId] += newListing.quantity;\n        sellerListings[_seller].push(listingId);\n        tokenListings[_releaseId].push(listingId);\n\n        emit Listed(listingId, _releaseId, _seller, _pricePerItem, _quantity);\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function handleModifyListing(\n        uint256 _listingId,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external override onlyGildiExchange {\n        Listing storage listing = listings[_listingId];\n\n        if (listing.id != _listingId) {\n            revert SharedErrors.ListingError(_listingId);\n        }\n\n        if (_quantity == 0) {\n            handleRemoveListing(_listingId);\n            return;\n        }\n\n        uint256 oldQuantity = listing.quantity;\n        uint256 newQuantity = _quantity;\n\n        if (newQuantity < oldQuantity) {\n            uint256 difference = oldQuantity - newQuantity;\n            gildiManager.unlockTokens(listing.seller, listing.releaseId, difference);\n            listedQuantitiesMap[listing.releaseId] -= difference;\n        } else if (newQuantity > oldQuantity) {\n            uint256 difference = newQuantity - oldQuantity;\n\n            gildiManager.lockTokens(listing.seller, listing.releaseId, difference);\n            listedQuantitiesMap[listing.releaseId] += difference;\n        }\n\n        // Remove the listing from the linked list\n        _clearListingFromLinkedList(_listingId);\n\n        // Update the listing with new price and quantity\n        listing.pricePerItem = _pricePerItem;\n        listing.quantity = newQuantity;\n        listing.modifiedAt = block.timestamp;\n        listing.slippageBps = _slippageBps;\n        listing.payoutCurrency = _payoutCurrency;\n        listing.fundsReceiver = _fundsReceiver;\n\n        // Re-insert into the correct position based on new price\n        _insertListingInOrder(listing.releaseId, listing.id, listing.pricePerItem);\n\n        emit Modified(_listingId, listing.releaseId, listing.seller, _pricePerItem, _quantity);\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function handleRemoveListing(uint256 _listingId) public override onlyGildiExchange {\n        Listing memory listing = listings[_listingId];\n        if (listing.id != _listingId) {\n            revert SharedErrors.ListingError(_listingId);\n        }\n\n        if (listing.quantity > 0) {\n            gildiManager.unlockTokens(listing.seller, listing.releaseId, listing.quantity);\n        }\n\n        _clearListingFromLinkedList(_listingId);\n\n        uint256[] storage sellerArray = sellerListings[listing.seller];\n        for (uint256 i = 0; i < sellerArray.length; i++) {\n            if (sellerArray[i] == _listingId) {\n                sellerArray[i] = sellerArray[sellerArray.length - 1];\n                sellerArray.pop();\n                break;\n            }\n        }\n\n        listedQuantitiesMap[listing.releaseId] -= listing.quantity;\n\n        uint256[] storage listingArray = tokenListings[listing.releaseId];\n        for (uint256 i = 0; i < listingArray.length; i++) {\n            if (listingArray[i] == _listingId) {\n                listingArray[i] = listingArray[listingArray.length - 1];\n                listingArray.pop();\n                break;\n            }\n        }\n\n        emit Unlisted(listing.id, listing.releaseId, listing.seller, listing.quantity);\n\n        delete listings[_listingId];\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function handleDecreaseListingQuantity(\n        uint256 _listingId,\n        uint256 _quantityToBuy\n    ) external override onlyGildiExchange {\n        Listing storage listing = listings[_listingId];\n\n        if (listing.id != _listingId) {\n            revert SharedErrors.ListingError(_listingId);\n        }\n\n        if (_quantityToBuy > listing.quantity) {\n            revert SharedErrors.ParamError();\n        }\n\n        listing.quantity -= _quantityToBuy;\n        listedQuantitiesMap[listing.releaseId] -= _quantityToBuy;\n        listing.modifiedAt = block.timestamp;\n\n        if (listing.quantity == 0) {\n            handleRemoveListing(_listingId);\n        }\n    }\n\n    /// @inheritdoc IGildiExchangeOrderBook\n    function handleUnlistReleaseListings(\n        uint256 _releaseId,\n        uint256 _batchSize\n    ) external override onlyGildiExchange returns (uint256 processedListings) {\n        uint256[] storage listingIds = tokenListings[_releaseId];\n        while (processedListings < _batchSize && listingIds.length > 0) {\n            // Process from the end of listings to avoid shifting elements\n            uint256 listingId = listingIds[listingIds.length - 1];\n            handleRemoveListing(listingId); // This will also emit the event and handle book-keeping\n            processedListings++;\n        }\n\n        return (processedListings);\n    }\n\n    // ========== Internal Functions ==========\n\n    /// @dev Clear a listing from the linked list\n    /// @param _listingId The ID of the listing to clear\n    function _clearListingFromLinkedList(uint256 _listingId) internal {\n        Listing storage listing = listings[_listingId];\n\n        // If the listing is the head\n        if (headListingIds[listing.releaseId] == _listingId) {\n            headListingIds[listing.releaseId] = listing.nextListingId;\n        }\n\n        // If the listing is the tail\n        if (tailListingIds[listing.releaseId] == _listingId) {\n            tailListingIds[listing.releaseId] = listing.prevListingId;\n        }\n\n        // Update neighbors\n        if (listing.prevListingId != 0) {\n            listings[listing.prevListingId].nextListingId = listing.nextListingId;\n        }\n\n        if (listing.nextListingId != 0) {\n            listings[listing.nextListingId].prevListingId = listing.prevListingId;\n        }\n\n        listing.nextListingId = 0;\n        listing.prevListingId = 0;\n    }\n\n    /// @dev Insert a listing into the correct position in the linked list based on price\n    /// @param _releaseId The ID of the release\n    /// @param _listingId The ID of the listing\n    /// @param _pricePerItem The price per item\n    function _insertListingInOrder(uint256 _releaseId, uint256 _listingId, uint256 _pricePerItem) internal {\n        if (headListingIds[_releaseId] == 0) {\n            headListingIds[_releaseId] = _listingId;\n            tailListingIds[_releaseId] = _listingId;\n            return;\n        }\n\n        if (_pricePerItem < listings[headListingIds[_releaseId]].pricePerItem) {\n            listings[_listingId].nextListingId = headListingIds[_releaseId];\n            listings[headListingIds[_releaseId]].prevListingId = _listingId;\n            headListingIds[_releaseId] = _listingId;\n        } else if (_pricePerItem >= listings[tailListingIds[_releaseId]].pricePerItem) {\n            listings[_listingId].prevListingId = tailListingIds[_releaseId];\n            listings[tailListingIds[_releaseId]].nextListingId = _listingId;\n            tailListingIds[_releaseId] = _listingId;\n        } else {\n            uint256 current = headListingIds[_releaseId];\n            while (current != 0) {\n                if (listings[current].pricePerItem > _pricePerItem) {\n                    listings[_listingId].nextListingId = current;\n                    listings[_listingId].prevListingId = listings[current].prevListingId;\n                    listings[listings[current].prevListingId].nextListingId = _listingId;\n                    listings[current].prevListingId = _listingId;\n                    break;\n                }\n                current = listings[current].nextListingId;\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------------\n    // Fallback functions\n    // ---------------------------------------------------------------------------\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    fallback() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    receive() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangePaymentAggregator.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport './GildiExchangePaymentBaseUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title GildiExchangePaymentAggregator\n/// @notice A generic payment adapter that aggregates multiple DEX/aggregator adapters.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiExchangePaymentAggregator is GildiExchangePaymentBaseUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the aggregator with the exchange, marketplace token, and wrapped native token.\n    /// @param _gildiExchange The address of the Gildi Exchange.\n    /// @param _wNativeAddress The address of the wrapped native token.\n    /// @param _initialDefaultAdmin The address of the initial default admin.\n    /// @param _initialContractAdmin The address of the initial contract admin.\n    function initialize(\n        address _gildiExchange,\n        address _wNativeAddress,\n        address _initialDefaultAdmin,\n        address _initialContractAdmin\n    ) public initializer {\n        __GildiExchangePaymentBase_init(_gildiExchange, _initialDefaultAdmin, _initialContractAdmin);\n        _setPurchaseAllowNative(true);\n        _setWrappedNative(_wNativeAddress);\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangePaymentBase.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../../interfaces/external/IWNative.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchangePaymentAggregator.sol';\nimport './GildiExchangePaymentBaseCore.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\n/// @title GildiExchangePaymentBase\n/// @notice Abstract base contract (non-upgradeable) implementing the payment flow for the marketplace.\n/// @dev Inherits from Ownable and ReentrancyGuard.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\nabstract contract GildiExchangePaymentBase is GildiExchangePaymentBaseCore, Context, AccessControl, ReentrancyGuard {\n    // Regular storage variable for holding state.\n    GildiExchangePaymentBaseStorage private $;\n\n    /// @notice Constructor initializing the Gildi Exchange and Marketplace Token.\n    /// @param _gildiExchange The address of the Gildi Exchange.\n    /// @param _initialDefaultAdmin The address of the initial default admin.\n    /// @param _initialContractAdmin The address of the initial contract admin.\n    constructor(address _gildiExchange, address _initialDefaultAdmin, address _initialContractAdmin) {\n        $.gildiExchange = IGildiExchange(_gildiExchange);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialDefaultAdmin);\n        _grantRole(ADMIN_ROLE, _initialContractAdmin);\n    }\n\n    //----- Admin Functions -----\n\n    /// @notice Sets whether native payments are allowed for purchases.\n    /// @param _allow True if native payments should be enabled.\n    function setPurchaseAllowNative(bool _allow) public onlyRole(ADMIN_ROLE) {\n        super._setPurchaseAllowNative(_allow);\n    }\n\n    /// @notice Sets the allowed purchase status for a given source token.\n    /// @param _token The address of the token.\n    /// @param _allowed True to allow the token.\n    function setAllowedPurchaseToken(address _token, bool _allowed) external onlyRole(ADMIN_ROLE) {\n        super._setAllowedPurchaseToken(_token, _allowed);\n    }\n\n    /// @notice Adds a new aggregator/DEX adapter.\n    /// @param _adapter The adapter to add.\n    function addAdapter(IGildiExchangeSwapAdapter _adapter) external onlyRole(ADMIN_ROLE) {\n        super._addAdapter(_adapter);\n    }\n\n    /// @notice Removes an adapter by instance.\n    /// @param adapter The adapter instance to remove.\n    function removeAdapter(IGildiExchangeSwapAdapter adapter) external onlyRole(ADMIN_ROLE) {\n        super._removeAdapter(adapter);\n    }\n\n    /// @notice Sets the wrapped native token address.\n    /// @param _wnative The address of the wrapped native token.\n    function setWrappedNative(address _wnative) external onlyRole(ADMIN_ROLE) {\n        super._setWrappedNative(_wnative);\n    }\n\n    /// @notice Removes an adapter by its index.\n    /// @param index The index of the adapter to remove.\n    function removeAdapter(uint256 index) external onlyRole(ADMIN_ROLE) {\n        super._removeAdapter(index);\n    }\n\n    //----- Internal Storage Getter -----\n\n    /// @dev Returns the storage pointer for this contract.\n    function _getStorage() internal view override returns (GildiExchangePaymentBaseStorage storage) {\n        return $;\n    }\n\n    function _msgSender() internal view override(GildiExchangePaymentBaseCore, Context) returns (address sender) {\n        return super._msgSender();\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangePaymentBaseCore.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../../interfaces/external/IWNative.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchangePaymentAggregator.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchangeSwapAdapter.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\n/// @title GildiExchangePaymentBaseCore\n/// @notice Core contract holding shared logic and storage definitions for the purchase flow.\n/// This contract is completely agnostic to access control and reentrancy protection;\n/// it just provides internal helper functions and defines a storage struct along with internal getters.\n/// Derived contracts must implement _getStorage().\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\nabstract contract GildiExchangePaymentBaseCore is IGildiExchangePaymentAggregator {\n    using SafeERC20 for IERC20;\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    // --- Storage Struct (shared by both implementations) ---\n    /// @dev Storage struct for the Gildi Marketplace.\n    /// @param gildiExchange The Gildi Exchange contract.\n    /// @param marketplaceToken DEPRECATED: The marketplace token address. Use gildiExchange.getActiveMarketplaceReleaseAsset() instead.\n    /// @param allowNative If native payments are allowed.\n    /// @param wrappedNative The wrapped native token address.\n    /// @param adapters The list of aggregator/DEX adapters.\n    /// @param allowedPurchaseTokens The allowed purchase tokens.\n    /// @param isPurchaseTokenAllowed Mapping of allowed purchase tokens.\n    struct GildiExchangePaymentBaseStorage {\n        IGildiExchange gildiExchange;\n        bool purchaseAllowNative;\n        address wrappedNative;\n        IGildiExchangeSwapAdapter[] adapters;\n        address[] allowedPurchaseTokens;\n        mapping(address => bool) isPurchaseTokenAllowed;\n    }\n\n    /// @dev Emitted when an index is out of bounds.\n    error IndexOutOfRange();\n\n    /// @dev Emitted when there are not enough source tokens for the best route.\n    error NotEnoughSourceTokensForBestRoute();\n\n    /// @dev Emitted when slippage exceeds the limit.\n    error SlippageExceeded();\n\n    /// @dev Emitted when a token is not allowed for purchase.\n    /// @param token The token that is not allowed.\n    error PurchaseTokenNotAllowed(address token);\n\n    /// @dev Emitted when native currency is not allowed for purchase.\n    error NativeNotAllowed();\n\n    /// @dev Emitted when the msg.value does not match the expected amount.\n    error IncorrectMsgValue();\n\n    /// @dev Emitted when there are no swap adapters configured.\n    error NoAdapters();\n\n    /// @dev Emitted when no valid route is found for a swap.\n    error NoValidRoute();\n\n    /// @dev Emitted when there is insufficient liquidity for a swap.\n    error InsufficientLiquidity();\n\n    /// @dev Emitted when the received amount is less than the required minimum.\n    error InsufficientReceiveAmount();\n\n    /// @dev Emitted when a swap operation fails.\n    error SwapOutFailed();\n\n    /// @notice Emitted when a new swap adapter is added.\n    /// @param adapter The adapter that was added.\n    event AdapterAdded(IGildiExchangeSwapAdapter adapter);\n\n    /// @notice Emitted when a swap adapter is removed.\n    /// @param adapter The adapter that was removed.\n    event AdapterRemoved(IGildiExchangeSwapAdapter adapter);\n\n    /// @notice Emitted when a token's swap-in status is changed.\n    /// @param token The token address.\n    /// @param allowed Whether the token is allowed for swap-in.\n    event AllowedSwapInTokenSet(address token, bool allowed);\n\n    /// @notice Emitted when the wrapped native token address is set.\n    /// @param wnative The wrapped native token address.\n    event WrappedNativeSet(address wnative);\n\n    /// @notice Emitted when the native payment allowance is changed.\n    /// @param allow Whether native payments are allowed.\n    event PurchaseAllowNativeSet(bool allow);\n\n    /// @notice Emitted when a token's source status is changed.\n    /// @param token The token address.\n    /// @param allowed Whether the token is allowed as a source.\n    event SourceTokenSet(address token, bool allowed);\n\n    /// @notice Emitted when a marketplace token leftover is returned.\n    event MarketplaceLeftoverReturned(\n        address indexed marketplaceToken,\n        address recipient,\n        uint256 sourceAmount,\n        bool swapped,\n        address targetToken,\n        uint256 targetAmount\n    );\n\n    /// @notice Emitted when a swap operation is executed.\n    /// @param sourceToken The address of the source token.\n    /// @param targetToken The address of the target token.\n    /// @param sourceAmount The amount of source tokens swapped.\n    /// @param targetAmount The amount of target tokens received.\n    /// @param recipient The address that received the target tokens.\n    /// @param adapter The adapter used for the swap.\n    /// @param route The detailed routing information used for the swap.\n    event SwapExecuted(\n        address indexed sourceToken,\n        address indexed targetToken,\n        uint256 sourceAmount,\n        uint256 targetAmount,\n        address recipient,\n        address adapter,\n        IGildiExchangeSwapAdapter.QuoteRoute route\n    );\n\n    /// @notice Emitted when a swap route is selected for a transaction.\n    /// @param sourceToken The starting token for the swap.\n    /// @param targetToken The desired output token.\n    /// @param amount The amount to be swapped.\n    /// @param expectedOutput The expected output amount.\n    /// @param selectedAdapter The address of the selected adapter for the route.\n    event SwapRouteSelected(\n        address indexed sourceToken,\n        address indexed targetToken,\n        uint256 amount,\n        uint256 expectedOutput,\n        address selectedAdapter\n    );\n\n    /// @notice The best adapter quote for a swap out\n    /// @param bestAdapter The best adapter\n    /// @param bestTargetAmount The best target amount\n    /// @param bestQuoteData The best quote data\n    /// @param bestQuoteRoute The best quote route\n    /// @param hasValidRoute Whether there is any valid route.\n    struct BestAdapterSwapOutQuote {\n        address bestAdapter;\n        uint256 bestTargetAmount;\n        bytes bestQuoteData;\n        IGildiExchangeSwapAdapter.QuoteRoute bestQuoteRoute;\n        bool hasValidRoute;\n    }\n\n    // --- Abstract function: must return the storage pointer ---\n    function _getStorage() internal view virtual returns (GildiExchangePaymentBaseStorage storage);\n\n    /// @dev Returns the message sender.\n    /// @return The address of the message sender.\n    function _msgSender() internal view virtual returns (address);\n\n    // --- Internal Setters ---\n    function _setPurchaseAllowNative(bool _allow) internal virtual {\n        if (_allow == getPurchaseAllowNative()) {\n            return;\n        }\n\n        _getStorage().purchaseAllowNative = _allow;\n        emit PurchaseAllowNativeSet(_allow);\n    }\n\n    function _setAllowedPurchaseToken(address _token, bool _allowed) internal virtual {\n        GildiExchangePaymentBaseStorage storage $ = _getStorage();\n        if (_allowed) {\n            if (!$.isPurchaseTokenAllowed[_token]) {\n                $.allowedPurchaseTokens.push(_token);\n                $.isPurchaseTokenAllowed[_token] = true;\n            }\n        } else {\n            if ($.isPurchaseTokenAllowed[_token]) {\n                delete $.isPurchaseTokenAllowed[_token];\n                uint256 len = $.allowedPurchaseTokens.length;\n                for (uint256 i = 0; i < len; i++) {\n                    if (_token == $.allowedPurchaseTokens[i]) {\n                        $.allowedPurchaseTokens[i] = $.allowedPurchaseTokens[len - 1];\n                        $.allowedPurchaseTokens.pop();\n                        break;\n                    }\n                }\n            }\n        }\n        emit AllowedSwapInTokenSet(_token, _allowed);\n    }\n\n    function _addAdapter(IGildiExchangeSwapAdapter _adapter) internal virtual {\n        for (uint256 i = 0; i < getAdapters().length; i++) {\n            if (address(_adapter) == address(getAdapters()[i])) {\n                return;\n            }\n        }\n\n        GildiExchangePaymentBaseStorage storage $ = _getStorage();\n        $.adapters.push(_adapter);\n        emit AdapterAdded(_adapter);\n    }\n\n    function _setWrappedNative(address _wnative) internal virtual {\n        if (_wnative == getWrappedNative()) {\n            return;\n        }\n\n        _getStorage().wrappedNative = _wnative;\n        emit WrappedNativeSet(_wnative);\n    }\n\n    function _removeAdapter(uint256 index) internal virtual {\n        GildiExchangePaymentBaseStorage storage $ = _getStorage();\n        IGildiExchangeSwapAdapter[] storage adapters = $.adapters;\n        if (index >= adapters.length) {\n            revert IndexOutOfRange();\n        }\n        emit AdapterRemoved(adapters[index]);\n        adapters[index] = adapters[adapters.length - 1];\n        adapters.pop();\n    }\n\n    function _removeAdapter(IGildiExchangeSwapAdapter _adapter) internal virtual {\n        GildiExchangePaymentBaseStorage storage $ = _getStorage();\n        uint256 len = $.adapters.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (address(_adapter) == address($.adapters[i])) {\n                emit AdapterRemoved(_adapter);\n                if (i != len - 1) {\n                    $.adapters[i] = $.adapters[len - 1];\n                }\n                $.adapters.pop();\n                break;\n            }\n        }\n    }\n\n    // --- Internal Logic ---\n    function _approveMarketplaceIfNeeded(address _marketplaceToken, uint256 _requiredAmount) internal {\n        uint256 allowanceNow = IERC20(_marketplaceToken).allowance(address(this), address(getGildiExchange()));\n        if (allowanceNow < _requiredAmount) {\n            IERC20(_marketplaceToken).forceApprove(address(getGildiExchange()), type(uint256).max);\n        }\n    }\n\n    function _collectPurchaseToken(address _sourceToken, uint256 _sourceMaxAmount) internal {\n        if (!isPurchaseTokenAllowed(_sourceToken)) {\n            revert PurchaseTokenNotAllowed(_sourceToken);\n        }\n        IERC20(_sourceToken).safeTransferFrom(msg.sender, address(this), _sourceMaxAmount);\n    }\n\n    function _approveFundsToAdapter(address _adapter, address _sourceToken, uint256 _amount) internal {\n        IERC20(_sourceToken).forceApprove(_adapter, _amount);\n    }\n\n    /// @notice Executes a swap out operation, converting source tokens to a target token\n    /// @param _amount The amount of source tokens to swap\n    /// @param _sourceCurrency The source currency to swap from\n    /// @param _targetToken The token to swap to\n    /// @param _minTargetAmount The minimum amount of target tokens to receive\n    /// @param _recipient The recipient of the target tokens\n    /// @return targetReceived The amount of target tokens received\n    function _executeSwapOut(\n        uint256 _amount,\n        address _sourceCurrency,\n        address _targetToken,\n        uint256 _minTargetAmount,\n        address _recipient\n    ) internal returns (uint256 targetReceived) {\n        // No swap needed if the target token is the source token\n        if (_targetToken == _sourceCurrency) {\n            IERC20(_sourceCurrency).safeTransfer(_recipient, _amount);\n            return _amount;\n        }\n\n        // Find the best adapter for the swap\n        BestAdapterSwapOutQuote memory quote = _swapOutQuoteAndPickAdapter(_amount, _targetToken, _sourceCurrency);\n\n        if (!quote.hasValidRoute) {\n            revert NoValidRoute();\n        }\n\n        if (quote.bestTargetAmount == 0) {\n            revert InsufficientLiquidity();\n        }\n\n        if (quote.bestTargetAmount < _minTargetAmount) {\n            revert InsufficientReceiveAmount();\n        }\n\n        _approveFundsToAdapter(quote.bestAdapter, _sourceCurrency, _amount);\n\n        // Emit event for selected route before execution\n        emit SwapRouteSelected(_sourceCurrency, _targetToken, _amount, quote.bestTargetAmount, quote.bestAdapter);\n\n        // Execute the swap\n        targetReceived = IGildiExchangeSwapAdapter(quote.bestAdapter).swapOut(\n            _sourceCurrency,\n            _targetToken,\n            _amount,\n            _minTargetAmount,\n            _recipient,\n            quote.bestQuoteData\n        );\n\n        if (targetReceived < _minTargetAmount) {\n            revert SwapOutFailed();\n        }\n\n        // Emit event for successful swap execution\n        emit SwapExecuted(\n            _sourceCurrency,\n            _targetToken,\n            _amount,\n            targetReceived,\n            _recipient,\n            quote.bestAdapter,\n            quote.bestQuoteRoute\n        );\n\n        return targetReceived;\n    }\n\n    function _returnLeftoverPurchaseSource(address _sourceToken, uint256 _amount, bool _isNative) internal {\n        if (_isNative) {\n            _unwrapNative(_amount);\n            Address.sendValue(payable(msg.sender), _amount);\n        } else {\n            IERC20(_sourceToken).safeTransfer(msg.sender, _amount);\n        }\n    }\n\n    function _collectAndWrapNative(uint256 _sourceMaxAmount) internal {\n        if (!getPurchaseAllowNative() || getWrappedNative() == address(0)) {\n            revert NativeNotAllowed();\n        }\n        if (msg.value != _sourceMaxAmount) {\n            revert IncorrectMsgValue();\n        }\n        IWNative(getWrappedNative()).deposit{value: _sourceMaxAmount}();\n    }\n\n    function _unwrapNative(uint256 _amount) internal {\n        IWNative(getWrappedNative()).withdraw(_amount);\n    }\n\n    /// @dev Must pick the best aggregator adapter among available ones.\n    ///      Can be overriden to implement custom logic.\n    /// @param _sourceToken The token to swap from.\n    /// @param _marketplaceAmount The amount of marketplace tokens needed.\n    /// @return bestAdapter The chosen adapter.\n    /// @return sourceNeeded The amount of _sourceToken required.\n    /// @return quoteData The data to pass to bestAdapter.swapIn(...).\n    function _swapInQuoteAndPickAdapter(\n        address _sourceToken,\n        uint256 _marketplaceAmount,\n        uint256 _releaseId\n    )\n        internal\n        view\n        virtual\n        returns (\n            IGildiExchangeSwapAdapter bestAdapter,\n            uint256 sourceNeeded,\n            bytes memory quoteData,\n            IGildiExchangeSwapAdapter.QuoteRoute memory quoteRoute\n        )\n    {\n        IGildiExchangeSwapAdapter[] memory adapters = getAdapters();\n        address marketplaceToken = getMarketplaceToken(_releaseId);\n\n        if (adapters.length == 0) {\n            revert NoAdapters();\n        }\n\n        uint256 bestNeeded = type(uint256).max;\n        bytes memory bestData;\n        IGildiExchangeSwapAdapter.QuoteRoute memory bestQuoteRoute;\n        bool anyValidRouteExists = false;\n        bool insufficientLiquidity = false;\n\n        for (uint256 i = 0; i < adapters.length; i++) {\n            IGildiExchangeSwapAdapter.SwapInQuote memory quote = adapters[i].quoteSwapIn(\n                _sourceToken,\n                marketplaceToken,\n                _marketplaceAmount\n            );\n\n            if (quote.validRoute) {\n                anyValidRouteExists = true;\n\n                if (quote.sourceTokenRequired == 0) {\n                    // Valid route exists but has insufficient liquidity\n                    insufficientLiquidity = true;\n                } else if (quote.sourceTokenRequired < bestNeeded) {\n                    // Found a better route with sufficient liquidity\n                    bestNeeded = quote.sourceTokenRequired;\n                    bestAdapter = adapters[i];\n                    bestData = quote.rawQuoteData;\n                    bestQuoteRoute = quote.quoteRoute;\n                }\n            }\n        }\n\n        if (address(bestAdapter) == address(0)) {\n            // No adapter found with sufficient liquidity\n            if (anyValidRouteExists && insufficientLiquidity) {\n                // Valid routes exist but all have insufficient liquidity\n                revert InsufficientLiquidity();\n            } else {\n                // No valid route exists between these tokens\n                revert NoValidRoute();\n            }\n        }\n        return (bestAdapter, bestNeeded, bestData, bestQuoteRoute);\n    }\n\n    /// @dev Estimates the amount of `_sourceToken` required to get `_amount` of `_targetToken` and returns the current best route.\n    /// @param _amount The amount of the target token.\n    /// @param _targetToken The target token.\n    /// @param _sourceToken The source token.\n    /// @return quote The quote.\n    function _swapOutQuoteAndPickAdapter(\n        uint256 _amount,\n        address _targetToken,\n        address _sourceToken\n    ) internal view virtual returns (BestAdapterSwapOutQuote memory quote) {\n        IGildiExchangeSwapAdapter[] memory adapters = getAdapters();\n\n        quote.bestTargetAmount = 0;\n\n        /* uint256 targetTokenOut;\n        bytes rawQuoteData;\n        QuoteRoute quoteRoute;\n        bool validRoute;*/\n        for (uint256 i = 0; i < adapters.length; i++) {\n            try adapters[i].quoteSwapOut(_sourceToken, _targetToken, _amount) returns (\n                IGildiExchangeSwapAdapter.SwapOutQuote memory swapOutQuote\n            ) {\n                if (swapOutQuote.validRoute) {\n                    if (swapOutQuote.targetTokenOut > quote.bestTargetAmount || !quote.hasValidRoute) {\n                        // Better route found with non-zero output\n                        quote.bestTargetAmount = swapOutQuote.targetTokenOut;\n                        quote.bestAdapter = address(adapters[i]);\n                        quote.bestQuoteData = swapOutQuote.rawQuoteData;\n                        quote.bestQuoteRoute = swapOutQuote.quoteRoute;\n                        quote.hasValidRoute = true;\n                    }\n                }\n            } catch {\n                // Skip this adapter if it reverts\n                continue;\n            }\n        }\n    }\n\n    /// @dev Attempts to refund leftover marketplace tokens by swapping them back to the original source token\n    /// @dev Falls back to direct transfer of marketplace token if the swap fails\n    /// @param _sourceToken The marketplace token address\n    /// @param _amount The amount of marketplace tokens to refund\n    /// @param _targetToken The destination token (original source token)\n    /// @param _recipient The recipient address who will receive the tokens\n    function _refundReleaseMarketplaceToken(\n        address _sourceToken,\n        uint256 _amount,\n        address _targetToken,\n        address _recipient\n    ) internal {\n        IERC20 sourceToken = IERC20(_sourceToken);\n\n        if (_targetToken == _sourceToken) {\n            sourceToken.safeTransfer(_recipient, _amount);\n            return;\n        }\n\n        // Try swap out\n        BestAdapterSwapOutQuote memory quote = _swapOutQuoteAndPickAdapter(_amount, _targetToken, _sourceToken);\n\n        bool swapExecuted = false;\n\n        if (quote.hasValidRoute && quote.bestTargetAmount > 0) {\n            // Emit event for selected route before execution\n            emit SwapRouteSelected(_sourceToken, _targetToken, _amount, quote.bestTargetAmount, quote.bestAdapter);\n\n            _approveFundsToAdapter(quote.bestAdapter, _sourceToken, _amount);\n            try\n                IGildiExchangeSwapAdapter(quote.bestAdapter).swapOut(\n                    _sourceToken,\n                    _targetToken,\n                    _amount,\n                    0,\n                    _recipient,\n                    quote.bestQuoteData\n                )\n            returns (uint256 targetReceived) {\n                if (targetReceived > 0) {\n                    // Emit events for successful swap\n                    emit SwapExecuted(\n                        _sourceToken,\n                        _targetToken,\n                        _amount,\n                        targetReceived,\n                        _recipient,\n                        quote.bestAdapter,\n                        quote.bestQuoteRoute\n                    );\n                    swapExecuted = true;\n                }\n            } catch {\n                _approveFundsToAdapter(quote.bestAdapter, _sourceToken, 0);\n            }\n        }\n\n        if (!swapExecuted) {\n            sourceToken.safeTransfer(_recipient, _amount);\n            emit MarketplaceLeftoverReturned(_sourceToken, _recipient, _amount, false, address(0), 0);\n        }\n    }\n\n    // --- Public Functions ---\n\n    // --- Getters ---\n    function getGildiExchange() public view returns (IGildiExchange) {\n        return _getStorage().gildiExchange;\n    }\n\n    /// @notice Returns the active marketplace token address for a given release or the default marketplace token.\n    /// @param _releaseId Optional release ID to get the specific token for, or 0 for default\n    /// @return The marketplace token address to use for the specified release\n    function getMarketplaceToken(uint256 _releaseId) public view returns (address) {\n        IGildiExchange exchange = getGildiExchange();\n        return exchange.getActiveMarketplaceReleaseAsset(_releaseId);\n    }\n\n    function getPurchaseAllowNative() public view returns (bool) {\n        return _getStorage().purchaseAllowNative;\n    }\n\n    function getWrappedNative() public view returns (address) {\n        return _getStorage().wrappedNative;\n    }\n\n    function getAdapters() public view returns (IGildiExchangeSwapAdapter[] memory) {\n        return _getStorage().adapters;\n    }\n\n    function isPurchaseTokenAllowed(address _token) public view returns (bool) {\n        return _getStorage().isPurchaseTokenAllowed[_token];\n    }\n\n    function getAllowedPurchaseTokens() public view returns (address[] memory) {\n        return _getStorage().allowedPurchaseTokens;\n    }\n\n    /// @inheritdoc IGildiExchangePaymentAggregator\n    function swapOut(\n        uint256 _amount,\n        address _sourceCurrency,\n        address _targetToken,\n        uint256 _minTargetAmount,\n        address _recipient\n    ) public virtual returns (uint256 targetReceived) {\n        // First, validate if we have a valid route\n        (bool hasValidRoute, uint256 expectedAmount, ) = previewSwapOut(_amount, _sourceCurrency, _targetToken);\n        if (!hasValidRoute || expectedAmount < _minTargetAmount) {\n            revert NoValidRoute();\n        }\n\n        // Transfer source tokens from the sender to this contract\n        IERC20(_sourceCurrency).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        // Execute the swap out\n        return _executeSwapOut(_amount, _sourceCurrency, _targetToken, _minTargetAmount, _recipient);\n    }\n\n    /// @inheritdoc IGildiExchangePaymentAggregator\n    function purchase(\n        uint256 _releaseId,\n        uint256 _amount,\n        address _sourceToken,\n        uint256 _sourceMaxAmount\n    ) public payable returns (uint256 amountUsdSpent) {\n        // 1) Get required marketplace token amount.\n        (uint256 requiredSourceAmount, address releaseCurrency, ) = getGildiExchange().quotePricePreview(\n            _releaseId,\n            _amount,\n            msg.sender\n        );\n\n        // 2) Collect user’s source tokens.\n        bool isNative = _sourceToken == address(0);\n        if (isNative) {\n            _collectAndWrapNative(_sourceMaxAmount);\n            _sourceToken = getWrappedNative();\n        } else {\n            _collectPurchaseToken(_sourceToken, _sourceMaxAmount);\n        }\n\n        uint256 sourceSpent = 0;\n\n        if (_sourceToken != releaseCurrency) {\n            // 3) Pick the best adapter.\n            (\n                IGildiExchangeSwapAdapter bestAdapter,\n                uint256 sourceNeeded,\n                bytes memory quoteData,\n\n            ) = _swapInQuoteAndPickAdapter(_sourceToken, requiredSourceAmount, _releaseId);\n            if (sourceNeeded > _sourceMaxAmount) {\n                revert NotEnoughSourceTokensForBestRoute();\n            }\n\n            // 4) Transfer funds to the adapter.\n            _approveFundsToAdapter(address(bestAdapter), _sourceToken, _sourceMaxAmount);\n\n            // 5) Execute the swap.\n            sourceSpent = bestAdapter.swapIn(\n                _sourceToken,\n                releaseCurrency,\n                _sourceMaxAmount,\n                requiredSourceAmount,\n                address(this),\n                quoteData\n            );\n            if (sourceSpent > _sourceMaxAmount) {\n                revert SlippageExceeded();\n            }\n        }\n\n        // 6) Approve and call purchase.\n        _approveMarketplaceIfNeeded(releaseCurrency, requiredSourceAmount);\n        (uint256 releaseMarketplaceTokenSpent, uint256 actualUsdSpent) = getGildiExchange().purchase(\n            _releaseId,\n            _amount,\n            requiredSourceAmount,\n            _msgSender(),\n            true\n        );\n        if (_sourceToken == releaseCurrency) {\n            sourceSpent = releaseMarketplaceTokenSpent;\n        }\n\n        // 7) Refund leftover tokens.\n        if (sourceSpent < _sourceMaxAmount) {\n            _returnLeftoverPurchaseSource(_sourceToken, _sourceMaxAmount - sourceSpent, isNative);\n        }\n\n        // 8) Try swap back unspent release marketplace token\n        if (releaseMarketplaceTokenSpent < requiredSourceAmount && _sourceToken != releaseCurrency) {\n            _refundReleaseMarketplaceToken(\n                releaseCurrency,\n                requiredSourceAmount - releaseMarketplaceTokenSpent,\n                _sourceToken,\n                msg.sender\n            );\n        }\n\n        return actualUsdSpent;\n    }\n\n    /// @inheritdoc IGildiExchangePaymentAggregator\n    function estimatePurchase(\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer,\n        address _sourceToken\n    )\n        public\n        view\n        virtual\n        returns (\n            uint256 sourceNeeded,\n            address releaseCurrency,\n            IGildiExchangeSwapAdapter.QuoteRoute memory quoteRoute,\n            uint256 totalPriceUsd\n        )\n    {\n        if (_sourceToken == address(0)) {\n            _sourceToken = getWrappedNative();\n        }\n\n        IGildiExchange gildiExchange = getGildiExchange();\n        (uint256 requiredAmount, address requiredAmountCurrency, uint256 usdPrice) = gildiExchange.quotePricePreview(\n            _releaseId,\n            _amount,\n            _buyer\n        );\n\n        if (_sourceToken == requiredAmountCurrency) {\n            return (\n                requiredAmount,\n                requiredAmountCurrency,\n                IGildiExchangeSwapAdapter.QuoteRoute({\n                    marketplaceAdapter: address(0),\n                    route: new address[](0),\n                    fees: new uint128[](0),\n                    amounts: new uint128[](0),\n                    virtualAmountsWithoutSlippage: new uint128[](0)\n                }),\n                usdPrice\n            );\n        }\n\n        (, sourceNeeded, , quoteRoute) = _swapInQuoteAndPickAdapter(_sourceToken, requiredAmount, _releaseId);\n\n        return (sourceNeeded, requiredAmountCurrency, quoteRoute, usdPrice);\n    }\n\n    /// @notice Previews a swap out operation to check if there's a valid route and estimate the output amount.\n    /// @param _amount The amount of source tokens to swap.\n    /// @param _sourceCurrency The address of the source token.\n    /// @param _targetToken The token to swap to.\n    /// @return hasValidRoute Whether there's a valid route for the swap.\n    /// @return expectedTargetAmount The expected amount of target tokens to receive.\n    /// @return bestRoute The best route for the swap.\n    function previewSwapOut(\n        uint256 _amount,\n        address _sourceCurrency,\n        address _targetToken\n    )\n        public\n        view\n        virtual\n        returns (\n            bool hasValidRoute,\n            uint256 expectedTargetAmount,\n            IGildiExchangeSwapAdapter.QuoteRoute memory bestRoute\n        )\n    {\n        // No swap needed if the target token is the source token\n        if (_targetToken == _sourceCurrency) {\n            return (\n                false,\n                _amount,\n                IGildiExchangeSwapAdapter.QuoteRoute({\n                    marketplaceAdapter: address(0),\n                    route: new address[](0),\n                    fees: new uint128[](0),\n                    amounts: new uint128[](0),\n                    virtualAmountsWithoutSlippage: new uint128[](0)\n                })\n            );\n        }\n\n        // Check for adapters\n        IGildiExchangeSwapAdapter[] memory adapters = getAdapters();\n        if (adapters.length == 0) {\n            return (\n                false,\n                0,\n                IGildiExchangeSwapAdapter.QuoteRoute({\n                    marketplaceAdapter: address(0),\n                    route: new address[](0),\n                    fees: new uint128[](0),\n                    amounts: new uint128[](0),\n                    virtualAmountsWithoutSlippage: new uint128[](0)\n                })\n            );\n        }\n\n        BestAdapterSwapOutQuote memory quote = _swapOutQuoteAndPickAdapter(_amount, _targetToken, _sourceCurrency);\n        expectedTargetAmount = quote.bestTargetAmount;\n        bestRoute = quote.bestQuoteRoute;\n        hasValidRoute = quote.hasValidRoute;\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangePaymentBaseUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../../interfaces/external/IWNative.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport '../../interfaces/marketplace/exchange/IGildiExchangeSwapAdapter.sol';\nimport './GildiExchangePaymentBaseCore.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title GildiExchangePaymentBaseUpgradeable\n/// @notice Abstract upgradeable base contract implementing the payment flow for the marketplace.\n/// @dev Inherits from Initializable, ContextUpgradeable, OwnableUpgradeable, and ReentrancyGuardUpgradeable.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\nabstract contract GildiExchangePaymentBaseUpgradeable is\n    GildiExchangePaymentBaseCore,\n    Initializable,\n    ContextUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    // keccak256(abi.encode(uint256(keccak256(\"gildi.storage.GildiExchangePaymentBase\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GildiExchangePaymentBaseStorageLocation =\n        0x29b67bb007a31b15dbc8250e7a602c4b79c971e992017fd3dae3b054f8ae4e00;\n\n    /// @notice Initializes the upgradeable contract.\n    /// @param _gildiExchange The address of the Gildi Exchange.\n    /// @param _initialDefaultAdmin The address of the initial default admin.\n    /// @param _initialContractAdmin The address of the initial contract admin.\n    function __GildiExchangePaymentBase_init(\n        address _gildiExchange,\n        address _initialDefaultAdmin,\n        address _initialContractAdmin\n    ) internal onlyInitializing {\n        __GildiExchangePaymentBase_init_unchained(_gildiExchange, _initialDefaultAdmin, _initialContractAdmin);\n    }\n\n    /// @notice Performs unchained initialization for the upgradeable contract.\n    /// @param _gildiExchange The address of the Gildi Exchange.\n    /// @param _initialDefaultAdmin The address of the initial default admin.\n    /// @param _initialContractAdmin The address of the initial contract admin.\n    function __GildiExchangePaymentBase_init_unchained(\n        address _gildiExchange,\n        address _initialDefaultAdmin,\n        address _initialContractAdmin\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __AccessControl_init();\n        GildiExchangePaymentBaseStorage storage s = _getGildiExchangePaymentBaseStorage();\n        s.gildiExchange = IGildiExchange(_gildiExchange);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialDefaultAdmin);\n        _grantRole(ADMIN_ROLE, _initialContractAdmin);\n    }\n\n    //----- Admin Functions -----\n\n    /// @notice Sets whether native payments are allowed for purchases.\n    /// @param _allow True if native payments are enabled.\n    function setPurchaseAllowNative(bool _allow) public onlyRole(ADMIN_ROLE) {\n        super._setPurchaseAllowNative(_allow);\n    }\n\n    /// @notice Sets the allowed purchase status for a given source token.\n    /// @param _token The address of the token.\n    /// @param _allowed True to allow the token.\n    function setAllowedPurchaseToken(address _token, bool _allowed) external onlyRole(ADMIN_ROLE) {\n        super._setAllowedPurchaseToken(_token, _allowed);\n    }\n\n    /// @notice Adds a new aggregator/DEX adapter.\n    /// @param _adapter The adapter to add.\n    function addAdapter(IGildiExchangeSwapAdapter _adapter) external onlyRole(ADMIN_ROLE) {\n        super._addAdapter(_adapter);\n    }\n\n    /// @notice Removes an adapter by instance.\n    /// @param adapter The adapter instance to remove.\n    function removeAdapter(IGildiExchangeSwapAdapter adapter) external onlyRole(ADMIN_ROLE) {\n        super._removeAdapter(adapter);\n    }\n\n    /// @notice Sets the wrapped native token address.\n    /// @param _wnative The address of the wrapped native token.\n    function setWrappedNative(address _wnative) external onlyRole(ADMIN_ROLE) {\n        super._setWrappedNative(_wnative);\n    }\n\n    /// @notice Removes an adapter by its index.\n    /// @param index The index of the adapter to remove.\n    function removeAdapter(uint256 index) external onlyRole(ADMIN_ROLE) {\n        super._removeAdapter(index);\n    }\n\n    //----- Internal Storage Getter -----\n\n    /// @dev Returns the storage pointer for unstructured storage.\n    function _getStorage() internal pure override returns (GildiExchangePaymentBaseStorage storage) {\n        return _getGildiExchangePaymentBaseStorage();\n    }\n\n    function _msgSender()\n        internal\n        view\n        override(GildiExchangePaymentBaseCore, ContextUpgradeable)\n        returns (address sender)\n    {\n        return super._msgSender();\n    }\n\n    /// @dev Internal function to retrieve the storage struct from a fixed slot.\n    /// @return $ The storage pointer.\n    function _getGildiExchangePaymentBaseStorage() private pure returns (GildiExchangePaymentBaseStorage storage $) {\n        assembly {\n            $.slot := GildiExchangePaymentBaseStorageLocation\n        }\n    }\n}\n"
        },
        "contracts/marketplace/exchange/GildiExchangePaymentProcessor.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {IGildiExchange} from '../../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport {IGildiExchangePaymentProcessor} from '../../interfaces/marketplace/exchange/IGildiExchangePaymentProcessor.sol';\nimport {IGildiPriceResolver} from '../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport {IGildiExchangePaymentAggregator} from '../../interfaces/marketplace/exchange/IGildiExchangePaymentAggregator.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IERC20Burnable} from '../../interfaces/token/IERC20Burnable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {SharedErrors} from '../../libraries/marketplace/exchange/SharedErrors.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableMap.sol';\n\n/// @title Gildi Exchange Payment Processor\n/// @notice Handles payment processing, fee calculation, and currency conversions for the Gildi Exchange\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiExchangePaymentProcessor is Initializable, IGildiExchangePaymentProcessor {\n    using SafeERC20 for IERC20;\n    using EnumerableMap for EnumerableMap.AddressToBytes32Map;\n\n    // ========== Constants ==========\n    /// @dev Dead address for burning tokens\n    address private constant DEAD_ADDRESS = address(0x000000000000000000000000000000000000dEaD);\n\n    /// @dev Default slippage tolerance in basis points (5%)\n    uint16 private constant DEFAULT_SLIPPAGE_BPS = 500;\n\n    // ========== Storage Variables ==========\n    /// @notice The GildiExchange contract that calls this contract\n    IGildiExchange public gildiExchange;\n\n    /// @dev Mapping from currency address to price feed ID\n    EnumerableMap.AddressToBytes32Map private priceFeedIds;\n\n    // ========== Events ==========\n    /// @notice Emitted when a price feed is set\n    /// @param currency The currency address\n    /// @param feedId The price feed ID\n    event PriceFeedSet(address indexed currency, bytes32 feedId);\n\n    /// @notice Emitted when a price feed is removed\n    /// @param currency The currency address\n    event PriceFeedRemoved(address indexed currency);\n\n    /// @notice Emitted when a payment is processed for a listing purchase or fee transfer\n    /// @param listingId The ID of the listing being purchased\n    /// @param from The address sending the payment\n    /// @param to The address receiving the payment\n    /// @param sourceToken The source token used for payment\n    /// @param amount The amount of source token\n    /// @param payoutToken The token received by the recipient (may differ from sourceToken if swapped)\n    /// @param swapAmount The amount received after swap (if performed)\n    /// @param isFee Whether this payment is a fee transfer\n    /// @param swapRequested Whether a token swap was requested\n    /// @param swapSuccessful Whether the swap was successful (if requested)\n    /// @param slippageBps The slippage tolerance in basis points used for swaps\n    event PaymentProcessed(\n        uint256 indexed listingId,\n        address indexed from,\n        address indexed to,\n        address sourceToken,\n        uint256 amount,\n        address payoutToken,\n        uint256 swapAmount,\n        bool isFee,\n        bool swapRequested,\n        bool swapSuccessful,\n        uint16 slippageBps\n    );\n\n    // ========== Structs ==========\n    struct PriceFeedInfo {\n        address currency;\n        bytes32 feedId;\n    }\n\n    /// @dev Struct for transfer parameters to reduce stack usage\n    struct TransferParams {\n        uint256 listingId;\n        address from;\n        address to;\n        uint256 amount;\n        address amountCurrency;\n        address payoutCurrency;\n        uint16 slippageBps;\n        bool isFee;\n    }\n\n    // ========== Modifiers ==========\n\n    /// @notice Ensures that only the GildiExchange contract can call this function\n    modifier onlyGildiExchange() {\n        if (msg.sender != address(gildiExchange)) {\n            revert SharedErrors.InvalidCaller();\n        }\n        _;\n    }\n\n    /// @notice Ensures that only admins can call this function (checks with GildiExchange)\n    modifier onlyAdmin() {\n        bytes32 adminRole = gildiExchange.getAppEnvironment().adminRole;\n        if (!gildiExchange.hasRole(adminRole, msg.sender)) {\n            revert SharedErrors.InvalidCaller();\n        }\n        _;\n    }\n\n    // ========== Constructor and Initializer ==========\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param _gildiExchange The address of the GildiExchange contract\n    function initialize(address _gildiExchange) external initializer {\n        gildiExchange = IGildiExchange(_gildiExchange);\n    }\n\n    // ========== Price Oracle Functions ==========\n\n    /// @notice Sets a price feed ID for a currency\n    /// @param _currency The currency address\n    /// @param _feedId The price feed ID\n    function setPriceFeedId(address _currency, bytes32 _feedId) external onlyAdmin {\n        (, bytes32 priceFeedId) = priceFeedIds.tryGet(_currency);\n        if (priceFeedId != _feedId) {\n            priceFeedIds.set(_currency, _feedId);\n            emit PriceFeedSet(_currency, _feedId);\n        }\n    }\n\n    /// @notice Removes a price feed for a currency\n    /// @param _currency The currency address\n    function removePriceFeedId(address _currency) external onlyAdmin {\n        if (priceFeedIds.contains(_currency)) {\n            priceFeedIds.remove(_currency);\n            emit PriceFeedRemoved(_currency);\n        }\n    }\n\n    /// @inheritdoc IGildiExchangePaymentProcessor\n    function getPriceFeedId(address _currency) public view returns (bytes32) {\n        (, bytes32 priceFeedId) = priceFeedIds.tryGet(_currency);\n        return priceFeedId;\n    }\n\n    /// @notice Returns all price feeds\n    /// @return priceFeedInfos Array of price feed information\n    function getPriceFeeds() public view returns (PriceFeedInfo[] memory priceFeedInfos) {\n        address[] memory keys = priceFeedIds.keys();\n        priceFeedInfos = new PriceFeedInfo[](keys.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            priceFeedInfos[i] = PriceFeedInfo(keys[i], priceFeedIds.get(keys[i]));\n        }\n    }\n\n    /// @inheritdoc IGildiExchangePaymentProcessor\n    function quoteInCurrency(uint256 _priceInUSD, address _currency) external view returns (uint256) {\n        IGildiExchange.AppEnvironment memory $ = _getAppEnvironment();\n        bytes32 priceFeedId = getPriceFeedId(_currency);\n        uint256 priceAskDecimals = $.settings.priceAskDecimals; // Cache storage read\n\n        IGildiPriceResolver.PriceData memory priceData = $.settings.gildiPriceOracle.getPriceNoOlderThan(\n            priceFeedId,\n            300\n        );\n        uint8 currencyDecimals = IERC20Metadata(_currency).decimals();\n        uint256 quoteScaled;\n\n        // Simplified calculation with ternary operator\n        quoteScaled = priceData.decimals >= priceAskDecimals\n            ? _priceInUSD * 10 ** (priceData.decimals - priceAskDecimals)\n            : _priceInUSD / 10 ** (priceAskDecimals - priceData.decimals);\n\n        return (quoteScaled * 10 ** currencyDecimals) / priceData.price;\n    }\n\n    /// @inheritdoc IGildiExchangePaymentProcessor\n    function handleProcessPaymentWithFees(\n        uint256 _releaseId,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        address _amountCurrency,\n        bool _createFund,\n        address _operator,\n        bool _isProxyOperation,\n        uint256 _listingId,\n        address _listingPayoutCurrency,\n        uint16 _slippageBps\n    ) external onlyGildiExchange {\n        // Skip self-transfers\n        if (_buyer == _seller) return;\n\n        IGildiExchange.AppEnvironment memory $ = _getAppEnvironment();\n\n        // Calculate fees\n        uint256 totalFeeAmount;\n        IGildiExchange.Receiver[] memory feeReceivers;\n        (totalFeeAmount, feeReceivers) = _calculateFees(_releaseId, _value);\n\n        if (_createFund) {\n            // Transfer tokens from operator to fund manager in context\n            gildiExchange.transferTokenInContext(_operator, address($.settings.fundManager), _value, _amountCurrency);\n        }\n\n        // Process fees - either transfer or create funds\n        uint256 receiversLength = feeReceivers.length;\n        for (uint256 i = 0; i < receiversLength; i++) {\n            address receiver = feeReceivers[i].receiverAddress;\n            uint256 feeAmount = feeReceivers[i].value;\n            address payoutCurrency = feeReceivers[i].payoutCurrency;\n\n            if (feeAmount > 0) {\n                if (_createFund) {\n                    // Use helper function to create or add to fund\n                    _addToFund(\n                        _releaseId,\n                        receiver,\n                        _buyer,\n                        _operator,\n                        _isProxyOperation,\n                        feeAmount,\n                        _amountCurrency,\n                        payoutCurrency\n                    );\n                } else {\n                    // Direct transfer for regular sales - use default slippage for fee receivers\n                    _executeTransfer(\n                        TransferParams({\n                            listingId: _listingId,\n                            from: _operator,\n                            to: receiver,\n                            amount: feeAmount,\n                            amountCurrency: _amountCurrency,\n                            payoutCurrency: payoutCurrency,\n                            slippageBps: DEFAULT_SLIPPAGE_BPS,\n                            isFee: true\n                        })\n                    );\n                }\n            }\n        }\n\n        // Handle the remaining amount for the receiver\n        uint256 remainingAmount = _value - totalFeeAmount;\n        if (remainingAmount > 0) {\n            if (_createFund) {\n                // Use helper function to create or add to fund\n                _addToFund(\n                    _releaseId,\n                    _seller,\n                    _buyer,\n                    _operator,\n                    _isProxyOperation,\n                    remainingAmount,\n                    _amountCurrency,\n                    _listingPayoutCurrency\n                );\n            } else {\n                // Direct transfer for regular sales\n                _executeTransfer(\n                    TransferParams({\n                        listingId: _listingId,\n                        from: _operator,\n                        to: _seller,\n                        amount: remainingAmount,\n                        amountCurrency: _amountCurrency,\n                        payoutCurrency: _listingPayoutCurrency,\n                        slippageBps: _slippageBps,\n                        isFee: false\n                    })\n                );\n            }\n        }\n    }\n\n    /// @dev Calculates fees for a purchase based on global and release-specific fee distributions\n    /// @param _releaseId The ID of the release\n    /// @param _amount The amount to calculate fees for\n    /// @return Total fees amount\n    /// @return Array of fee receivers with their respective amounts\n    function _calculateFees(\n        uint256 _releaseId,\n        uint256 _amount\n    ) internal view returns (uint256, IGildiExchange.Receiver[] memory) {\n        IGildiExchange.AppEnvironment memory env = _getAppEnvironment();\n\n        // Get fees for this release\n        IGildiExchange.FeeDistribution[] memory releaseFees = gildiExchange.getReleaseFees(_releaseId);\n        uint256 feeDistCount = releaseFees.length;\n\n        // Count total receivers\n        uint256 totalReceivers = 0;\n        for (uint256 i = 0; i < feeDistCount; i++) {\n            totalReceivers += releaseFees[i].subFeeReceivers.length + 1; // +1 for parent\n        }\n\n        // Initialize result arrays\n        IGildiExchange.Receiver[] memory receivers = new IGildiExchange.Receiver[](totalReceivers);\n        uint256 totalFees = 0;\n        uint256 receiverIndex = 0;\n\n        // Process each fee distribution\n        for (uint256 i = 0; i < feeDistCount; i++) {\n            IGildiExchange.FeeDistribution memory dist = releaseFees[i];\n\n            // Calculate parent fee amount\n            uint256 parentFee = (_amount * dist.feeReceiver.value) / env.basisPoints;\n            uint256 remainingParentFee = parentFee;\n            totalFees += parentFee;\n\n            // Calculate & store sub-receiver fees\n            uint256 subCount = dist.subFeeReceivers.length;\n            uint256 startIndex = receiverIndex + 1; // Skip parent index for now\n\n            for (uint256 j = 0; j < subCount; j++) {\n                uint256 subFee = (parentFee * dist.subFeeReceivers[j].value) / env.basisPoints;\n                receivers[startIndex + j] = IGildiExchange.Receiver({\n                    receiverAddress: dist.subFeeReceivers[j].receiverAddress,\n                    value: uint16(subFee),\n                    payoutCurrency: dist.subFeeReceivers[j].payoutCurrency\n                });\n                remainingParentFee -= subFee;\n            }\n\n            // Store parent data after calculating all sub-fees\n            receivers[receiverIndex] = IGildiExchange.Receiver({\n                receiverAddress: dist.feeReceiver.receiverAddress,\n                value: uint16(remainingParentFee),\n                payoutCurrency: dist.feeReceiver.payoutCurrency\n            });\n\n            // Move index for next distribution\n            receiverIndex += subCount + 1;\n        }\n\n        return (totalFees, receivers);\n    }\n\n    /// @dev Adds funds to fund for a participant\n    ///      Delegates to the fund manager contract\n    /// @param _releaseId The ID of the release\n    /// @param _fundParticipant The address of the fund participant\n    /// @param _buyer The address of the buyer\n    /// @param _operator The address of the operator\n    /// @param _isProxyOperation Whether this is a proxy operation\n    /// @param _amount The amount to add to fund\n    /// @param _amountCurrency The currency of the fund amount\n    /// @param _payoutCurrency The currency to payout in\n    function _addToFund(\n        uint256 _releaseId,\n        address _fundParticipant,\n        address _buyer,\n        address _operator,\n        bool _isProxyOperation,\n        uint256 _amount,\n        address _amountCurrency,\n        address _payoutCurrency\n    ) internal {\n        IGildiExchange.AppEnvironment memory env = _getAppEnvironment();\n\n        // Delegate to the fund manager\n        env.settings.fundManager.handleAddToFund(\n            _releaseId,\n            _fundParticipant,\n            _buyer,\n            _operator,\n            _isProxyOperation,\n            _amount,\n            _amountCurrency,\n            _payoutCurrency\n        );\n    }\n\n    /// @dev Executes a transfer between addresses, potentially with currency conversion\n    /// @param _params Transfer parameters struct containing all transfer details\n    function _executeTransfer(TransferParams memory _params) internal {\n        if (_params.from == address(this)) {\n            revert SharedErrors.ParamError();\n        }\n\n        IGildiExchange.AppEnvironment memory env = _getAppEnvironment();\n        // Try to burn if destination is zero address or dead address\n        if (_params.to == address(0) || _params.to == DEAD_ADDRESS) {\n            // Check if we need to swap before burning (currencies differ and payout currency specified)\n            if (\n                _params.payoutCurrency != address(0) &&\n                _params.amountCurrency != _params.payoutCurrency &&\n                address(env.settings.paymentAggregator) != address(0)\n            ) {\n                // Need to swap first, then burn the swapped amount\n                IERC20 sourceToken = IERC20(_params.amountCurrency);\n                gildiExchange.transferTokenInContext(\n                    _params.from,\n                    address(this),\n                    _params.amount,\n                    _params.amountCurrency\n                );\n\n                // Check if there's a valid swap route\n                (bool hasValidRoute, uint256 expectedAmount, ) = env.settings.paymentAggregator.previewSwapOut(\n                    _params.amount,\n                    _params.amountCurrency,\n                    _params.payoutCurrency\n                );\n\n                if (hasValidRoute && expectedAmount > 0) {\n                    // Approve the payment aggregator to spend the tokens\n                    uint256 allowance = sourceToken.allowance(address(this), address(env.settings.paymentAggregator));\n                    if (allowance < _params.amount) {\n                        sourceToken.forceApprove(address(env.settings.paymentAggregator), type(uint256).max);\n                    }\n\n                    // Calculate minimum amount based on slippage\n                    uint256 minAmount = (expectedAmount * (env.basisPoints - _params.slippageBps)) / env.basisPoints;\n\n                    // Execute swap to this contract, then try to burn the swapped amount\n                    try\n                        env.settings.paymentAggregator.swapOut(\n                            _params.amount,\n                            _params.amountCurrency,\n                            _params.payoutCurrency,\n                            minAmount,\n                            address(this)\n                        )\n                    returns (uint256 swapAmount) {\n                        // Swap successful, now try to burn the swapped amount in payout currency\n                        // First, approve the exchange contract to burn the swapped tokens\n                        IERC20(_params.payoutCurrency).forceApprove(address(gildiExchange), swapAmount);\n\n                        if (gildiExchange.tryBurnTokenInContext(address(this), swapAmount, _params.payoutCurrency)) {\n                            // Burning succeeded, emit event and return\n                            emit PaymentProcessed(\n                                _params.listingId,\n                                _params.from,\n                                address(0), // to: burned tokens go to zero address\n                                _params.amountCurrency, // sourceToken\n                                _params.amount, // amount\n                                _params.payoutCurrency, // payoutToken (swapped currency)\n                                swapAmount, // swapAmount\n                                _params.isFee,\n                                true, // swapRequested\n                                true, // swapSuccessful\n                                _params.slippageBps\n                            );\n                            return;\n                        } else {\n                            // Burning failed, send swapped tokens to dead address\n                            IERC20(_params.payoutCurrency).safeTransfer(DEAD_ADDRESS, swapAmount);\n                            emit PaymentProcessed(\n                                _params.listingId,\n                                _params.from,\n                                DEAD_ADDRESS,\n                                _params.amountCurrency, // sourceToken\n                                _params.amount, // amount\n                                _params.payoutCurrency, // payoutToken (swapped currency)\n                                swapAmount, // swapAmount\n                                _params.isFee,\n                                true, // swapRequested\n                                true, // swapSuccessful\n                                _params.slippageBps\n                            );\n                            return;\n                        }\n                    } catch {\n                        // Swap failed, fall through to original burn logic\n                    }\n                }\n                // If no valid route or swap failed, fall through to original burn logic\n            }\n\n            // Original burn logic: try to burn in original currency\n            if (gildiExchange.tryBurnTokenInContext(_params.from, _params.amount, _params.amountCurrency)) {\n                // Burning succeeded, emit event and return\n                emit PaymentProcessed(\n                    _params.listingId,\n                    _params.from,\n                    address(0), // to: burned tokens go to zero address\n                    _params.amountCurrency, // sourceToken\n                    _params.amount, // amount\n                    _params.amountCurrency, // payoutToken (same as source for direct burns)\n                    _params.amount, // swapAmount (no swap, same amount)\n                    _params.isFee,\n                    false, // swapRequested (no swap for direct burns)\n                    false, // swapSuccessful (no swap for direct burns)\n                    0\n                );\n                return;\n            } else {\n                // Burning failed, redirect to dead address\n                _params.to = DEAD_ADDRESS;\n            }\n        }\n\n        bool swapRequested = false;\n        bool swapSuccessful = false;\n        address finalPayoutCurrency = _params.payoutCurrency;\n        uint256 finalAmount = _params.amount; // Initialize to original amount, will be updated if swap is successful\n\n        // If amount currency and payout currency are the same or payout currency is not specified or destination is DEAD_ADDRESS, do direct transfer\n        if (\n            _params.payoutCurrency == address(0) ||\n            _params.amountCurrency == _params.payoutCurrency ||\n            _params.to == DEAD_ADDRESS ||\n            address(env.settings.paymentAggregator) == address(0)\n        ) {\n            gildiExchange.transferTokenInContext(_params.from, _params.to, _params.amount, _params.amountCurrency);\n            // In this case, the payout currency is the same as the amount currency\n            finalPayoutCurrency = _params.amountCurrency;\n        } else {\n            swapRequested = true;\n\n            // First, get the tokens to this contract if they're not already here\n            IERC20 sourceToken = IERC20(_params.amountCurrency);\n            gildiExchange.transferTokenInContext(_params.from, address(this), _params.amount, _params.amountCurrency);\n\n            // Check if there's a valid swap route\n            (bool hasValidRoute, uint256 expectedAmount, ) = env.settings.paymentAggregator.previewSwapOut(\n                _params.amount,\n                _params.amountCurrency,\n                _params.payoutCurrency\n            );\n\n            if (hasValidRoute && expectedAmount > 0) {\n                // Approve the payment aggregator to spend the tokens\n                uint256 allowance = sourceToken.allowance(address(this), address(env.settings.paymentAggregator));\n                if (allowance < _params.amount) {\n                    sourceToken.forceApprove(address(env.settings.paymentAggregator), type(uint256).max);\n                }\n\n                // Calculate minimum amount based on slippage (10000 - slippageBps) / 10000\n                uint256 minAmount = (expectedAmount * (env.basisPoints - _params.slippageBps)) / env.basisPoints;\n\n                // Execute the swap\n                try\n                    env.settings.paymentAggregator.swapOut(\n                        _params.amount,\n                        _params.amountCurrency,\n                        _params.payoutCurrency,\n                        minAmount,\n                        _params.to\n                    )\n                returns (uint256 swapAmount) {\n                    // Swap successful\n                    swapSuccessful = true;\n                    finalPayoutCurrency = _params.payoutCurrency;\n                    finalAmount = swapAmount;\n                } catch {\n                    // Swap failed, fallback to direct transfer\n                    sourceToken.safeTransfer(_params.to, _params.amount);\n                    finalPayoutCurrency = _params.amountCurrency;\n                }\n            } else {\n                // No valid route, fallback to direct transfer\n                sourceToken.safeTransfer(_params.to, _params.amount);\n                finalPayoutCurrency = _params.amountCurrency;\n            }\n        }\n\n        // Emit payment processed event\n        emit PaymentProcessed(\n            _params.listingId,\n            _params.from,\n            _params.to,\n            _params.amountCurrency,\n            _params.amount,\n            finalPayoutCurrency,\n            finalAmount,\n            _params.isFee,\n            swapRequested,\n            swapSuccessful,\n            _params.slippageBps\n        );\n    }\n\n    /// @dev Gets the application environment from the GildiExchange contract\n    /// @dev Returns the app environment structure containing all settings and roles\n    function _getAppEnvironment() internal view returns (IGildiExchange.AppEnvironment memory) {\n        return gildiExchange.getAppEnvironment();\n    }\n\n    // ---------------------------------------------------------------------------\n    // Fallback functions\n    // ---------------------------------------------------------------------------\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    fallback() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n\n    /// @notice Fallback function to prevent direct Ether transfers\n    receive() external payable {\n        revert SharedErrors.NotAllowed();\n    }\n}\n"
        },
        "contracts/marketplace/vault/GildiExchangePurchaseVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {IGildiPriceOracle} from '../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport {IGildiPriceResolver} from '../../interfaces/oracles/price/IGildiPriceResolver.sol';\nimport {IGildiExchangePurchaseVault} from '../../interfaces/marketplace/vault/IGildiExchangePurchaseVault.sol';\nimport {IGildiExchangePaymentAggregator} from '../../interfaces/marketplace/exchange/IGildiExchangePaymentAggregator.sol';\nimport {IGildiExchangeSwapAdapter} from '../../interfaces/marketplace/exchange/IGildiExchangeSwapAdapter.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {ReentrancyGuardUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\n\n/// @title USD Treasury Purchase Vault\n/// @notice A vault that allows creating USD purchase intents and fulfilling them with crypto tokens\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiExchangePurchaseVault is\n    Initializable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IGildiExchangePurchaseVault\n{\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // -------------------- Constants --------------------\n    bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE'); // create/cancel intents\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE'); // admin\n\n    // -------------------- Types --------------------\n    enum PurchaseStatus {\n        PENDING,\n        FUNDED,\n        SETTLED,\n        EXPIRED,\n        CANCELLED\n    }\n\n    /// @notice Represents a purchase intent within the vault lifecycle.\n    /// @dev Captures all metadata required to validate and settle a purchase.\n    struct PurchaseIntent {\n        /// @dev Unique identifier for the intent\n        bytes32 intentId;\n        /// @dev Address authorized to execute and settle this intent\n        address beneficiary;\n        /// @dev Total authorized value in USD cents (2 decimals)\n        uint256 valueUsd;\n        /// @dev Token used for funding the purchase\n        address debitedToken;\n        /// @dev Amount of token debited to the beneficiary\n        uint256 debitedTokenAmount;\n        /// @dev Token price in USD with 18 decimals at time of debit\n        uint256 debitedTokenPrice;\n        /// @dev Actual USD spent (in cents, 2 decimals)\n        uint256 settledUsd;\n        /// @dev Unix timestamp after which the intent is no longer valid\n        uint256 expiresAt;\n        /// @dev Unix timestamp of intent creation\n        uint256 createdAt;\n        /// @dev Unix timestamp of last update\n        uint256 updatedAt;\n        /// @dev Stored status; EXPIRED is derived in views for pending intents past expiry\n        PurchaseStatus status;\n        /// @dev Block number when executeIntent was called (0 = not executed)\n        uint256 executedAtBlock;\n    }\n\n    /// @notice Represents a token supported by the vault.\n    struct TokenView {\n        /// @dev The token address\n        address token;\n        /// @dev The feed ID for the token\n        bytes32 feedId;\n        /// @dev Whether this token is the default token\n        bool defaultToken;\n    }\n\n    // -------------------- State Variables --------------------\n    /// @notice Price oracle for token valuations\n    IGildiPriceOracle public gildiPriceOracle;\n\n    /// @notice Payment aggregator for purchase routing and estimation\n    IGildiExchangePaymentAggregator public paymentAggregator;\n\n    /// @notice Slippage and fee buffer in basis points (100 = 1%)\n    uint256 public slippageAndFeeBuffer;\n\n    /// @notice Preferred token to use if viable (acts as an override when set)\n    address public preferredToken;\n\n    /// @dev Supported tokens for vault operations\n    EnumerableSet.AddressSet private supportedTokens;\n\n    /// @notice Oracle feed IDs for supported tokens (token => feedId)\n    mapping(address => bytes32) public tokenFeedIds;\n\n    /// @dev Purchase intents storage\n    mapping(bytes32 => PurchaseIntent) private intents;\n\n    // -------------------- Errors --------------------\n    // Intent lifecycle errors\n    /// @dev Thrown when trying to create an intent that already exists\n    error IntentAlreadyExists(bytes32 intentId);\n    /// @dev Thrown when a referenced intent does not exist\n    error IntentDoesNotExist(bytes32 intentId);\n    /// @dev Thrown when an operation is invalid for the current intent state\n    error IntentWrongState(bytes32 intentId);\n    /// @dev Thrown when an operation is attempted on an expired intent\n    error IntentExpired(bytes32 intentId);\n    /// @dev Thrown when msg.sender is not the intent beneficiary\n    error NotBeneficiary(bytes32 intentId);\n    /// @dev Thrown when a debit would exceed remaining USD allowance\n    error UsdOverDebit(bytes32 intentId, uint256 want, uint256 remaining);\n\n    // Token and vault errors\n    /// @dev Thrown when a token is not supported by the vault\n    error TokenNotSupported(address token);\n    /// @dev Thrown when a provided token is not allowed for the operation\n    error NotAllowedToken(address token);\n    /// @dev Thrown when vault balance is insufficient for the transfer\n    error InsufficientVaultBalance(address token, uint256 want, uint256 have);\n    /// @dev Thrown when no viable token can be found to fund a purchase\n    error NoViableTokenFound(uint256 intentValueUsdCents);\n    /// @dev Thrown when oracle feed ID is missing for a token\n    error TokenFeedIdNotSet(address token);\n    /// @dev Thrown when zero address provided where non-zero is required\n    error ZeroAddressToken();\n\n    // Refund errors\n    /// @dev Thrown when attempting a refund before execution\n    error RefundWithoutExecution(bytes32 intentId);\n    /// @dev Thrown when refund is not performed within the same transaction as execution\n    error RefundNotSameTransaction(bytes32 intentId);\n    /// @dev Thrown when provided refund is insufficient to cover required delta\n    error InsufficientRefund(bytes32 intentId);\n    /// @dev Thrown when interacting with fee-on-transfer tokens (unsupported)\n    error FeeOnTransferNotSupported(address token);\n\n    // Configuration and validation errors\n    /// @dev Thrown when price data is considered too old\n    error PriceDataTooOld(uint256 age);\n    /// @dev Thrown when function parameters are invalid\n    error BadParams();\n    /// @dev Thrown when USD credit is below the minimum threshold\n    error UsdCreditTooLow(uint256 credited, uint256 minUsdCredit);\n    /// @dev Thrown when ETH is sent to a non-payable function\n    error EthNotAcceptedHere();\n\n    // -------------------- Events --------------------\n    // Intent lifecycle events\n    /// @notice Emitted when a purchase intent is created\n    event IntentCreated(bytes32 indexed intentId, address indexed beneficiary, uint256 valueUsd, uint256 expiresAt);\n\n    /// @notice Emitted when an intent is executed\n    event IntentExecuted(\n        bytes32 indexed intentId,\n        address indexed token,\n        uint256 tokenSent,\n        uint256 usdDebited,\n        uint256 tokenPrice\n    );\n\n    /// @notice Emitted when intent is settled with actual USD spent\n    event IntentSettled(bytes32 indexed intentId, uint256 actualUsdSpentCents);\n\n    /// @notice Emitted when an intent is cancelled\n    event IntentCancelled(bytes32 indexed intentId, uint8 reasonCode);\n\n    // Vault management events\n    /// @notice Emitted when vault is topped up with tokens\n    event VaultToppedUp(address indexed token, uint256 amount, address indexed from);\n\n    /// @notice Emitted when tokens are withdrawn from vault\n    event VaultWithdrawn(address indexed token, uint256 amount, address indexed to);\n\n    // Configuration events\n    /// @notice Emitted when price oracle is updated\n    event PriceOracleSet(address indexed priceOracle);\n\n    /// @notice Emitted when payment aggregator is updated\n    event PaymentAggregatorSet(address indexed paymentAggregator);\n\n    /// @notice Emitted when slippage and fee buffer is updated\n    event SlippageAndFeeBufferSet(uint256 slippageAndFeeBufferBps);\n\n    /// @notice Emitted when a token is added/removed from supported list\n    event TokenSupportUpdated(address indexed token, bool supported);\n\n    /// @notice Emitted when preferred token is updated (address(0) means cleared)\n    event PreferredTokenSet(address indexed token);\n\n    /// @notice Emitted when a token's oracle feed ID is updated\n    event TokenFeedIdSet(address indexed token, bytes32 feedId);\n\n    // -------------------- Admin --------------------\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the purchase vault\n    /// @param _defaultAdmin Default admin address\n    /// @param _contractAdmin Contract admin address\n    /// @param _operator Operator address\n    /// @param _gildiPriceOracle Price oracle contract address\n    /// @param _paymentAggregator Payment aggregator contract address\n    function initialize(\n        address _defaultAdmin,\n        address _contractAdmin,\n        address _operator,\n        IGildiPriceOracle _gildiPriceOracle,\n        IGildiExchangePaymentAggregator _paymentAggregator\n    ) public initializer {\n        if (\n            _defaultAdmin == address(0) ||\n            _contractAdmin == address(0) ||\n            _operator == address(0) ||\n            address(_gildiPriceOracle) == address(0) ||\n            address(_paymentAggregator) == address(0)\n        ) {\n            revert BadParams();\n        }\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        _grantRole(ADMIN_ROLE, _contractAdmin);\n        _grantRole(OPERATOR_ROLE, _operator);\n\n        gildiPriceOracle = _gildiPriceOracle;\n        paymentAggregator = _paymentAggregator;\n        emit PriceOracleSet(address(_gildiPriceOracle));\n        emit PaymentAggregatorSet(address(_paymentAggregator));\n\n        // Set default slippage buffer to 1% (100 BPS)\n        slippageAndFeeBuffer = 100;\n    }\n\n    function setPriceOracle(IGildiPriceOracle _gildiPriceOracle) external onlyRole(ADMIN_ROLE) {\n        if (address(_gildiPriceOracle) == address(0)) {\n            revert BadParams();\n        }\n        gildiPriceOracle = _gildiPriceOracle;\n        emit PriceOracleSet(address(_gildiPriceOracle));\n    }\n\n    /// @notice Gets the current slippage and fee buffer\n    /// @return bufferBps Current buffer in basis points\n    function getSlippageAndFeeBuffer() external view returns (uint256 bufferBps) {\n        return slippageAndFeeBuffer;\n    }\n\n    /// @notice Sets the slippage and fee buffer\n    /// @param _slippageAndFeeBufferBps New buffer in basis points (100 = 1%)\n    function setSlippageAndFeeBuffer(uint256 _slippageAndFeeBufferBps) external onlyRole(ADMIN_ROLE) {\n        if (_slippageAndFeeBufferBps > 2000) {\n            revert BadParams(); // Max 20%\n        }\n        slippageAndFeeBuffer = _slippageAndFeeBufferBps;\n        emit SlippageAndFeeBufferSet(_slippageAndFeeBufferBps);\n    }\n\n    /// @notice Sets the payment aggregator\n    /// @param _paymentAggregator Payment aggregator contract address\n    function setPaymentAggregator(IGildiExchangePaymentAggregator _paymentAggregator) external onlyRole(ADMIN_ROLE) {\n        if (address(_paymentAggregator) == address(0)) {\n            revert BadParams();\n        }\n        paymentAggregator = _paymentAggregator;\n        emit PaymentAggregatorSet(address(_paymentAggregator));\n    }\n\n    /// @notice Adds a token with oracle feed ID (enables support + sets feed ID)\n    /// @param _token Token address\n    /// @param _feedId Oracle feed ID for the token\n    /// @param _setAsPreferred Whether to set this as the preferred token\n    function addToken(address _token, bytes32 _feedId, bool _setAsPreferred) external onlyRole(ADMIN_ROLE) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        if (_feedId == bytes32(0)) {\n            revert BadParams();\n        }\n\n        if (!supportedTokens.contains(_token)) {\n            supportedTokens.add(_token);\n\n            tokenFeedIds[_token] = _feedId;\n\n            if (_setAsPreferred) {\n                preferredToken = _token;\n                emit PreferredTokenSet(_token);\n            }\n\n            emit TokenSupportUpdated(_token, true);\n            emit TokenFeedIdSet(_token, _feedId);\n        }\n    }\n\n    /// @notice Removes a token (disables support + clears feed ID)\n    /// @param _token Token address to remove\n    function removeToken(address _token) external onlyRole(ADMIN_ROLE) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n\n        if (supportedTokens.contains(_token)) {\n            // Clear preferred token if this was the preferred token\n            if (preferredToken == _token) {\n                preferredToken = address(0);\n                emit PreferredTokenSet(address(0));\n            }\n\n            supportedTokens.remove(_token);\n            tokenFeedIds[_token] = bytes32(0);\n\n            emit TokenSupportUpdated(_token, false);\n            emit TokenFeedIdSet(_token, bytes32(0));\n        }\n    }\n\n    /// @notice Updates the oracle feed ID for an already supported token\n    /// @param _token Token address\n    /// @param _feedId New oracle feed ID\n    function setTokenFeedId(address _token, bytes32 _feedId) external onlyRole(ADMIN_ROLE) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        if (!supportedTokens.contains(_token)) {\n            revert TokenNotSupported(_token);\n        }\n        if (_feedId == bytes32(0)) {\n            revert BadParams();\n        }\n        tokenFeedIds[_token] = _feedId;\n        emit TokenFeedIdSet(_token, _feedId);\n    }\n\n    /// @notice Sets the preferred token for intent execution\n    /// @param _token Preferred token address (must be configured)\n    function setPreferredToken(address _token) external onlyRole(ADMIN_ROLE) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        if (!supportedTokens.contains(_token)) {\n            revert TokenNotSupported(_token);\n        }\n        preferredToken = _token;\n        emit PreferredTokenSet(_token);\n    }\n\n    /// @notice Clears the preferred token override\n    function clearPreferredToken() external onlyRole(ADMIN_ROLE) {\n        preferredToken = address(0);\n        emit PreferredTokenSet(address(0));\n    }\n\n    // -------------------- Lifecycle --------------------\n\n    /// @notice Backend creates an intent bound to the wallet (beneficiary)\n    /// @param _intentId Unique identifier for the intent\n    /// @param _valueUsd USD value in cents (2 decimals)\n    /// @param _beneficiary Who can execute this intent\n    /// @param _expiresAt Unix timestamp when intent expires\n    function createIntent(\n        bytes32 _intentId,\n        uint256 _valueUsd,\n        address _beneficiary,\n        uint256 _expiresAt\n    ) external onlyRole(OPERATOR_ROLE) {\n        if (_intentId == bytes32(0) || _beneficiary == address(0) || _valueUsd == 0 || _expiresAt == 0) {\n            revert BadParams();\n        }\n        if (_expiresAt <= block.timestamp) {\n            revert BadParams();\n        }\n        if (intents[_intentId].intentId != bytes32(0)) {\n            revert IntentAlreadyExists(_intentId);\n        }\n\n        intents[_intentId] = PurchaseIntent({\n            intentId: _intentId,\n            beneficiary: _beneficiary,\n            valueUsd: _valueUsd,\n            settledUsd: 0,\n            debitedToken: address(0),\n            debitedTokenPrice: 0,\n            debitedTokenAmount: 0,\n            expiresAt: _expiresAt,\n            createdAt: block.timestamp,\n            updatedAt: block.timestamp,\n            status: PurchaseStatus.PENDING,\n            executedAtBlock: 0\n        });\n\n        emit IntentCreated(_intentId, _beneficiary, _valueUsd, _expiresAt);\n    }\n\n    /// @inheritdoc IGildiExchangePurchaseVault\n    function executeIntent(\n        bytes32 _intentId,\n        address _tokenHint,\n        IGildiExchangePurchaseVault.ExecutionContext calldata _ctx\n    ) external override nonReentrant returns (address token, uint256 tokenAmount) {\n        PurchaseIntent storage intent = intents[_intentId];\n\n        // Validation checks\n        if (intent.intentId == bytes32(0)) {\n            revert IntentDoesNotExist(_intentId);\n        }\n        if (msg.sender != intent.beneficiary) {\n            revert NotBeneficiary(_intentId);\n        }\n        if (_derivedExpired(intent)) {\n            revert IntentExpired(_intentId);\n        }\n        if (intent.status != PurchaseStatus.PENDING) {\n            revert IntentWrongState(_intentId);\n        }\n\n        // Token selection business logic using optimal selection\n        address selectedToken = _selectToken(_tokenHint, intent.valueUsd, _ctx.releaseId, _ctx.amount, _ctx.buyer);\n\n        // Get current price with validation\n        uint256 tokenPriceUsd18 = _getTokenPriceUsd(selectedToken);\n\n        // Calculate token amount needed with slippage buffer\n        uint256 requiredTokenAmount = _calculateTokenAmountWithBuffer(selectedToken, intent.valueUsd);\n\n        // Check vault balance\n        uint256 vaultBalance = IERC20(selectedToken).balanceOf(address(this));\n        if (vaultBalance < requiredTokenAmount) {\n            revert InsufficientVaultBalance(selectedToken, requiredTokenAmount, vaultBalance);\n        }\n\n        // Transfer tokens; enforce non-FOT by verifying recipient received exact amount\n        uint256 recipientBefore = IERC20(selectedToken).balanceOf(msg.sender);\n        IERC20(selectedToken).safeTransfer(msg.sender, requiredTokenAmount);\n        uint256 recipientAfter = IERC20(selectedToken).balanceOf(msg.sender);\n        if (recipientAfter - recipientBefore != requiredTokenAmount) {\n            revert FeeOnTransferNotSupported(selectedToken);\n        }\n        uint256 actualSent = requiredTokenAmount;\n\n        // Update intent state\n        intent.debitedToken = selectedToken;\n        intent.debitedTokenAmount = actualSent;\n        intent.debitedTokenPrice = tokenPriceUsd18;\n        intent.executedAtBlock = block.number; // Track execution block\n        intent.status = PurchaseStatus.FUNDED; // Mark as funded\n        intent.updatedAt = block.timestamp;\n\n        emit IntentExecuted(_intentId, selectedToken, actualSent, intent.valueUsd, tokenPriceUsd18);\n\n        return (selectedToken, actualSent);\n    }\n\n    /// @inheritdoc IGildiExchangePurchaseVault\n    function settleIntent(\n        bytes32 _intentId,\n        uint256 _actualUsdSpentCents,\n        address _refundToken,\n        uint256 _refundTokenAmount\n    ) external override nonReentrant {\n        PurchaseIntent storage intent = intents[_intentId];\n\n        // Validation checks\n        if (intent.intentId == bytes32(0)) revert IntentDoesNotExist(_intentId);\n        if (msg.sender != intent.beneficiary) revert NotBeneficiary(_intentId);\n        if (intent.status != PurchaseStatus.FUNDED) revert IntentWrongState(_intentId);\n        // Allow no-refund path (both zero). If refunding, token must match debited token.\n        if (_refundToken == address(0)) {\n            if (_refundTokenAmount != 0) {\n                revert NotAllowedToken(_refundToken);\n            }\n        } else {\n            if (_refundToken != intent.debitedToken) {\n                revert NotAllowedToken(_refundToken);\n            }\n        }\n\n        // Enforce same-transaction requirement\n        if (intent.executedAtBlock != block.number) {\n            revert RefundNotSameTransaction(_intentId);\n        }\n\n        // Handle token refunds if provided\n        if (_refundToken != address(0) && _refundTokenAmount > 0) {\n            // Calculate the USD delta that needs to be covered by refund\n            uint256 intentValueCents = intent.valueUsd;\n            uint256 deltaUsdCents = 0;\n\n            if (intentValueCents > _actualUsdSpentCents) {\n                deltaUsdCents = intentValueCents - _actualUsdSpentCents;\n            }\n\n            // If there's a delta, validate refund covers it\n            if (deltaUsdCents > 0) {\n                // Use the same token price from when intent was executed (18 decimals)\n                uint256 refundTokenPriceUsd18 = intent.debitedTokenPrice;\n\n                // Measure actual tokens received (ban fee-on-transfer: must match requested)\n                uint256 balBefore = IERC20(_refundToken).balanceOf(address(this));\n                IERC20(_refundToken).safeTransferFrom(msg.sender, address(this), _refundTokenAmount);\n                uint256 balAfter = IERC20(_refundToken).balanceOf(address(this));\n                uint256 actualReceived = balAfter - balBefore;\n                if (actualReceived != _refundTokenAmount) {\n                    revert FeeOnTransferNotSupported(_refundToken);\n                }\n\n                // Get token decimals and calculate refund value in cents using FLOOR rounding\n                uint8 tokenDecimals = IERC20Metadata(_refundToken).decimals();\n                uint256 refundValueCents = Math.mulDiv(\n                    actualReceived,\n                    refundTokenPriceUsd18,\n                    (10 ** tokenDecimals) * 1e16,\n                    Math.Rounding.Floor\n                );\n\n                // Validate refund covers the delta (reverts entire tx including transfer if insufficient)\n                if (refundValueCents < deltaUsdCents) {\n                    revert InsufficientRefund(_intentId);\n                }\n            } else {\n                // No delta; still pull tokens if provided to avoid dangling approvals\n                IERC20(_refundToken).safeTransferFrom(msg.sender, address(this), _refundTokenAmount);\n            }\n        }\n\n        // Update intent with settled amount (already in cents) - clamp to intent value\n        intent.settledUsd = Math.min(_actualUsdSpentCents, intent.valueUsd);\n        intent.status = PurchaseStatus.SETTLED;\n        intent.updatedAt = block.timestamp;\n\n        emit IntentSettled(_intentId, intent.settledUsd);\n    }\n\n    /// @notice Backend cancels a pending/expired intent. No token movement here.\n    /// @param _intentId The intent to cancel\n    /// @param _reasonCode Reason for cancellation (for logging)\n    function cancelIntent(bytes32 _intentId, uint8 _reasonCode) external onlyRole(OPERATOR_ROLE) {\n        PurchaseIntent storage intent = intents[_intentId];\n        if (intent.intentId == bytes32(0)) {\n            revert IntentDoesNotExist(_intentId);\n        }\n        // Only pending intents can be cancelled (includes time-expired which are still stored as PENDING)\n        if (intent.status != PurchaseStatus.PENDING) {\n            revert IntentWrongState(_intentId);\n        }\n\n        intent.status = PurchaseStatus.CANCELLED;\n        intent.updatedAt = block.timestamp;\n        emit IntentCancelled(_intentId, _reasonCode);\n    }\n\n    // -------------------- Views --------------------\n\n    /// @notice Gets complete intent details\n    /// @param _intentId The intent to query\n    /// @return intent The purchase intent with derived status\n    function getIntent(bytes32 _intentId) external view returns (PurchaseIntent memory intent) {\n        intent = intents[_intentId];\n        if (intent.intentId == bytes32(0)) {\n            revert IntentDoesNotExist(_intentId);\n        }\n        if (_derivedExpired(intent) && intent.status == PurchaseStatus.PENDING) {\n            intent.status = PurchaseStatus.EXPIRED; // derived, not stored\n        }\n    }\n\n    /// @notice Gets the status of an intent\n    /// @param _intentId The intent to query\n    /// @return status The current intent status\n    function statusOf(bytes32 _intentId) external view returns (PurchaseStatus status) {\n        PurchaseIntent storage intent = intents[_intentId];\n        if (intent.intentId == bytes32(0)) {\n            revert IntentDoesNotExist(_intentId);\n        }\n        if (_derivedExpired(intent) && intent.status == PurchaseStatus.PENDING) {\n            return PurchaseStatus.EXPIRED;\n        }\n        return intent.status;\n    }\n\n    /// @notice Checks if an intent is expired\n    /// @param _intentId The intent to check\n    /// @return expired True if the intent is expired\n    function isExpired(bytes32 _intentId) external view returns (bool expired) {\n        PurchaseIntent storage intent = intents[_intentId];\n        if (intent.intentId == bytes32(0)) {\n            revert IntentDoesNotExist(_intentId);\n        }\n        return _derivedExpired(intent) && intent.status == PurchaseStatus.PENDING;\n    }\n\n    /// @inheritdoc IGildiExchangePurchaseVault\n    function remainingUsd(bytes32 _intentId) external view override returns (uint256 remaining) {\n        PurchaseIntent storage intent = intents[_intentId];\n        if (intent.intentId == bytes32(0)) {\n            revert IntentDoesNotExist(_intentId);\n        }\n        return _remainingUsd(intent);\n    }\n\n    // -------------------- Vault Ops (liquidity) --------------------\n\n    /// @notice Adds tokens to the vault for liquidity\n    /// @param _token Token address\n    /// @param _amount Amount to add\n    function topUp(address _token, uint256 _amount) external nonReentrant {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        if (!supportedTokens.contains(_token)) {\n            revert TokenNotSupported(_token);\n        }\n        uint256 beforeBal = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 afterBal = IERC20(_token).balanceOf(address(this));\n        if (afterBal - beforeBal != _amount) {\n            revert FeeOnTransferNotSupported(_token);\n        }\n        emit VaultToppedUp(_token, _amount, msg.sender);\n    }\n\n    /// @notice Withdraws tokens from the vault\n    /// @param _token Token address\n    /// @param _amount Amount to withdraw\n    /// @param _to Recipient address (address(0) defaults to msg.sender)\n    function withdraw(address _token, uint256 _amount, address _to) external onlyRole(ADMIN_ROLE) nonReentrant {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        address recipient = _to == address(0) ? msg.sender : _to;\n        IERC20(_token).safeTransfer(recipient, _amount);\n        emit VaultWithdrawn(_token, _amount, recipient);\n    }\n\n    /// @notice Withdraws all tokens of a type from the vault\n    /// @param _token Token address\n    /// @param _to Recipient address (address(0) defaults to msg.sender)\n    function withdrawAll(address _token, address _to) external onlyRole(ADMIN_ROLE) nonReentrant {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        address recipient = _to == address(0) ? msg.sender : _to;\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        if (amount == 0) {\n            return;\n        }\n\n        IERC20(_token).safeTransfer(recipient, amount);\n\n        emit VaultWithdrawn(_token, amount, recipient);\n    }\n\n    /// @notice Gets vault balance for a token\n    /// @param _token Token address\n    /// @return balance The vault balance\n    function getVaultBalance(address _token) external view returns (uint256 balance) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    /// @notice Gets the oracle feed ID for a token\n    /// @param _token Token address\n    /// @return feedId The oracle feed ID\n    function getTokenFeedId(address _token) external view returns (bytes32 feedId) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        return tokenFeedIds[_token];\n    }\n\n    /// @notice Checks if a token is supported for vault operations\n    /// @param _token Token address\n    /// @return supported True if token is supported\n    function isTokenSupported(address _token) external view returns (bool supported) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        return supportedTokens.contains(_token);\n    }\n\n    /// @notice Gets all supported tokens\n    /// @return tokens Array of supported token addresses\n    function getSupportedTokens() external view returns (address[] memory tokens) {\n        uint256 length = supportedTokens.length();\n        tokens = new address[](length);\n        for (uint256 i = 0; i < length; i++) {\n            tokens[i] = supportedTokens.at(i);\n        }\n    }\n\n    /// @notice Checks if a token is fully configured (supported + has feed ID)\n    /// @param _token Token address\n    /// @return configured True if token is supported and has feed ID set\n    function isTokenConfigured(address _token) external view returns (bool configured) {\n        if (_token == address(0)) {\n            revert ZeroAddressToken();\n        }\n        return supportedTokens.contains(_token) && tokenFeedIds[_token] != bytes32(0);\n    }\n\n    /// @notice Checks if vault can fund a purchase with current token balances\n    /// @param _intentValueUsdCents Intent value in USD cents\n    /// @param _releaseId Release ID for purchase estimation\n    /// @param _amount Amount of tokens to purchase\n    /// @param _buyer Buyer address for estimation\n    /// @return canFund True if purchase can be funded\n    /// @return bestToken Address of the most cost-effective token (zero if can't fund)\n    /// @return estimatedCost Estimated cost in best token (zero if can't fund)\n    /// @inheritdoc IGildiExchangePurchaseVault\n    function canFundPurchase(\n        uint256 _intentValueUsdCents,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer\n    ) external view override returns (bool canFund, address bestToken, uint256 estimatedCost) {\n        address optimalToken = address(0);\n        uint256 lowestCostDeviation = type(uint256).max;\n        uint256 bestEstimatedCost = 0;\n\n        uint256 tokenCount = supportedTokens.length();\n        for (uint256 i = 0; i < tokenCount; i++) {\n            address candidateToken = supportedTokens.at(i);\n\n            if (_isTokenViableForIntent(candidateToken, _intentValueUsdCents, _releaseId, _amount, _buyer)) {\n                uint256 costDeviation = _calculateCostDeviation(\n                    candidateToken,\n                    _intentValueUsdCents,\n                    _releaseId,\n                    _amount,\n                    _buyer\n                );\n\n                if (costDeviation < lowestCostDeviation) {\n                    lowestCostDeviation = costDeviation;\n                    optimalToken = candidateToken;\n\n                    // Get estimated cost for this token\n                    try paymentAggregator.estimatePurchase(_releaseId, _amount, _buyer, candidateToken) returns (\n                        uint256 sourceNeeded,\n                        address,\n                        IGildiExchangeSwapAdapter.QuoteRoute memory,\n                        uint256\n                    ) {\n                        bestEstimatedCost = sourceNeeded;\n                    } catch {\n                        // If estimation fails, calculate based on price oracle\n                        bestEstimatedCost = _calculateTokenAmountWithBuffer(candidateToken, _intentValueUsdCents);\n                    }\n                }\n            }\n        }\n\n        return (optimalToken != address(0), optimalToken, bestEstimatedCost);\n    }\n\n    /// @notice Gets the list of supported tokens\n    /// @return tokens Array of supported tokens\n    function listTokens() external view returns (TokenView[] memory tokens) {\n        address[] memory allTokens = supportedTokens.values();\n        tokens = new TokenView[](allTokens.length);\n        for (uint256 i = 0; i < allTokens.length; i++) {\n            address token = allTokens[i];\n            tokens[i] = TokenView({token: token, feedId: tokenFeedIds[token], defaultToken: token == preferredToken});\n        }\n    }\n\n    // -------------------- Internal --------------------\n\n    /// @dev Selects the optimal token for intent execution based on cost analysis\n    /// @param _tokenHint Optional token preference from beneficiary\n    /// @param _intentValueUsdCents Intent value in USD cents for cost calculation\n    /// @param _releaseId Release ID for purchase estimation\n    /// @param _amount Amount of tokens to purchase\n    /// @param _buyer Buyer address for estimation\n    /// @return selectedToken The token address to use\n    function _selectToken(\n        address _tokenHint,\n        uint256 _intentValueUsdCents,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer\n    ) internal view returns (address selectedToken) {\n        // If hint is provided and viable, use it\n        if (\n            _tokenHint != address(0) &&\n            _isTokenViableForIntent(_tokenHint, _intentValueUsdCents, _releaseId, _amount, _buyer)\n        ) {\n            return _tokenHint;\n        }\n\n        // Prefer preferred token if configured and viable\n        if (\n            preferredToken != address(0) &&\n            _isTokenViableForIntent(preferredToken, _intentValueUsdCents, _releaseId, _amount, _buyer)\n        ) {\n            return preferredToken;\n        }\n\n        // Otherwise, find the most cost-effective option\n        address optimalToken = _findOptimalToken(_intentValueUsdCents, _releaseId, _amount, _buyer);\n        if (optimalToken == address(0)) {\n            revert NoViableTokenFound(_intentValueUsdCents);\n        }\n        return optimalToken;\n    }\n\n    /// @dev Checks if a token is viable for the intent (sufficient balance + cost analysis)\n    function _isTokenViableForIntent(\n        address _token,\n        uint256 _intentValueUsdCents,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer\n    ) internal view returns (bool viable) {\n        if (!supportedTokens.contains(_token)) {\n            return false;\n        }\n\n        // Calculate required amount with slippage buffer\n        uint256 requiredAmountWithBuffer = _calculateTokenAmountWithBuffer(_token, _intentValueUsdCents);\n\n        // Check vault balance\n        if (IERC20(_token).balanceOf(address(this)) < requiredAmountWithBuffer) {\n            return false;\n        }\n\n        // If we have aggregator, do cost analysis\n        if (address(paymentAggregator) != address(0)) {\n            try paymentAggregator.estimatePurchase(_releaseId, _amount, _buyer, _token) returns (\n                uint256 sourceNeeded,\n                address,\n                IGildiExchangeSwapAdapter.QuoteRoute memory,\n                uint256\n            ) {\n                return sourceNeeded <= requiredAmountWithBuffer;\n            } catch {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @dev Finds the most cost-effective token from all supported options\n    function _findOptimalToken(\n        uint256 _intentValueUsdCents,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer\n    ) internal view returns (address bestToken) {\n        uint256 tokenCount = supportedTokens.length();\n        if (tokenCount == 0) {\n            return address(0);\n        }\n\n        uint256 lowestDeviationBps = type(uint256).max;\n        address candidateToken;\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            candidateToken = supportedTokens.at(i);\n\n            if (_isTokenViableForIntent(candidateToken, _intentValueUsdCents, _releaseId, _amount, _buyer)) {\n                uint256 deviationBps = _calculateCostDeviation(\n                    candidateToken,\n                    _intentValueUsdCents,\n                    _releaseId,\n                    _amount,\n                    _buyer\n                );\n\n                if (deviationBps < lowestDeviationBps) {\n                    lowestDeviationBps = deviationBps;\n                    bestToken = candidateToken;\n                }\n            }\n        }\n\n        return bestToken;\n    }\n\n    /// @dev Calculates cost deviation for a token compared to intent value\n    function _calculateCostDeviation(\n        address _token,\n        uint256 _intentValueUsdCents,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _buyer\n    ) internal view returns (uint256 deviationBps) {\n        if (address(paymentAggregator) == address(0)) {\n            return 0;\n        }\n\n        try paymentAggregator.estimatePurchase(_releaseId, _amount, _buyer, _token) returns (\n            uint256 sourceNeeded,\n            address releaseCurrency,\n            IGildiExchangeSwapAdapter.QuoteRoute memory quoteRoute,\n            uint256\n        ) {\n            // Direct payment (no swap) = 0 deviation\n            if (releaseCurrency == _token) {\n                return 0;\n            }\n\n            // Calculate intent value in token with slippage buffer\n            uint256 intentValueInTokenWithBuffer = _calculateTokenAmountWithBuffer(_token, _intentValueUsdCents);\n\n            // Get actual swap input amount from quote\n            uint256 actualSwapAmount = quoteRoute.amounts.length > 0 ? quoteRoute.amounts[0] : sourceNeeded;\n\n            // Calculate deviation in BPS\n            if (actualSwapAmount > intentValueInTokenWithBuffer) {\n                return ((actualSwapAmount - intentValueInTokenWithBuffer) * 10000) / intentValueInTokenWithBuffer;\n            } else {\n                return ((intentValueInTokenWithBuffer - actualSwapAmount) * 10000) / intentValueInTokenWithBuffer;\n            }\n        } catch {\n            return type(uint256).max; // Max penalty for estimation failure\n        }\n    }\n\n    /// @dev Calculates token amount needed including slippage buffer\n    function _calculateTokenAmountWithBuffer(\n        address _token,\n        uint256 _intentValueUsdCents\n    ) internal view returns (uint256) {\n        uint256 price18 = _getTokenPriceUsd(_token);\n\n        uint8 dec = IERC20Metadata(_token).decimals();\n\n        // base = ceil( cents * 10^dec * 1e16 / price )\n        uint256 base = Math.mulDiv(_intentValueUsdCents, (10 ** dec) * 1e16, price18, Math.Rounding.Ceil);\n\n        // apply buffer with ceil\n        return Math.mulDiv(base, 10000 + slippageAndFeeBuffer, 10000, Math.Rounding.Ceil);\n    }\n\n    /// @dev Gets current USD price for a token with validation\n    /// @param _token Token address to get price for\n    /// @return priceUsd18 Price in USD with 18 decimals\n    function _getTokenPriceUsd(address _token) internal view returns (uint256 priceUsd18) {\n        if (!supportedTokens.contains(_token)) {\n            revert TokenNotSupported(_token);\n        }\n\n        bytes32 feedId = tokenFeedIds[_token];\n        if (feedId == bytes32(0)) {\n            revert TokenFeedIdNotSet(_token);\n        }\n\n        IGildiPriceResolver.PriceData memory priceData = gildiPriceOracle.getPriceNoOlderThan(\n            feedId,\n            300 // 5 minutes max age\n        );\n\n        // Normalize price to 18 decimals\n        if (priceData.decimals == 18) {\n            return priceData.price;\n        } else if (priceData.decimals < 18) {\n            return priceData.price * (10 ** (18 - priceData.decimals));\n        } else {\n            return priceData.price / (10 ** (priceData.decimals - 18));\n        }\n    }\n\n    /// @dev Computes remaining USD cents available for an intent.\n    function _remainingUsd(PurchaseIntent memory _intent) internal pure returns (uint256) {\n        return _intent.valueUsd - _intent.settledUsd;\n    }\n\n    /// @dev Returns true if the current timestamp is past the intent's expiry.\n    function _derivedExpired(PurchaseIntent memory _intent) internal view returns (bool) {\n        return block.timestamp > _intent.expiresAt;\n    }\n\n    /// @dev Converts USD cents to 18-decimal fixed-point amount.\n    function _valueUsdCentsToE18(uint256 _valueUsdCents) internal pure returns (uint256) {\n        return (_valueUsdCents * 1e18) / 1e2;\n    }\n\n    // -------------------- Fallbacks --------------------\n    /// @dev Rejects direct ETH transfers to force proper vault management\n    receive() external payable {\n        revert EthNotAcceptedHere();\n    }\n\n    /// @dev Rejects calls to non-existent functions\n    fallback() external payable {\n        revert EthNotAcceptedHere();\n    }\n}\n"
        },
        "contracts/mock/adapters/MockSwapAdapter.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../../interfaces/marketplace/exchange/IGildiExchangeSwapAdapter.sol';\nimport '../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport '../tokens/erc20/MockERC20Token.sol';\nimport {ContextUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\n\n/// @title MockSwapAdapter\n/// @notice A mock adapter that simulates DEX behavior with on-demand token minting\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract MockSwapAdapter is IGildiExchangeSwapAdapter, Initializable, ContextUpgradeable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    /// @dev Array of custom routes for each token pair\n    mapping(address => mapping(address => MockRoute[])) private customRoutes;\n\n    /// @dev Tracks all token pairs that have one or more configured routes\n    TokenPair[] private allTokenPairs;\n\n    /// @notice Address of the GildiPriceOracle contract\n    address public gildiPriceOracle;\n\n    /// @dev Mapping of token pairs to oracle pair IDs (tokenA => tokenB => pairId)\n    mapping(address => mapping(address => bytes32)) private oraclePairIds;\n\n    /// @dev Base rate used for display-only calculations (1e18)\n    uint256 private constant BASE_RATE = 1e18;\n\n    /// @dev Emitted when a route has invalid length\n    error InvalidRouteLength();\n    /// @dev Emitted when the route does not start with the input token\n    error RouteMustStartWithTokenIn();\n    /// @dev Emitted when the route does not end with the output token\n    error RouteMustEndWithTokenOut();\n    /// @dev Emitted when an index is out of array bounds\n    error IndexOutOfBounds();\n    /// @dev Emitted when a maximum amount is exceeded\n    error ExceededMaxAmount();\n    /// @dev Emitted when the output amount is insufficient\n    error InsufficientOutputAmount();\n    /// @dev Emitted when no valid route is found\n    error NoValidRoute();\n    /// @dev Emitted when a token is not a MockERC20Token\n    error TokenNotMockable();\n    /// @dev Emitted when exchange rate is zero or invalid\n    error InvalidExchangeRate();\n    /// @dev Emitted when price oracle address is zero\n    error InvalidPriceOracle();\n    /// @dev Emitted when assets are not found in price oracle\n    error AssetsNotFoundInOracle();\n    /// @dev Emitted when fee rate is invalid (must be < 1_000_000)\n    error InvalidFeeRate();\n\n    /// @notice Struct to represent a mock route\n    /// @dev Combines token path and fees as a single unit\n    struct MockRoute {\n        address[] path; // The tokens in the route\n        uint24[] fees; // The fees for each hop in Uniswap v3 fee units (parts per million). Example: 3000 = 0.30%\n    }\n\n    /// @notice QuoteData structure to store mock quote information\n    /// @param route The token path for the swap\n    /// @param fees The fee tiers for each hop\n    /// @param exchangeRates The exchange rates for each hop (display-only, 1e18 floor)\n    struct QuoteData {\n        address[] route;\n        uint24[] fees;\n        uint256[] exchangeRates;\n    }\n\n    /// @dev BestInQuote structure for internal stack depth optimization (quoteSwapIn)\n    struct BestInQuote {\n        uint256 cost;\n        address[] route;\n        uint24[] fees;\n        uint256[] exchangeRates;\n        bool found;\n    }\n\n    /// @dev BestOutQuote structure for internal stack depth optimization (quoteSwapOut)\n    struct BestOutQuote {\n        uint256 output;\n        address[] route;\n        uint24[] fees;\n        uint256[] exchangeRates;\n        bool found;\n    }\n\n    /// @dev Array to track all token pairs for clearAllRoutes functionality\n    struct TokenPair {\n        address tokenIn;\n        address tokenOut;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the MockSwapAdapter\n    /// @param _gildiPriceOracle The address of the GildiPriceOracle contract\n    /// @param _initialDefaultAdmin The address of the initial default admin\n    /// @param _initialContractAdmin The address of the initial contract admin\n    function initialize(\n        address _gildiPriceOracle,\n        address _initialDefaultAdmin,\n        address _initialContractAdmin\n    ) public initializer {\n        __AccessControl_init();\n        gildiPriceOracle = _gildiPriceOracle;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialDefaultAdmin);\n        _grantRole(ADMIN_ROLE, _initialContractAdmin);\n    }\n\n    /// @notice Sets the GildiPriceOracle address\n    /// @param _gildiPriceOracle The address of the GildiPriceOracle contract\n    function setGildiPriceOracle(address _gildiPriceOracle) external onlyRole(ADMIN_ROLE) {\n        gildiPriceOracle = _gildiPriceOracle;\n    }\n\n    /// @notice Sets the oracle pair ID for a token pair\n    /// @param _tokenPair The token pair\n    /// @param _pairId The oracle pair ID for this token pair\n    function setOraclePairId(TokenPair memory _tokenPair, bytes32 _pairId) external onlyRole(ADMIN_ROLE) {\n        oraclePairIds[_tokenPair.tokenIn][_tokenPair.tokenOut] = _pairId;\n    }\n\n    /// @notice Gets the oracle pair ID for a token pair\n    /// @param _tokenPair The token pair\n    /// @return pairId The oracle pair ID, or bytes32(0) if not set\n    function getOraclePairId(TokenPair memory _tokenPair) external view returns (bytes32 pairId) {\n        return oraclePairIds[_tokenPair.tokenIn][_tokenPair.tokenOut];\n    }\n\n    /// @notice Gets a display exchange rate (floor) such that: tokenA_amount * rate / 1e18 = tokenB_amount\n    function getExchangeRate(TokenPair memory _tokenPair) external view returns (uint256 rate) {\n        (uint256 num, uint256 den) = _getOracleRateFrac(_tokenPair.tokenIn, _tokenPair.tokenOut);\n        if (num == 0 || den == 0) {\n            return 0;\n        }\n        return Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n    }\n\n    /// @notice Adds a custom route for swapping tokens\n    /// @param _pair The token pair for which to add the route\n    /// @param _route The route to swap through\n    /// @param _fees The fee tiers for each hop in the route (must be one less than route length). Units are parts per million.\n    function addRoute(\n        TokenPair memory _pair,\n        address[] calldata _route,\n        uint24[] calldata _fees\n    ) external onlyRole(ADMIN_ROLE) {\n        if (_route.length < 2) {\n            revert InvalidRouteLength();\n        }\n        if (_route[0] != _pair.tokenIn) {\n            revert RouteMustStartWithTokenIn();\n        }\n        if (_route[_route.length - 1] != _pair.tokenOut) {\n            revert RouteMustEndWithTokenOut();\n        }\n        if (_route.length - 1 != _fees.length) {\n            revert InvalidRouteLength();\n        }\n\n        // Validate fee units\n        for (uint256 i = 0; i < _fees.length; i++) {\n            if (_fees[i] >= 1_000_000) {\n                revert InvalidFeeRate();\n            }\n        }\n\n        // Create and store a new MockRoute\n        MockRoute memory newRoute = MockRoute({path: _route, fees: _fees});\n\n        customRoutes[_pair.tokenIn][_pair.tokenOut].push(newRoute);\n\n        // Track that this token pair has routes (only add if not already tracked)\n        if (!_isTokenPairTracked(_pair)) {\n            allTokenPairs.push(_pair);\n        }\n    }\n\n    /// @notice Removes a custom route for swapping tokens\n    /// @param _routeIndex The index of the route to remove\n    function removeRoute(TokenPair memory _tokenPair, uint256 _routeIndex) external onlyRole(ADMIN_ROLE) {\n        if (_routeIndex >= customRoutes[_tokenPair.tokenIn][_tokenPair.tokenOut].length) {\n            revert IndexOutOfBounds();\n        }\n\n        uint256 lastIndex = customRoutes[_tokenPair.tokenIn][_tokenPair.tokenOut].length - 1;\n        if (_routeIndex < lastIndex) {\n            customRoutes[_tokenPair.tokenIn][_tokenPair.tokenOut][_routeIndex] = customRoutes[_tokenPair.tokenIn][\n                _tokenPair.tokenOut\n            ][lastIndex];\n        }\n        customRoutes[_tokenPair.tokenIn][_tokenPair.tokenOut].pop();\n\n        if (customRoutes[_tokenPair.tokenIn][_tokenPair.tokenOut].length == 0) {\n            _removeTokenPairFromArray(_tokenPair);\n        }\n    }\n\n    /// @notice Clears all custom routes for swapping tokens for a specific token pair.\n    /// @param _pair The token pair for which to clear the routes\n    function clearRoutes(TokenPair memory _pair) external onlyRole(ADMIN_ROLE) {\n        delete customRoutes[_pair.tokenIn][_pair.tokenOut];\n        _removeTokenPairFromArray(_pair);\n    }\n\n    /// @notice Clears all custom routes for all token pairs\n    function clearAllRoutes() external onlyRole(ADMIN_ROLE) {\n        for (uint256 i = 0; i < allTokenPairs.length; i++) {\n            TokenPair storage pair = allTokenPairs[i];\n            delete customRoutes[pair.tokenIn][pair.tokenOut];\n        }\n        delete allTokenPairs;\n    }\n\n    /// @notice Lists all custom routes for swapping tokens for a specific token pair.\n    /// @param _pair The token pair for which to list the routes\n    /// @return routes Array of MockRoute structs containing path and fees\n    function listRoutes(TokenPair memory _pair) external view returns (MockRoute[] memory) {\n        return customRoutes[_pair.tokenIn][_pair.tokenOut];\n    }\n\n    // ---------------------------------------------------------------------\n    // Precision-first math: fractional oracle rates + Uniswap-style rounding\n    // ---------------------------------------------------------------------\n\n    /// @dev Euclidean GCD\n    function _gcd(uint256 a, uint256 b) private pure returns (uint256) {\n        while (b != 0) {\n            uint256 t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\n    /// @dev Return price as a fraction num/den such that: out = in * num / den\n    /// Fractions account for token decimal mismatch. Returns (0,0) if unavailable.\n    function _getOracleRateFrac(address _tokenA, address _tokenB) private view returns (uint256 num, uint256 den) {\n        if (gildiPriceOracle == address(0)) {\n            return (0, 0);\n        }\n\n        bytes32 pairIdA = oraclePairIds[_tokenA][_tokenB];\n        bytes32 pairIdB = oraclePairIds[_tokenB][_tokenA];\n        if (pairIdA == bytes32(0) || pairIdB == bytes32(0)) {\n            return (0, 0);\n        }\n\n        try IGildiPriceOracle(gildiPriceOracle).getPrice(pairIdA) returns (IGildiPriceResolver.PriceData memory pa) {\n            try IGildiPriceOracle(gildiPriceOracle).getPrice(pairIdB) returns (\n                IGildiPriceResolver.PriceData memory pb\n            ) {\n                uint8 da = MockERC20Token(_tokenA).decimals();\n                uint8 db = MockERC20Token(_tokenB).decimals();\n\n                // Normalize oracle prices to 18 decimals to avoid precision loss\n                uint256 Pa = (pa.decimals <= 18)\n                    ? pa.price * (10 ** (18 - pa.decimals))\n                    : pa.price / (10 ** (pa.decimals - 18));\n                uint256 Pb = (pb.decimals <= 18)\n                    ? pb.price * (10 ** (18 - pb.decimals))\n                    : pb.price / (10 ** (pb.decimals - 18));\n\n                if (Pa == 0 || Pb == 0) {\n                    return (0, 0);\n                }\n\n                if (db >= da) {\n                    // F = (Pa * 10^(db-da)) / Pb\n                    uint256 s = 10 ** (db - da);\n\n                    // Reduce (Pa / Pb)\n                    uint256 g1 = _gcd(Pa, Pb);\n                    uint256 a = Pa / g1;\n                    uint256 b = Pb / g1;\n\n                    // Push as much of s into denominator as possible\n                    uint256 g2 = _gcd(s, b);\n                    uint256 s1 = s / g2;\n                    uint256 b1 = b / g2;\n\n                    num = a * s1;\n                    den = b1;\n                } else {\n                    // F = Pa / (Pb * 10^(da-db))\n                    uint256 s = 10 ** (da - db);\n\n                    // Reduce Pa vs s, then vs Pb\n                    uint256 g2 = _gcd(Pa, s);\n                    uint256 a1 = Pa / g2;\n                    uint256 s1 = s / g2;\n\n                    uint256 g1 = _gcd(a1, Pb);\n                    uint256 a2 = a1 / g1;\n                    uint256 b2 = Pb / g1;\n\n                    num = a2;\n                    den = b2 * s1;\n                }\n\n                if (den == 0) {\n                    return (0, 0);\n                }\n\n                // For logs: floor display rate (omitted to avoid unused variable)\n                return (num, den);\n            } catch {\n                return (0, 0);\n            }\n        } catch {\n            return (0, 0);\n        }\n    }\n\n    /// @dev Exact-input: apply fee then floor\n    function _amountOutViaFrac(uint256 amountIn, uint256 num, uint256 den, uint24 fee) private pure returns (uint256) {\n        if (fee >= 1_000_000) {\n            revert InvalidFeeRate();\n        }\n        // Apply fee to input (round DOWN)\n        uint256 effectiveIn = Math.mulDiv(amountIn, (1_000_000 - fee), 1_000_000, Math.Rounding.Floor);\n        // Multiply by fraction (round DOWN)\n        return Math.mulDiv(effectiveIn, num, den, Math.Rounding.Floor);\n    }\n\n    /// @dev Exact-output: invert then ceil, including fee-on-input\n    function _amountInViaFrac(uint256 amountOut, uint256 num, uint256 den, uint24 fee) private pure returns (uint256) {\n        if (fee >= 1_000_000) {\n            revert InvalidFeeRate();\n        }\n        if (num == 0 || den == 0) {\n            revert InvalidExchangeRate();\n        }\n        // Gross (pre-fee) input: ceil(amountOut * den / num)\n        uint256 grossNoFee = Math.mulDiv(amountOut, den, num, Math.Rounding.Ceil);\n        // Undo fee on input: ceil(gross / (1 - f))\n        return Math.mulDiv(grossNoFee, 1_000_000, (1_000_000 - fee), Math.Rounding.Ceil);\n    }\n\n    // ---------------------------------------------------------\n    // Multi-hop simulators (use fractions + correct rounding)\n    // ---------------------------------------------------------\n\n    /// @dev Simulates a multi-hop swap calculation for exact output (reverse)\n    function _simulateMultiHopOut(\n        address[] memory _route,\n        uint24[] memory _fees,\n        uint256 _finalAmountOut\n    ) private view returns (uint256 totalAmountIn, uint256[] memory displayRates) {\n        displayRates = new uint256[](_fees.length);\n        uint256 currentAmountOut = _finalAmountOut;\n\n        for (uint256 i = _fees.length; i > 0; i--) {\n            uint256 hopIndex = i - 1;\n            address tokenIn = _route[hopIndex];\n            address tokenOut = _route[hopIndex + 1];\n\n            (uint256 num, uint256 den) = _getOracleRateFrac(tokenIn, tokenOut);\n            if (num == 0 || den == 0) {\n                return (0, displayRates);\n            }\n            displayRates[hopIndex] = Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n\n            currentAmountOut = _amountInViaFrac(currentAmountOut, num, den, _fees[hopIndex]);\n        }\n\n        totalAmountIn = currentAmountOut;\n    }\n\n    /// @dev Simulates a multi-hop swap calculation for exact input (forward)\n    function _simulateMultiHopIn(\n        address[] memory _route,\n        uint24[] memory _fees,\n        uint256 _initialAmountIn\n    ) private view returns (uint256 totalAmountOut, uint256[] memory displayRates) {\n        displayRates = new uint256[](_fees.length);\n        uint256 currentAmountIn = _initialAmountIn;\n\n        for (uint256 i = 0; i < _fees.length; i++) {\n            address tokenIn = _route[i];\n            address tokenOut = _route[i + 1];\n\n            (uint256 num, uint256 den) = _getOracleRateFrac(tokenIn, tokenOut);\n            if (num == 0 || den == 0) {\n                return (0, displayRates);\n            }\n            displayRates[i] = Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n\n            currentAmountIn = _amountOutViaFrac(currentAmountIn, num, den, _fees[i]);\n        }\n\n        totalAmountOut = currentAmountIn;\n    }\n\n    // ---------------------------------------------------------\n    // Quoting & swapping (now using fractional math)\n    // ---------------------------------------------------------\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function quoteSwapIn(\n        address _sourceToken,\n        address _marketplaceToken,\n        uint256 _marketplaceAmountDesired\n    ) public view override returns (SwapInQuote memory quote) {\n        MockRoute[] storage routes = customRoutes[_sourceToken][_marketplaceToken];\n\n        BestInQuote memory best;\n        best.cost = type(uint256).max;\n\n        if (routes.length == 0) {\n            address[] memory defaultRoute = new address[](2);\n            defaultRoute[0] = _sourceToken;\n            defaultRoute[1] = _marketplaceToken;\n\n            uint24[] memory defaultFees = _getDefaultFees();\n\n            for (uint256 i = 0; i < defaultFees.length; i++) {\n                uint24 poolFee = defaultFees[i];\n\n                uint24[] memory routeFees = new uint24[](1);\n                routeFees[0] = poolFee;\n\n                (uint256 num, uint256 den) = _getOracleRateFrac(_sourceToken, _marketplaceToken);\n                if (num == 0 || den == 0) {\n                    continue;\n                }\n\n                uint256 amountIn = _amountInViaFrac(_marketplaceAmountDesired, num, den, poolFee);\n                if (amountIn > 0 && (amountIn < best.cost || !best.found)) {\n                    best.cost = amountIn;\n                    best.route = defaultRoute;\n                    best.fees = routeFees;\n\n                    best.exchangeRates = new uint256[](1);\n                    best.exchangeRates[0] = Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n\n                    best.found = true;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < routes.length; i++) {\n                MockRoute storage route = routes[i];\n\n                if (route.path.length == 2) {\n                    (uint256 num, uint256 den) = _getOracleRateFrac(route.path[0], route.path[1]);\n                    if (num == 0 || den == 0) {\n                        continue;\n                    }\n\n                    uint256 amountIn = _amountInViaFrac(_marketplaceAmountDesired, num, den, route.fees[0]);\n                    if (amountIn > 0 && (amountIn < best.cost || !best.found)) {\n                        best.cost = amountIn;\n                        best.route = route.path;\n                        best.fees = route.fees;\n\n                        best.exchangeRates = new uint256[](1);\n                        best.exchangeRates[0] = Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n\n                        best.found = true;\n                    }\n                } else {\n                    (uint256 amountIn, uint256[] memory rates) = _simulateMultiHopOut(\n                        route.path,\n                        route.fees,\n                        _marketplaceAmountDesired\n                    );\n\n                    if (amountIn > 0 && (amountIn < best.cost || !best.found)) {\n                        best.cost = amountIn;\n                        best.route = route.path;\n                        best.fees = route.fees;\n                        best.exchangeRates = rates;\n                        best.found = true;\n                    }\n                }\n            }\n        }\n\n        if (best.found) {\n            QuoteData memory quoteData = QuoteData({\n                route: best.route,\n                fees: best.fees,\n                exchangeRates: best.exchangeRates\n            });\n\n            bytes memory rawQuoteData = abi.encode(quoteData);\n\n            uint128[] memory amounts = new uint128[](best.route.length);\n            amounts[0] = uint128(best.cost);\n            amounts[best.route.length - 1] = uint128(_marketplaceAmountDesired);\n\n            uint128[] memory feesArr = new uint128[](best.fees.length);\n            for (uint256 i = 0; i < best.fees.length; i++) {\n                feesArr[i] = uint128(best.fees[i]);\n            }\n\n            // virtualAmountsWithoutSlippage: omitted by request\n            uint128[] memory emptyVirtual = new uint128[](best.route.length);\n\n            QuoteRoute memory quoteRoute = QuoteRoute({\n                marketplaceAdapter: address(this),\n                route: best.route,\n                fees: feesArr,\n                amounts: amounts,\n                virtualAmountsWithoutSlippage: emptyVirtual\n            });\n\n            quote = SwapInQuote({\n                sourceTokenRequired: best.cost,\n                rawQuoteData: rawQuoteData,\n                quoteRoute: quoteRoute,\n                validRoute: true\n            });\n        } else {\n            quote.validRoute = false;\n        }\n        return quote;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function swapIn(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmountMax,\n        uint256 _marketplaceAmount,\n        address _to,\n        bytes memory _quoteData\n    ) external override returns (uint256 sourceSpent) {\n        if (_quoteData.length == 0) {\n            SwapInQuote memory quote = quoteSwapIn(_sourceToken, _targetToken, _marketplaceAmount);\n            if (!quote.validRoute) {\n                revert NoValidRoute();\n            }\n            _quoteData = quote.rawQuoteData;\n        }\n\n        QuoteData memory quoteData = abi.decode(_quoteData, (QuoteData));\n\n        // Validate route\n        if (\n            quoteData.route.length < 2 ||\n            quoteData.fees.length != quoteData.route.length - 1 ||\n            quoteData.route[0] != _sourceToken ||\n            quoteData.route[quoteData.route.length - 1] != _targetToken\n        ) {\n            revert NoValidRoute();\n        }\n\n        if (quoteData.route.length == 2) {\n            (uint256 num, uint256 den) = _getOracleRateFrac(quoteData.route[0], quoteData.route[1]);\n            if (num == 0 || den == 0) {\n                revert InvalidExchangeRate();\n            }\n            sourceSpent = _amountInViaFrac(_marketplaceAmount, num, den, uint24(quoteData.fees[0]));\n        } else {\n            (sourceSpent, ) = _simulateMultiHopOut(quoteData.route, quoteData.fees, _marketplaceAmount);\n            if (sourceSpent == 0) {\n                revert NoValidRoute();\n            }\n        }\n\n        if (sourceSpent > _sourceAmountMax) {\n            revert ExceededMaxAmount();\n        }\n\n        IERC20(_sourceToken).safeTransferFrom(msg.sender, address(this), sourceSpent);\n        _mintTokenToAddress(_targetToken, _to, _marketplaceAmount);\n\n        return sourceSpent;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function quoteSwapOut(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmount\n    ) public view override returns (SwapOutQuote memory quote) {\n        MockRoute[] storage routes = customRoutes[_sourceToken][_targetToken];\n        BestOutQuote memory best;\n\n        if (routes.length == 0) {\n            address[] memory defaultRoute = new address[](2);\n            defaultRoute[0] = _sourceToken;\n            defaultRoute[1] = _targetToken;\n\n            uint24[] memory defaultFees = _getDefaultFees();\n\n            for (uint256 i = 0; i < defaultFees.length; i++) {\n                uint24 poolFee = defaultFees[i];\n\n                uint24[] memory routeFees = new uint24[](1);\n                routeFees[0] = poolFee;\n\n                (uint256 num, uint256 den) = _getOracleRateFrac(_sourceToken, _targetToken);\n                if (num == 0 || den == 0) {\n                    continue;\n                }\n\n                uint256 amountOut = _amountOutViaFrac(_sourceAmount, num, den, poolFee);\n\n                if (amountOut > 0 && (amountOut > best.output || !best.found)) {\n                    best.output = amountOut;\n                    best.route = defaultRoute;\n                    best.fees = routeFees;\n\n                    best.exchangeRates = new uint256[](1);\n                    best.exchangeRates[0] = Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n\n                    best.found = true;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < routes.length; i++) {\n                MockRoute storage route = routes[i];\n\n                if (route.path.length == 2) {\n                    (uint256 num, uint256 den) = _getOracleRateFrac(route.path[0], route.path[1]);\n                    if (num == 0 || den == 0) {\n                        continue;\n                    }\n\n                    uint256 amountOut = _amountOutViaFrac(_sourceAmount, num, den, route.fees[0]);\n\n                    if (amountOut > 0 && (amountOut > best.output || !best.found)) {\n                        best.output = amountOut;\n                        best.route = route.path;\n                        best.fees = route.fees;\n\n                        best.exchangeRates = new uint256[](1);\n                        best.exchangeRates[0] = Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n\n                        best.found = true;\n                    }\n                } else {\n                    (uint256 amountOut, uint256[] memory rates) = _simulateMultiHopIn(\n                        route.path,\n                        route.fees,\n                        _sourceAmount\n                    );\n\n                    if (amountOut > 0 && (amountOut > best.output || !best.found)) {\n                        best.output = amountOut;\n                        best.route = route.path;\n                        best.fees = route.fees;\n                        best.exchangeRates = rates;\n                        best.found = true;\n                    }\n                }\n            }\n        }\n\n        if (best.found) {\n            QuoteData memory quoteData = QuoteData({\n                route: best.route,\n                fees: best.fees,\n                exchangeRates: best.exchangeRates\n            });\n\n            uint128[] memory amounts = new uint128[](best.route.length);\n            amounts[0] = uint128(_sourceAmount);\n            amounts[best.route.length - 1] = uint128(best.output);\n\n            uint128[] memory feesArr = new uint128[](best.fees.length);\n            for (uint256 i = 0; i < best.fees.length; i++) {\n                feesArr[i] = uint128(best.fees[i]);\n            }\n\n            // virtualAmountsWithoutSlippage: omitted by request\n            uint128[] memory emptyVirtual = new uint128[](best.route.length);\n\n            QuoteRoute memory quoteRoute = QuoteRoute({\n                marketplaceAdapter: address(this),\n                route: best.route,\n                fees: feesArr,\n                amounts: amounts,\n                virtualAmountsWithoutSlippage: emptyVirtual\n            });\n\n            quote = SwapOutQuote({\n                targetTokenOut: best.output,\n                rawQuoteData: abi.encode(quoteData),\n                quoteRoute: quoteRoute,\n                validRoute: true\n            });\n        } else {\n            quote.validRoute = false;\n        }\n\n        return quote;\n    }\n\n    /// @inheritdoc IGildiExchangeSwapAdapter\n    function swapOut(\n        address _sourceToken,\n        address _targetToken,\n        uint256 _sourceAmount,\n        uint256 _minimumAmountOut,\n        address _to,\n        bytes memory _quoteData\n    ) external override returns (uint256 targetTokenReceived) {\n        if (_quoteData.length == 0) {\n            SwapOutQuote memory quote = quoteSwapOut(_sourceToken, _targetToken, _sourceAmount);\n            if (!quote.validRoute) {\n                revert NoValidRoute();\n            }\n            _quoteData = quote.rawQuoteData;\n        }\n\n        QuoteData memory quoteData = abi.decode(_quoteData, (QuoteData));\n\n        // Validate route\n        if (\n            quoteData.route.length < 2 ||\n            quoteData.fees.length != quoteData.route.length - 1 ||\n            quoteData.route[0] != _sourceToken ||\n            quoteData.route[quoteData.route.length - 1] != _targetToken\n        ) {\n            revert NoValidRoute();\n        }\n\n        if (quoteData.route.length == 2) {\n            (uint256 num, uint256 den) = _getOracleRateFrac(quoteData.route[0], quoteData.route[1]);\n            if (num == 0 || den == 0) {\n                revert InvalidExchangeRate();\n            }\n            targetTokenReceived = _amountOutViaFrac(_sourceAmount, num, den, uint24(quoteData.fees[0]));\n        } else {\n            (targetTokenReceived, ) = _simulateMultiHopIn(quoteData.route, quoteData.fees, _sourceAmount);\n            if (targetTokenReceived == 0) {\n                revert NoValidRoute();\n            }\n        }\n\n        if (targetTokenReceived < _minimumAmountOut) {\n            revert InsufficientOutputAmount();\n        }\n\n        IERC20(_sourceToken).safeTransferFrom(msg.sender, address(this), _sourceAmount);\n        _mintTokenToAddress(_targetToken, _to, targetTokenReceived);\n\n        return targetTokenReceived;\n    }\n\n    /// @dev Mints tokens to a specific address if the token supports minting\n    /// @param _token The token contract address\n    /// @param _to The address to mint to\n    /// @param _amount The amount to mint\n    function _mintTokenToAddress(address _token, address _to, uint256 _amount) private {\n        try MockERC20Token(_token).mint(_to, _amount) {\n            // ok\n        } catch {\n            revert TokenNotMockable();\n        }\n    }\n\n    /// @dev (Legacy) get scalar rate used for display/testing — floors to avoid optimism\n    function _getOracleRate(address _tokenA, address _tokenB) private view returns (uint256 rate) {\n        (uint256 num, uint256 den) = _getOracleRateFrac(_tokenA, _tokenB);\n        if (num == 0 || den == 0) {\n            return 0;\n        }\n        return Math.mulDiv(num, BASE_RATE, den, Math.Rounding.Floor);\n    }\n\n    /// @dev Gets asset ID by symbol from the oracle\n    /// @param _symbol The token symbol\n    /// @return assetId The asset ID, 0 if not found\n    function _getAssetIdBySymbol(string memory _symbol) private view returns (uint256 assetId) {\n        try IGildiPriceOracle(gildiPriceOracle).getAssets() returns (IGildiPriceOracle.Asset[] memory assets) {\n            for (uint256 i = 0; i < assets.length; i++) {\n                if (keccak256(bytes(assets[i].symbol)) == keccak256(bytes(_symbol))) {\n                    return assets[i].id;\n                }\n            }\n        } catch {}\n        return 0;\n    }\n\n    /// @dev Returns the default fee tiers for mock swaps\n    function _getDefaultFees() private pure returns (uint24[] memory defaultFees) {\n        defaultFees = new uint24[](4);\n        defaultFees[0] = 3000; // 0.30%\n        defaultFees[1] = 500; // 0.05%\n        defaultFees[2] = 10000; // 1.00%\n        defaultFees[3] = 100; // 0.01%\n        return defaultFees;\n    }\n\n    /// @dev Checks if a token pair is already being tracked\n    function _isTokenPairTracked(TokenPair memory _pair) private view returns (bool exists) {\n        for (uint256 i = 0; i < allTokenPairs.length; i++) {\n            if (allTokenPairs[i].tokenIn == _pair.tokenIn && allTokenPairs[i].tokenOut == _pair.tokenOut) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @dev Removes a token pair from the tracking array\n    function _removeTokenPairFromArray(TokenPair memory _pair) private {\n        for (uint256 i = 0; i < allTokenPairs.length; i++) {\n            if (allTokenPairs[i].tokenIn == _pair.tokenIn && allTokenPairs[i].tokenOut == _pair.tokenOut) {\n                if (i < allTokenPairs.length - 1) {\n                    allTokenPairs[i] = allTokenPairs[allTokenPairs.length - 1];\n                }\n                allTokenPairs.pop();\n                break;\n            }\n        }\n    }\n}\n"
        },
        "contracts/mock/MockERC20MintableOwnable.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';\n\ncontract MockERC20MintableOwnable is ERC20, ERC20Burnable, Ownable, ERC20Permit {\n    uint8 private tokenDecimals;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol) Ownable(_msgSender()) ERC20Permit(_name) {\n        if (_decimals > 18 || _decimals == 0) {\n            _decimals = 18;\n        }\n\n        tokenDecimals = _decimals;\n    }\n\n    function mint(address _to, uint256 _amount) public virtual onlyOwner {\n        _mint(_to, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return tokenDecimals;\n    }\n}\n"
        },
        "contracts/mock/MockGildiExchangeUpgrade.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../marketplace/exchange/GildiExchange.sol';\nimport './MockUpgrade.sol';\n\ncontract MockGildiExchangeUpgrade is GildiExchange, MockUpgrade {}\n"
        },
        "contracts/mock/MockGildiManagerUpgrade.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../manager/GildiManager.sol';\nimport './MockUpgrade.sol';\n\ncontract MockGildiManagerUpgrade is GildiManager, MockUpgrade {}\n"
        },
        "contracts/mock/MockGildiShareTokenUpgrade.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../token/GildiShareToken.sol';\nimport './MockUpgrade.sol';\n\ncontract MockGildiShareTokenV2 is GildiShareToken, MockUpgrade {}\n"
        },
        "contracts/mock/MockGildiWalletLogicUpgrade.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {GildiWalletLogic} from '../wallet/GildiWalletLogic.sol';\nimport {MockUpgrade} from './MockUpgrade.sol';\n\ncontract MockGildiWalletLogicUpgrade is GildiWalletLogic, MockUpgrade {}\n"
        },
        "contracts/mock/MockRoyaltyDistributorUpgrade.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../royalties/RoyaltyDistributor.sol';\nimport './MockUpgrade.sol';\n\ncontract MockRoyaltyDistributorUpgrade is RoyaltyDistributor, MockUpgrade {}\n"
        },
        "contracts/mock/MockUpgrade.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nabstract contract MockUpgrade {\n    bool private newFunctionValue;\n\n    /// @dev This function is used to test the upgradeability of the contract.\n    /// @return True if the function is called, false otherwise.\n    function newFunctionGetter() external view returns (bool) {\n        return newFunctionValue;\n    }\n\n    /// @dev This function is used to test the upgradeability of the contract.\n    /// @param _newFunctionValue The new value for the function.\n    function newFunctionSetter(bool _newFunctionValue) external {\n        newFunctionValue = _newFunctionValue;\n    }\n\n    /// @dev Returns true to indicate this is an upgraded contract\n    /// @return Boolean indicating upgrade status\n    function isUpgraded() public pure returns (bool) {\n        return true;\n    }\n}\n"
        },
        "contracts/mock/tokens/erc20/faucet/MockTokenFaucet.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '../MockERC20Token.sol';\n\n/// @title MockTokenFaucet\n/// @dev For testing purposes only.\n/// @notice This contract is a faucet for ERC20 mock tokens.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract MockTokenFaucet is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    address[] private faucetTokens;\n    mapping(address => uint256) private faucetTokenBaseAmount;\n    mapping(address => bool) private isFaucetToken;\n\n    uint256 private mintCooldown;\n    uint256 private receiveCooldown;\n\n    mapping(address => mapping(address => uint256)) private lastMinted;\n    mapping(address => mapping(address => uint256)) private lastReceived;\n\n    error TokenNotFaucetToken();\n    error ContractNotMinter();\n    error MintCooldownNotExpired();\n    error ReceiveCooldownNotExpired();\n    error BadRequest();\n\n    event FaucetTokenSet(address token, uint256 baseAmount);\n    event FaucetTokenRemoved(address token);\n    event MintCooldownSet(uint256 cooldown);\n    event ReceiveCooldownSet(uint256 cooldown);\n    event FaucetSent(address token, address receiver, uint256 amount);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract\n    /// @param _initialOwner The initial owner of the contract\n    /// @param _mintCooldown The cooldown period for minting in seconds\n    /// @param _receiveCooldown The cooldown period for receiving in seconds\n    function initialize(address _initialOwner, uint256 _mintCooldown, uint256 _receiveCooldown) public initializer {\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n\n        mintCooldown = _mintCooldown;\n        receiveCooldown = _receiveCooldown;\n    }\n\n    /// @notice Request tokens from the faucet\n    /// @param _tokenAddress The address of the token to mint\n    /// @param _receiver The address that will receive the tokens\n    /// @param _mintAmount The amount of tokens to mint\n    function requestTokens(\n        address[] calldata _tokenAddress,\n        address _receiver,\n        uint256[] calldata _mintAmount\n    ) external nonReentrant {\n        if (_tokenAddress.length != _mintAmount.length) {\n            revert BadRequest();\n        }\n\n        for (uint256 i = 0; i < _tokenAddress.length; i++) {\n            _requestFaucetToken(_tokenAddress[i], _receiver, _mintAmount[i]);\n        }\n    }\n\n    /// @notice Request a single token from the faucet\n    /// @param _tokenAddress The address of the token to mint\n    /// @param _receiver The address that will receive the tokens\n    /// @param _mintAmount The amount of tokens to mint\n    function requestToken(address _tokenAddress, address _receiver, uint256 _mintAmount) external nonReentrant {\n        _requestFaucetToken(_tokenAddress, _receiver, _mintAmount);\n    }\n\n    /// @notice Request all tokens from the faucet\n    /// @param _receiver The address that will receive the tokens\n    function requestAllTokens(address _receiver) external nonReentrant {\n        for (uint256 i = 0; i < faucetTokens.length; i++) {\n            _requestFaucetToken(faucetTokens[i], _receiver, faucetTokenBaseAmount[faucetTokens[i]]);\n        }\n    }\n\n    /// @notice Set a token as a faucet token with a base amount\n    /// @param _tokenAddress The address of the token\n    /// @param _baseAmount The base amount for the token\n    function setFaucetToken(address _tokenAddress, uint256 _baseAmount) external onlyOwner {\n        MockERC20Token token = MockERC20Token(_tokenAddress);\n        if (!token.hasRole(token.MINTER_ROLE(), address(this))) {\n            revert ContractNotMinter();\n        }\n\n        if (!isFaucetToken[_tokenAddress]) {\n            faucetTokens.push(_tokenAddress);\n            isFaucetToken[_tokenAddress] = true;\n        }\n\n        faucetTokenBaseAmount[_tokenAddress] = _baseAmount;\n\n        emit FaucetTokenSet(_tokenAddress, _baseAmount);\n    }\n\n    /// @notice Remove a token from the faucet\n    /// @param _token The address of the token to remove\n    function removeFaucetToken(address _token) external onlyOwner {\n        if (!isFaucetToken[_token]) {\n            revert TokenNotFaucetToken();\n        }\n\n        isFaucetToken[_token] = false;\n        faucetTokenBaseAmount[_token] = 0;\n\n        for (uint256 i = 0; i < faucetTokens.length; i++) {\n            if (faucetTokens[i] == _token) {\n                faucetTokens[i] = faucetTokens[faucetTokens.length - 1];\n                faucetTokens.pop();\n                break;\n            }\n        }\n\n        emit FaucetTokenRemoved(_token);\n    }\n\n    /// @notice Set the mint cooldown period\n    /// @param _cooldown The new mint cooldown period in seconds\n    function setMintCooldown(uint256 _cooldown) external onlyOwner {\n        mintCooldown = _cooldown;\n\n        emit MintCooldownSet(_cooldown);\n    }\n\n    /// @notice Set the receive cooldown period\n    /// @param _cooldown The new receive cooldown period in seconds\n    function setReceiveCooldown(uint256 _cooldown) external onlyOwner {\n        receiveCooldown = _cooldown;\n\n        emit ReceiveCooldownSet(_cooldown);\n    }\n\n    /// @notice Check if a token is a faucet token\n    /// @param _token The address of the token\n    function getIsFaucetToken(address _token) external view returns (bool) {\n        return isFaucetToken[_token];\n    }\n\n    /// @notice Get the base amounts for all faucet tokens\n    /// @return tokenAddresses An array of faucet token addresses\n    /// @return tokenAmounts An array of base amounts for the faucet tokens\n    function getFaucetTokenBaseAmounts()\n        external\n        view\n        returns (address[] memory tokenAddresses, uint256[] memory tokenAmounts)\n    {\n        tokenAddresses = new address[](faucetTokens.length);\n        tokenAmounts = new uint256[](faucetTokens.length);\n\n        for (uint256 i = 0; i < faucetTokens.length; i++) {\n            tokenAddresses[i] = faucetTokens[i];\n            tokenAmounts[i] = faucetTokenBaseAmount[faucetTokens[i]];\n        }\n    }\n\n    /// @notice Get the list of faucet tokens\n    /// @return An array of faucet token addresses\n    function getFaucetTokens() external view returns (address[] memory) {\n        return faucetTokens;\n    }\n\n    /// @notice Get the base amount for a faucet token\n    /// @param _tokenAddress The address of the token\n    /// @return The base amount for the token\n    function getFaucetTokenBaseAmount(address _tokenAddress) external view returns (uint256) {\n        return faucetTokenBaseAmount[_tokenAddress];\n    }\n\n    /// @notice Get the last mint timestamp for a user and token\n    /// @param user The address of the user\n    /// @param token The address of the token\n    /// @return The last mint timestamp\n    function getLastMinted(address user, address token) external view returns (uint256) {\n        return lastMinted[user][token];\n    }\n\n    /// @notice Get the last receive timestamp for a user and token\n    /// @param user The address of the user\n    /// @param token The address of the token\n    /// @return The last receive timestamp\n    function getLastReceived(address user, address token) external view returns (uint256) {\n        return lastReceived[user][token];\n    }\n\n    /// @notice Get the next mint timestamp for a token\n    /// @param _tokenAddress The address of the token\n    /// @param _caller The address of the caller\n    /// @param _receiver The address of the receiver\n    /// @return The timestamp of the next mint\n    function getNextMintTimestamp(\n        address _tokenAddress,\n        address _caller,\n        address _receiver\n    ) external view returns (uint256) {\n        uint256 callerTokenLastMinted = lastMinted[_caller][_tokenAddress];\n        uint256 receiverTokenLastReceived = lastReceived[_receiver][_tokenAddress];\n\n        if (callerTokenLastMinted > receiverTokenLastReceived) {\n            return callerTokenLastMinted + mintCooldown;\n        } else {\n            return receiverTokenLastReceived + receiveCooldown;\n        }\n    }\n\n    /// @dev Internal function to request a token from the faucet\n    /// @param _tokenAddress The address of the token to mint\n    /// @param _receiver The address that will receive the tokens\n    /// @param _mintAmount The amount of tokens to mint\n    function _requestFaucetToken(address _tokenAddress, address _receiver, uint256 _mintAmount) internal {\n        if (!isFaucetToken[_tokenAddress]) {\n            revert TokenNotFaucetToken();\n        }\n\n        if (block.timestamp - lastMinted[msg.sender][_tokenAddress] < mintCooldown) {\n            revert MintCooldownNotExpired();\n        }\n\n        if (block.timestamp - lastReceived[_receiver][_tokenAddress] < receiveCooldown) {\n            revert ReceiveCooldownNotExpired();\n        }\n\n        MockERC20Token token = MockERC20Token(_tokenAddress);\n        if (!token.hasRole(token.MINTER_ROLE(), address(this))) {\n            revert ContractNotMinter();\n        }\n\n        if (_mintAmount > faucetTokenBaseAmount[_tokenAddress]) {\n            _mintAmount = faucetTokenBaseAmount[_tokenAddress];\n        }\n\n        if (_mintAmount == 0) {\n            _mintAmount = faucetTokenBaseAmount[_tokenAddress];\n        }\n\n        // If balance is already at faucetTokenBaseAmount, mint only 10% of the base amount\n        if (token.balanceOf(_receiver) >= faucetTokenBaseAmount[_tokenAddress]) {\n            _mintAmount = faucetTokenBaseAmount[_tokenAddress] / 10;\n        }\n\n        token.mint(_receiver, _mintAmount);\n\n        // Update cooldown timestamps\n        lastMinted[msg.sender][_tokenAddress] = block.timestamp;\n        lastReceived[_receiver][_tokenAddress] = block.timestamp;\n\n        emit FaucetSent(_tokenAddress, _receiver, _mintAmount);\n    }\n}\n"
        },
        "contracts/mock/tokens/erc20/MockERC20Token.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';\nimport '../MockToken.sol';\n\n/// @title MockERC20Token\n/// @dev This contract is used for testing purposes only.\n/// @notice Anm abstract ERC20 token with permit that is used for testing purposes only.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract MockERC20Token is ERC20, ERC20Permit, MockToken {\n    uint8 private tokenDecimals;\n\n    /// @notice Constructs the ERC20 token with permit.\n    /// @dev If the decimals are greater than 18, it will be set to 18\n    /// @param _name The name of the token\n    /// @param _symbol The symbol of the token\n    /// @param _decimals The number of decimals for the token\n    /// @param _defaultAdmin The initial default Administrator\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _defaultAdmin\n    ) ERC20(_name, _symbol) ERC20Permit(_name) {\n        if (_decimals > 18) {\n            _decimals = 18;\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n\n        tokenDecimals = _decimals;\n    }\n\n    /// @notice Mints the token to the specified address.\n    /// @param to The address to mint the token to\n    /// @param amount The amount of token to mint\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return tokenDecimals;\n    }\n}\n"
        },
        "contracts/mock/tokens/erc20/MockERC20TokenBurnable.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport './MockERC20Token.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\n\n/// @title MockERC20Token\n/// @dev This contract is used for testing purposes only.\n/// @notice Anm abstract ERC20 token with permit that is used for testing purposes only.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract MockERC20TokenBurnable is MockERC20Token, ERC20Burnable {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _defaultAdmin\n    ) MockERC20Token(_name, _symbol, _decimals, _defaultAdmin) {}\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override(ERC20, MockERC20Token) returns (uint8) {\n        return super.decimals();\n    }\n}\n"
        },
        "contracts/mock/tokens/erc20/MockRUSTToken.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport './MockERC20TokenBurnable.sol';\n\n/// @title MockRUSTToken\n/// @notice Mock contract for the Rusty Robot Country Club token\n/// @dev This contract is for testing purposes only\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract MockRUSTToken is MockERC20TokenBurnable {\n    /// @notice Initialize the MockRUSTToken contract\n    /// @dev Sets up the ERC20 token with name \"Mock Rusty Robot Country Club\", symbol \"mRUST\", and 18 decimals\n    /// @param _defaultAdmin The address that will have admin privileges for the token\n    constructor(\n        address _defaultAdmin\n    ) MockERC20TokenBurnable('Mock Rusty Robot Country Club', 'mRUST', 18, _defaultAdmin) {}\n}\n"
        },
        "contracts/mock/tokens/erc20/MockUSDCToken.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport './MockERC20Token.sol';\n\n/// @title MockUSDCToken\n/// @notice Mock contract for the USDC token\n/// @dev This contract is for testing purposes only\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract MockUSDCToken is MockERC20Token {\n    /// @notice Initialize the MockUSDCToken contract\n    /// @dev Sets up the ERC20 token with name \"Mock USD Coin\", symbol \"mUSDC\", and 6 decimals\n    /// @param _defaultAdmin The address that will have admin privileges for the token\n    constructor(address _defaultAdmin) MockERC20Token('Mock USD Coin', 'mUSDC', 6, _defaultAdmin) {}\n}\n"
        },
        "contracts/mock/tokens/erc20/MockWETH9Token.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport {MockERC20Token, ERC20} from './MockERC20Token.sol';\nimport {IWNative} from '../../../interfaces/external/IWNative.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\n\n/// @title MockWETH9Token\n/// @notice Mock implementation of the WETH9 token for testing and development purposes\n/// @dev Provides wrapped ETH functionality with deposit/withdraw capabilities and reentrancy protection\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract MockWETH9Token is IWNative, MockERC20Token, ReentrancyGuard {\n    /// @dev Optional override for the ERC20 name returned by `name()` when non-empty.\n    string private overrideNameValue;\n    /// @dev Optional override for the ERC20 symbol returned by `symbol()` when non-empty.\n    string private overrideSymbolValue;\n\n    /// @notice Role permitted to administer contract-level settings (e.g., name/symbol overrides).\n    bytes32 public constant CONTRACT_ADMIN_ROLE = keccak256('CONTRACT_ADMIN_ROLE');\n\n    /// @dev Reverts when ETH transfer via withdraw fails\n    error EthTransferFailed();\n\n    /// @dev Reverts when no name is set\n    error EmptyName();\n\n    /// @dev Reverts when no symbol is set\n    error EmptySymbol();\n\n    /// @notice Initialize the MockWETH9Token contract\n    /// @dev Sets up the ERC20 token with name \"Mock WETH9\", symbol \"mWETH9\", and 18 decimals\n    /// @param _initialDefaultAdmin The address that will have admin privileges for the token\n    /// @param _initialContractAdmin The address that will have admin privileges for the contract\n    /// @param _overrideName The name of the token\n    /// @param _overrideSymbol The symbol of the token\n    constructor(\n        address _initialDefaultAdmin,\n        address _initialContractAdmin,\n        string memory _overrideName,\n        string memory _overrideSymbol\n    ) MockERC20Token('Mock WETH9', 'mWETH9', 18, _initialDefaultAdmin) {\n        _grantRole(CONTRACT_ADMIN_ROLE, _initialContractAdmin);\n\n        overrideNameValue = _overrideName;\n        overrideSymbolValue = _overrideSymbol;\n    }\n\n    /// @notice Emitted when ETH is deposited and WETH tokens are minted\n    /// @param dst The address receiving the wrapped tokens\n    /// @param wad The amount of ETH deposited and tokens minted\n    event Deposit(address indexed dst, uint wad);\n\n    /// @notice Emitted when WETH tokens are burned and ETH is withdrawn\n    /// @param src The address withdrawing the ETH\n    /// @param wad The amount of tokens burned and ETH withdrawn\n    event Withdrawal(address indexed src, uint wad);\n\n    /// @notice Emitted when the token name override is updated\n    /// @param previousName The previously observed token name\n    /// @param newName The new token name\n    event CustomNameUpdated(string previousName, string newName);\n\n    /// @notice Emitted when the token symbol override is updated\n    /// @param previousSymbol The previously observed token symbol\n    /// @param newSymbol The new token symbol\n    event CustomSymbolUpdated(string previousSymbol, string newSymbol);\n\n    /// @inheritdoc IWNative\n    function deposit() public payable override nonReentrant {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /// @inheritdoc IWNative\n    function withdraw(uint256 _amount) public override nonReentrant {\n        _burn(msg.sender, _amount);\n        (bool ok, ) = msg.sender.call{value: _amount}('');\n        if (!ok) {\n            revert EthTransferFailed();\n        }\n        emit Withdrawal(msg.sender, _amount);\n    }\n\n    /// @notice Sets a new token name override.\n    /// @param _name The new token name to expose via `name()`.\n    function setCustomName(string memory _name) external onlyRole(CONTRACT_ADMIN_ROLE) {\n        if (bytes(_name).length == 0) {\n            revert EmptyName();\n        }\n        string memory previous = bytes(overrideNameValue).length > 0 ? overrideNameValue : super.name();\n        overrideNameValue = _name;\n        emit CustomNameUpdated(previous, _name);\n    }\n\n    /// @notice Sets a new token symbol override.\n    /// @param _symbol The new token symbol to expose via `symbol()`.\n    function setCustomSymbol(string memory _symbol) external onlyRole(CONTRACT_ADMIN_ROLE) {\n        if (bytes(_symbol).length == 0) {\n            revert EmptySymbol();\n        }\n        string memory previous = bytes(overrideSymbolValue).length > 0 ? overrideSymbolValue : super.symbol();\n        overrideSymbolValue = _symbol;\n        emit CustomSymbolUpdated(previous, _symbol);\n    }\n\n    /// @notice Clears the custom token name override and restores the base ERC20 name\n    /// @dev Sets `overrideNameValue` to empty so `name()` falls back to `super.name()`\n    function clearCustomName() external onlyRole(CONTRACT_ADMIN_ROLE) {\n        overrideNameValue = '';\n    }\n\n    /// @notice Clears the custom token symbol override and restores the base ERC20 symbol\n    /// @dev Sets `overrideSymbolValue` to empty so `symbol()` falls back to `super.symbol()`\n    function clearCustomSymbol() external onlyRole(CONTRACT_ADMIN_ROLE) {\n        overrideSymbolValue = '';\n    }\n\n    /// @inheritdoc ERC20\n    function name() public view override returns (string memory) {\n        return bytes(overrideNameValue).length > 0 ? overrideNameValue : super.name();\n    }\n\n    /// @inheritdoc ERC20\n    function symbol() public view override returns (string memory) {\n        return bytes(overrideSymbolValue).length > 0 ? overrideSymbolValue : super.symbol();\n    }\n\n    /// @notice Receive function that automatically deposits ETH when sent directly to contract\n    /// @dev Calls the deposit function when ETH is sent without data\n    receive() external payable {\n        deposit();\n    }\n\n    /// @notice Fallback function that automatically deposits ETH when sent directly to contract\n    /// @dev Calls the deposit function when ETH is sent with data\n    fallback() external payable {\n        deposit();\n    }\n}\n"
        },
        "contracts/mock/tokens/MockToken.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\n\n/// @title Mock Token\n/// @notice Abstract contract for mock tokens, makes sure that the contract has a minter role\n/// @dev This contract is for testing purposes only\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\nabstract contract MockToken is AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256('MINTER_ROLE');\n}\n"
        },
        "contracts/oracles/price/GildiPriceOracle.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title Gildi Price Oracle\n/// @notice Manages asset pairs and delegates price resolution to resolvers\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiPriceOracle is Initializable, AccessControlUpgradeable, IGildiPriceOracle {\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    /// @dev Mapping from pair hash to IGildiPriceResolver implementation\n    mapping(bytes32 => IGildiPriceResolver) private pairResolvers;\n\n    // Custom Errors\n    /// @dev Thrown when a non-admin attempts to perform an admin-only action\n    error NotAdmin();\n    /// @dev Thrown when a resolver address is zero\n    error ResolverAddressZero();\n    /// @dev Thrown when an index is out of bounds\n    error IndexOutOfBounds();\n    /// @dev Thrown when an asset is not found\n    /// @param assetId The ID of the asset that was not found\n    error AssetNotFound(uint256 assetId);\n    /// @dev Thrown when a symbol length is invalid\n    error InvalidSymbolLength();\n    /// @dev Thrown when a pair is not found\n    error PairNotFound();\n    /// @dev Thrown when a symbol contains invalid characters\n    error InvalidSymbol();\n    /// @dev Thrown when a symbol is already taken\n    error SymbolTaken();\n\n    // Events\n    /// @notice Emitted when a resolver is added for a pair\n    /// @param baseAsset The base asset address\n    /// @param quoteAsset The quote asset address\n    /// @param resolver The address of the resolver contract\n    event ResolverAdded(string baseAsset, string quoteAsset, address indexed resolver);\n\n    /// @notice Emitted when a pair is deleted\n    /// @param pairId The pair ID\n    /// @param baseAssetId The base asset id\n    /// @param quoteAssetId The quote asset id\n    event PairDeleted(bytes32 pairId, uint256 baseAssetId, uint256 quoteAssetId);\n\n    /// @notice Emitted when an asset is deleted\n    /// @param assetId The asset ID\n    /// @param symbol The asset symbol\n    /// @param name The asset name\n    event AssetDeleted(uint256 assetId, string symbol, string name);\n\n    // Assets\n    /// @dev Array of all pairs\n    Pair[] private pairs;\n    /// @dev Mapping to track if a pair exists\n    mapping(bytes32 => bool) private pairExists;\n\n    /// @dev Map asset ID -> Asset\n    mapping(uint256 => Asset) private assetRegistry;\n    /// @dev Next asset ID to be assigned\n    uint256 private nextAssetId;\n    /// @dev Maps uppercase symbol -> assetId\n    mapping(bytes32 => uint256) private symbolToId;\n    /// @dev Store assets in an array for getAssets()\n    Asset[] private allAssets;\n\n    // Pairs\n    /// @dev Structure to represent an asset pair\n    struct Pair {\n        /// @dev The unique identifier for the base asset\n        uint256 baseAssetId;\n        /// @dev The unique identifier for the quote asset\n        uint256 quoteAssetId;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract and sets up roles\n    /// @param _defaultAdmin The address of the default admin\n    /// @param _contractAdmin The address of the contract admin\n    function initialize(address _defaultAdmin, address _contractAdmin) public initializer {\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        _grantRole(ADMIN_ROLE, _contractAdmin);\n    }\n\n    /// @inheritdoc IGildiPriceOracle\n    function getResolver(bytes32 _pairId) external view override returns (IGildiPriceResolver resolver) {\n        if (!pairExists[_pairId]) {\n            revert InvalidPairId();\n        }\n\n        resolver = pairResolvers[_pairId];\n        return resolver;\n    }\n\n    /// @dev Computes a unique pair ID for an asset pair\n    /// @param _baseAsset The base asset address\n    /// @param _quoteAsset The quote asset address\n    /// @return The hash of the asset pair\n    function _generatePairId(string memory _baseAsset, string memory _quoteAsset) internal pure returns (bytes32) {\n        // Convert both strings to uppercase, then hash them together\n        // (or just hash them directly if preferred)\n        bytes memory b1 = bytes(_baseAsset);\n        bytes memory b2 = bytes(_quoteAsset);\n        for (uint i = 0; i < b1.length; i++) {\n            if (b1[i] >= 0x61 && b1[i] <= 0x7A) {\n                b1[i] = bytes1(uint8(b1[i]) - 32);\n            }\n        }\n        for (uint j = 0; j < b2.length; j++) {\n            if (b2[j] >= 0x61 && b2[j] <= 0x7A) {\n                b2[j] = bytes1(uint8(b2[j]) - 32);\n            }\n        }\n        return keccak256(abi.encodePacked(b1, '/', b2));\n    }\n\n    /// @notice Return all pairs in the form \"BASE/QUOTE\" for direct usage\n    /// @return An array of PairInfo structs containing all registered pairs\n    function getPairs() external view returns (PairInfo[] memory) {\n        PairInfo[] memory pairList = new PairInfo[](pairs.length);\n        for (uint i = 0; i < pairs.length; i++) {\n            Asset memory baseAsset = assetRegistry[pairs[i].baseAssetId];\n            Asset memory quoteAsset = assetRegistry[pairs[i].quoteAssetId];\n\n            pairList[i] = PairInfo({\n                pairId: _generatePairId(baseAsset.symbol, quoteAsset.symbol),\n                baseAsset: baseAsset,\n                quoteAsset: quoteAsset\n            });\n        }\n        return pairList;\n    }\n\n    /// @notice Adds a new asset to the registry\n    /// @param _symbol The symbol of the asset\n    /// @param _name The name of the asset\n    /// @return The ID of the newly added asset\n    function addAsset(string memory _symbol, string memory _name) external onlyRole(ADMIN_ROLE) returns (uint256) {\n        // Validate & uppercase symbol\n        bytes memory s = bytes(_symbol);\n        if (s.length < 3 || s.length > 6) {\n            revert InvalidSymbolLength();\n        }\n\n        for (uint i = 0; i < s.length; i++) {\n            if (s[i] >= 0x61 && s[i] <= 0x7A) {\n                s[i] = bytes1(uint8(s[i]) - 32);\n            }\n            // Only [A-Z0-9] allowed\n            if ((s[i] < 0x30 || s[i] > 0x39) && (s[i] < 0x41 || s[i] > 0x5A)) {\n                revert InvalidSymbol();\n            }\n        }\n        bytes32 symbolHash = keccak256(s);\n        if (symbolToId[symbolHash] != 0) {\n            revert SymbolTaken();\n        }\n\n        nextAssetId++;\n        assetRegistry[nextAssetId] = Asset(nextAssetId, string(s), _name);\n        symbolToId[symbolHash] = nextAssetId;\n        allAssets.push(assetRegistry[nextAssetId]);\n        return nextAssetId;\n    }\n\n    /// @notice Deletes an asset and all pairs that reference it\n    /// @param _assetId The ID of the asset to delete\n    function deleteAsset(uint256 _assetId) external onlyRole(ADMIN_ROLE) {\n        // 1. Check that the asset exists\n        Asset memory asset = assetRegistry[_assetId];\n        if (asset.id != _assetId) {\n            revert AssetNotFound(_assetId);\n        }\n\n        // 2. Remove the asset from assetRegistry and symbolToId\n        delete assetRegistry[_assetId];\n\n        // Convert symbol to uppercase hash (same logic used for pair ID generation)\n        bytes memory symbolBytes = bytes(asset.symbol);\n        for (uint256 k = 0; k < symbolBytes.length; k++) {\n            // uppercase ASCII conversion\n            if (symbolBytes[k] >= 0x61 && symbolBytes[k] <= 0x7A) {\n                symbolBytes[k] = bytes1(uint8(symbolBytes[k]) - 32);\n            }\n        }\n        bytes32 symbolHash = keccak256(symbolBytes);\n        delete symbolToId[symbolHash];\n\n        // Remove from allAssets array\n        uint256 length = allAssets.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (allAssets[i].id == _assetId) {\n                allAssets[i] = allAssets[length - 1];\n                allAssets.pop();\n                break;\n            }\n        }\n\n        // 3. Remove all pairs referencing this asset\n        uint256 pairCount = pairs.length;\n        uint256 idx = 0;\n        while (idx < pairCount) {\n            Pair memory p = pairs[idx];\n            if (p.baseAssetId == _assetId || p.quoteAssetId == _assetId) {\n                // Compute pairId\n                Asset memory baseA = assetRegistry[p.baseAssetId];\n                Asset memory quoteA = assetRegistry[p.quoteAssetId];\n\n                // If baseA or quoteA was also deleted, we can still reconstruct the pair ID\n                // from the original strings we stored in memory (asset.symbol) if needed.\n                // If you strictly need the original uppercase symbols, you can store them\n                // temporarily before deleting, but let's keep it straightforward here.\n                bytes32 pairId = _generatePairId(baseA.symbol, quoteA.symbol);\n\n                // Delete from pairResolvers and pairExists\n                delete pairResolvers[pairId];\n                pairExists[pairId] = false;\n\n                // Emit an event\n                emit PairDeleted(pairId, baseA.id, quoteA.id);\n\n                // Remove the pair from the array\n                pairs[idx] = pairs[pairCount - 1];\n                pairs.pop();\n                pairCount--;\n            } else {\n                idx++;\n            }\n        }\n\n        // 4. Emit asset deleted event\n        emit AssetDeleted(_assetId, asset.symbol, asset.name);\n    }\n\n    /// @notice Deletes a pair from the oracle\n    /// @param _pairId The ID of the pair to delete\n    function deletePair(bytes32 _pairId) external onlyRole(ADMIN_ROLE) {\n        // 1. Check that the pair exists\n        if (!pairExists[_pairId]) {\n            revert PairNotFound();\n        }\n\n        uint256 baseAssetId = 0;\n        uint256 quoteAssetId = 0;\n\n        // 2. Delete the pair from pairResolvers, pairExists and pairs\n        delete pairResolvers[_pairId];\n        pairExists[_pairId] = false;\n        for (uint256 i = 0; i < pairs.length; i++) {\n            Asset memory baseAsset = assetRegistry[pairs[i].baseAssetId];\n            Asset memory quoteAsset = assetRegistry[pairs[i].quoteAssetId];\n            if (_generatePairId(baseAsset.symbol, quoteAsset.symbol) == _pairId) {\n                pairs[i] = pairs[pairs.length - 1];\n                pairs.pop();\n\n                baseAssetId = baseAsset.id;\n                quoteAssetId = quoteAsset.id;\n                break;\n            }\n        }\n\n        // 3. Emit pair deleted event\n        emit PairDeleted(_pairId, baseAssetId, quoteAssetId);\n    }\n\n    /// @notice Return all registered assets\n    /// @return An array of all assets in the registry\n    function getAssets() external view returns (Asset[] memory) {\n        return allAssets;\n    }\n\n    /// @notice Return asset by ID\n    /// @param _assetId The ID of the asset to retrieve\n    /// @return The asset with the specified ID\n    function getAssetById(uint256 _assetId) external view returns (Asset memory) {\n        return assetRegistry[_assetId];\n    }\n\n    /// @notice Add a new pair using numeric asset IDs\n    /// @param _baseAssetId The ID of the base asset\n    /// @param _quoteAssetId The ID of the quote asset\n    /// @param _resolver The resolver contract for the pair\n    function addPair(\n        uint256 _baseAssetId,\n        uint256 _quoteAssetId,\n        IGildiPriceResolver _resolver\n    ) external onlyRole(ADMIN_ROLE) {\n        // Ensure both assets exist\n        if (assetRegistry[_baseAssetId].id == 0) {\n            revert AssetNotFound(_baseAssetId);\n        }\n        if (assetRegistry[_quoteAssetId].id == 0) {\n            revert AssetNotFound(_quoteAssetId);\n        }\n\n        if (address(_resolver) == address(0)) {\n            revert ResolverAddressZero();\n        }\n\n        // Convert to uppercase for hashing\n        bytes32 pairId = _generatePairId(assetRegistry[_baseAssetId].symbol, assetRegistry[_quoteAssetId].symbol);\n        pairResolvers[pairId] = _resolver;\n\n        if (!pairExists[pairId]) {\n            pairs.push(Pair(assetRegistry[_baseAssetId].id, assetRegistry[_quoteAssetId].id));\n            pairExists[pairId] = true;\n        }\n\n        emit ResolverAdded(assetRegistry[_baseAssetId].symbol, assetRegistry[_quoteAssetId].symbol, address(_resolver));\n    }\n\n    /// @notice Update the resolver for an existing pair\n    /// @param _baseAssetId The ID of the base asset\n    /// @param _quoteAssetId The ID of the quote asset\n    /// @param _resolver The new resolver contract for the pair\n    function updateResolver(\n        uint256 _baseAssetId,\n        uint256 _quoteAssetId,\n        IGildiPriceResolver _resolver\n    ) external onlyRole(ADMIN_ROLE) {\n        bytes32 pairId = _generatePairId(assetRegistry[_baseAssetId].symbol, assetRegistry[_quoteAssetId].symbol);\n        pairResolvers[pairId] = _resolver;\n    }\n\n    /// @notice Return pairs that use a specific quote asset ID\n    /// @param _quoteAssetId The ID of the quote asset to filter by\n    /// @return An array of pair strings in the format \"BASE/QUOTE\"\n    function getPairsByQuoteAsset(uint256 _quoteAssetId) external view returns (string[] memory) {\n        if (assetRegistry[_quoteAssetId].id == 0) {\n            revert AssetNotFound(_quoteAssetId);\n        }\n        string memory quoteSymbol = assetRegistry[_quoteAssetId].symbol;\n\n        Asset memory pairQuoteAsset;\n\n        // Filter pairs where pair.quoteAsset == quoteSymbol\n        uint count;\n        for (uint i = 0; i < pairs.length; i++) {\n            pairQuoteAsset = assetRegistry[pairs[i].quoteAssetId];\n            if (keccak256(bytes(pairQuoteAsset.symbol)) == keccak256(bytes(quoteSymbol))) {\n                count++;\n            }\n        }\n\n        string[] memory results = new string[](count);\n        uint index;\n        for (uint j = 0; j < pairs.length; j++) {\n            pairQuoteAsset = assetRegistry[pairs[j].quoteAssetId];\n            if (keccak256(bytes(pairQuoteAsset.symbol)) == keccak256(bytes(quoteSymbol))) {\n                Asset memory pairBaseAsset = assetRegistry[pairs[j].baseAssetId];\n                results[index] = string(abi.encodePacked(pairBaseAsset.symbol, '/', pairQuoteAsset.symbol));\n                index++;\n            }\n        }\n        return results;\n    }\n\n    /// @notice Overload to get price by numeric IDs\n    /// @param _baseAssetId The ID of the base asset\n    /// @param _quoteAssetId The ID of the quote asset\n    /// @return Price data for the specified asset pair\n    function getPriceById(uint256 _baseAssetId, uint256 _quoteAssetId) external view returns (PriceData memory) {\n        if (assetRegistry[_baseAssetId].id == 0) {\n            revert AssetNotFound(_baseAssetId);\n        }\n        if (assetRegistry[_quoteAssetId].id == 0) {\n            revert AssetNotFound(_quoteAssetId);\n        }\n\n        bytes32 pairId = _generatePairId(assetRegistry[_baseAssetId].symbol, assetRegistry[_quoteAssetId].symbol);\n        IGildiPriceResolver resolver = pairResolvers[pairId];\n        if (!pairExists[pairId]) {\n            revert InvalidPairId();\n        }\n\n        return resolver.getPrice(pairId);\n    }\n\n    /// @inheritdoc IGildiPriceResolver\n    function getPrice(bytes32 _pairId) external view override returns (PriceData memory) {\n        IGildiPriceResolver resolver = pairResolvers[_pairId];\n        if (!pairExists[_pairId]) {\n            revert InvalidPairId();\n        }\n\n        return resolver.getPrice(_pairId);\n    }\n\n    /// @inheritdoc IGildiPriceResolver\n    function getPriceNoOlderThan(bytes32 _pairId, uint256 _age) external view override returns (PriceData memory) {\n        IGildiPriceResolver resolver = pairResolvers[_pairId];\n        if (!pairExists[_pairId]) {\n            revert InvalidPairId();\n        }\n\n        return resolver.getPriceNoOlderThan(_pairId, _age);\n    }\n\n    /// @inheritdoc IGildiPriceOracle\n    function pairExistsById(bytes32 _pairId) external view override returns (bool) {\n        return pairExists[_pairId];\n    }\n}\n"
        },
        "contracts/oracles/price/providers/GildiPriceProvider.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '../../../interfaces/oracles/price/IGildiPriceResolver.sol';\nimport '../../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title Gildi Price Provider\n/// @notice Provides price data for asset pairs\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiPriceProvider is Initializable, IGildiPriceResolver, AccessControlUpgradeable {\n    bytes32 public constant PRICE_FEEDER_ROLE = keccak256('PRICE_FEEDER_ROLE');\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    /// @dev Mapping from pairId => PriceData\n    mapping(bytes32 => PriceData) private prices;\n    /// @dev Array of all pair IDs with price data\n    bytes32[] private pairIds;\n    /// @dev Reference to the Gildi price oracle contract\n    IGildiPriceOracle private oracle;\n\n    // Structs\n    struct PriceUpdate {\n        bytes32 pairId;\n        uint256 price;\n        uint8 decimals;\n    }\n\n    // Custom Errors\n    /// @dev Thrown when a non-price feeder attempts to set price data\n    error NotPriceFeeder();\n    /// @dev Thrown when an invalid price (zero) is provided\n    error InvalidPrice();\n    /// @dev Thrown when price data is not available for a requested pair\n    error PriceDataNotAvailable();\n    /// @dev Thrown when a pair is not found\n    error PairNotFound();\n    /// @dev Thrown when a price is older than the requested maximum age\n    error StalePrice();\n\n    // Events\n    /// @notice Emitted when a price is updated\n    /// @param pairId The pair ID\n    /// @param price The updated price\n    /// @param decimals The number of decimals for the price\n    /// @param timestamp The timestamp when the price was updated\n    event PriceUpdated(bytes32 indexed pairId, uint256 price, uint8 decimals, uint256 timestamp);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract and sets up roles\n    /// @param _defaultAdmin The address of the default admin\n    /// @param _contractAdmin The address of the contract admin\n    /// @param _oracle The address of the Gildi price oracle\n    function initialize(address _defaultAdmin, address _contractAdmin, IGildiPriceOracle _oracle) public initializer {\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        _grantRole(ADMIN_ROLE, _contractAdmin);\n        oracle = _oracle;\n    }\n\n    /// @notice Sets the price data for a given pair\n    /// @param _priceUpdate The price data to set\n    function setPriceData(PriceUpdate calldata _priceUpdate) external onlyRole(PRICE_FEEDER_ROLE) {\n        _setPriceData(_priceUpdate);\n    }\n\n    /// @notice Sets the price data for multiple pairs in a single transaction\n    /// @param _priceUpdates Array of price updates\n    function setPriceData(PriceUpdate[] calldata _priceUpdates) external onlyRole(PRICE_FEEDER_ROLE) {\n        for (uint256 i = 0; i < _priceUpdates.length; i++) {\n            _setPriceData(_priceUpdates[i]);\n        }\n    }\n\n    /// @notice Deletes the price data for a given pair\n    /// @param _pairId The pair ID\n    function deletePriceDataForPair(bytes32 _pairId) external onlyRole(ADMIN_ROLE) {\n        if (prices[_pairId].timestamp == 0) {\n            revert PairNotFound();\n        }\n\n        delete prices[_pairId];\n        for (uint256 i = 0; i < pairIds.length; i++) {\n            if (pairIds[i] == _pairId) {\n                pairIds[i] = pairIds[pairIds.length - 1];\n                pairIds.pop();\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IGildiPriceResolver\n    function getPrice(bytes32 _pairId) external view override returns (PriceData memory priceData) {\n        if (prices[_pairId].timestamp == 0) {\n            revert PriceDataNotAvailable();\n        }\n        return prices[_pairId];\n    }\n\n    /// @inheritdoc IGildiPriceResolver\n    function getPriceNoOlderThan(\n        bytes32 _pairId,\n        uint256 _age\n    ) external view override returns (PriceData memory priceData) {\n        if (prices[_pairId].timestamp == 0) {\n            revert PriceDataNotAvailable();\n        }\n        if (block.timestamp - prices[_pairId].timestamp > _age) {\n            revert StalePrice();\n        }\n        return prices[_pairId];\n    }\n\n    /// @notice Retrieves all pairs with price data\n    /// @return pairInfos An array of PairInfo structs\n    function getPairs() external view returns (IGildiPriceOracle.PairInfo[] memory) {\n        IGildiPriceOracle.PairInfo[] memory pairInfos = new IGildiPriceOracle.PairInfo[](pairIds.length);\n        IGildiPriceOracle.PairInfo[] memory allOraclePairs = oracle.getPairs();\n        for (uint256 i = 0; i < pairIds.length; i++) {\n            for (uint256 j = 0; j < allOraclePairs.length; j++) {\n                if (allOraclePairs[j].pairId == pairIds[i]) {\n                    pairInfos[i] = allOraclePairs[j];\n                    break;\n                }\n            }\n\n            if (pairInfos[i].pairId == 0) {\n                pairInfos[i] = IGildiPriceOracle.PairInfo(\n                    pairIds[i],\n                    IGildiPriceOracle.Asset(0, 'UNKNOWN', 'UNKNOWN'),\n                    IGildiPriceOracle.Asset(0, 'UNKNOWN', 'UNKNOWN')\n                );\n            }\n        }\n\n        return pairInfos;\n    }\n\n    /// @dev Internal function to set price data for a given pair\n    /// @param _priceUpdate The price data to set\n    function _setPriceData(PriceUpdate calldata _priceUpdate) internal {\n        if (_priceUpdate.price == 0) {\n            revert InvalidPrice();\n        }\n        if (!oracle.pairExistsById(_priceUpdate.pairId)) {\n            revert IGildiPriceOracle.InvalidPairId();\n        }\n\n        if (prices[_priceUpdate.pairId].timestamp == 0) {\n            pairIds.push(_priceUpdate.pairId);\n        }\n\n        prices[_priceUpdate.pairId] = PriceData(_priceUpdate.price, _priceUpdate.decimals, block.timestamp);\n        emit PriceUpdated(_priceUpdate.pairId, _priceUpdate.price, _priceUpdate.decimals, block.timestamp);\n    }\n}\n"
        },
        "contracts/oracles/price/resolvers/GildiPriceResolver.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '../../../interfaces/oracles/price/IGildiPriceResolver.sol';\nimport '../../../interfaces/oracles/price/IGildiPriceOracle.sol';\nimport '../providers/GildiPriceProvider.sol';\n\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n/// @title Gildi Price Resolver\n/// @notice Resolves prices using an external data source\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiPriceResolver is IGildiPriceResolver, Initializable, AccessControlUpgradeable {\n    /// @notice The external data source for price data (could be another contract or oracle)\n    GildiPriceProvider public dataSource;\n\n    // Custom Errors\n    /// @dev Thrown when the data source address is zero\n    error DataSourceAddressZero();\n    /// @dev Thrown when a pair is not found\n    error PairNotFound();\n    /// @dev Thrown when the oracle address is zero\n    error OracleAddressZero();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with the address of the external data source\n    /// @param _gildiPriceProvider The address of the external data source\n    /// @param _defaultAdmin The address of the default admin\n    function initialize(GildiPriceProvider _gildiPriceProvider, address _defaultAdmin) external initializer {\n        __AccessControl_init();\n\n        if (address(_gildiPriceProvider) == address(0)) {\n            revert DataSourceAddressZero();\n        }\n        dataSource = _gildiPriceProvider;\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n    }\n\n    /// @inheritdoc IGildiPriceResolver\n    function getPrice(bytes32 _pairId) external view override returns (PriceData memory priceData) {\n        return dataSource.getPrice(_pairId);\n    }\n\n    /// @inheritdoc IGildiPriceResolver\n    function getPriceNoOlderThan(\n        bytes32 _pairId,\n        uint256 _age\n    ) external view override returns (PriceData memory priceData) {\n        return dataSource.getPriceNoOlderThan(_pairId, _age);\n    }\n}\n"
        },
        "contracts/royalties/RoyaltyClaimStorage.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '../storage/AddressKeyValueStore.sol';\nimport './RoyaltyDistributionSharedStructs.sol';\n\n/// @title RoyaltyClaimStorage\n/// @notice A seperate contract to store the royalty claims.\n/// @dev Deployed by the Royalty Distributor. Might be switched to an off-chain solution in the future.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract RoyaltyClaimStorage is AddressKeyValueStore {\n    using RoyaltyDistributionSharedStructs for *;\n\n    constructor(uint256 distributionId) AddressKeyValueStore(_msgSender()) {\n        DISTRIBUTION_ID = distributionId;\n    }\n\n    /// @notice The ID of the Distribution.\n    uint256 immutable DISTRIBUTION_ID;\n\n    event ClaimDeleted(uint256 indexed releaseId, address indexed user);\n    event ClaimPushed(\n        uint256 indexed releaseId,\n        address indexed user,\n        address[] assets,\n        uint256[] values,\n        uint256 timestamp\n    );\n\n    /// @notice Sets a Claim for a user.\n    /// @param _user The user address.\n    /// @param _claim The new claim entry.\n    function setClaim(address _user, RoyaltyDistributionSharedStructs.Claim calldata _claim) external {\n        // Check if the user already has claims\n        set(_user, claimToBytes(_claim));\n\n        address[] memory assets = new address[](_claim.assetValues.length);\n        uint256[] memory values = new uint256[](_claim.assetValues.length);\n        for (uint256 i = 0; i < _claim.assetValues.length; i++) {\n            assets[i] = _claim.assetValues[i].assetAddress;\n            values[i] = _claim.assetValues[i].amount;\n        }\n\n        emit ClaimPushed(DISTRIBUTION_ID, _user, assets, values, block.timestamp);\n    }\n\n    /// @notice Checks if a user has a claim.\n    /// @param _user The user address.\n    /// @return Whether the user has a claim or not.\n    function hasClaim(address _user) external view returns (bool) {\n        return containsKey(_user);\n    }\n\n    /// @notice Fetch the claim of a user.\n    /// @param _user The user address.\n    /// @return The claim of the user.\n    function fetchClaim(address _user) external view returns (RoyaltyDistributionSharedStructs.Claim memory) {\n        bytes memory claimData = get(_user);\n        return bytesToClaim(claimData);\n    }\n\n    /// @notice Fetch all claims.\n    /// @return All claims.\n    function fetchAllClaims() external view returns (RoyaltyDistributionSharedStructs.Claim[] memory) {\n        RoyaltyDistributionSharedStructs.Claim[] memory claims = new RoyaltyDistributionSharedStructs.Claim[](\n            getNumberOfKeys()\n        );\n\n        bytes[] memory allData = getAll();\n        for (uint256 i = 0; i < allData.length; i++) {\n            claims[i] = bytesToClaim(allData[i]);\n        }\n\n        return claims;\n    }\n\n    /// @notice Fetch the users.\n    function fetchUsers() external view returns (address[] memory) {\n        return getAllKeys();\n    }\n\n    function claimToBytes(RoyaltyDistributionSharedStructs.Claim memory _claim) private pure returns (bytes memory) {\n        return abi.encode(_claim);\n    }\n\n    function bytesToClaim(bytes memory _data) private pure returns (RoyaltyDistributionSharedStructs.Claim memory) {\n        RoyaltyDistributionSharedStructs.Claim memory res = abi.decode(_data, (RoyaltyDistributionSharedStructs.Claim));\n        return res;\n    }\n}\n"
        },
        "contracts/royalties/RoyaltyDistributionSharedStructs.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\n/// @title RoyaltyDistributionSharedStructs\n/// @notice Library for shared structs used in the Royalty Distribution.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\nlibrary RoyaltyDistributionSharedStructs {\n    /// @notice A struct representing an asset value.\n    struct AssetValue {\n        /// @notice The address of the asset.\n        address assetAddress;\n        /// @notice The amount of the asset.\n        uint256 amount;\n    }\n\n    /// @notice A struct representing a royalty claim.\n    struct Claim {\n        /// @notice The ID of the distribution.\n        uint256 distributionId;\n        /// @notice The address of the user.\n        address user;\n        /// @notice The asset values.\n        AssetValue[] assetValues;\n        /// @notice The shares of the user the values are based on.\n        uint256 userShares;\n        /// @notice The date and time when the claim was created.\n        uint256 createdAt;\n        /// @notice The claim was claimed (paid out).\n        bool claimed;\n    }\n}\n"
        },
        "contracts/royalties/RoyaltyDistributor.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\n\npragma solidity 0.8.24;\n\nimport '../interfaces/manager/IGildiManager.sol';\nimport './RoyaltyDistributionSharedStructs.sol';\nimport './RoyaltyClaimStorage.sol';\n\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\n/// @title RoyaltyDistributor\n/// @notice A contract to distribute royalties in different currencies to users.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract RoyaltyDistributor is Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant ROYALTY_MANAGER_ROLE = keccak256('ROYALTY_MANAGER_ROLE');\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    /// @notice The Gildi Manager.\n    IGildiManager private gildiManager;\n    /// @notice The current distribution ID.\n    uint256 private currentDistributionId;\n\n    // All distributions and distributions to release mappings.\n    mapping(uint256 => Distribution) private distributions;\n    mapping(uint256 => uint256[]) private distributionsByReleaseId;\n    uint256[] private distributionIds;\n    uint256[] private releaseIds;\n\n    // Allowed assets we can generate distributions for.\n    mapping(address => bool) private allowedAssets;\n    address[] private allowedAssetsArray;\n\n    /// Storage where the claims are stored on a release ID basis, deployed for each distribution by the Royal Distributor smart contract.\n    mapping(uint256 => RoyaltyClaimStorage) public royaltyClaimStorages;\n\n    // Tracking of distribution claims.\n    mapping(address => uint256[]) private userClaimDistributionIds;\n    mapping(uint256 => address[]) private distributionClaimUsers;\n\n    // Tracking of distribution shares. Only used temporarily for the calculation of the claims.\n    mapping(uint256 => DistributionShares) private distributionShares;\n\n    struct Distribution {\n        /// @notice An internal ID for the distribution.\n        uint256 distributionId;\n        /// @notice The ID of the release.\n        uint256 rwaReleaseId;\n        /// @notice The start of the time period for the distribution.\n        uint256 start;\n        /// @notice The end of the time period for the distribution.\n        uint256 end;\n        /// @notice The date and time until the distribution must be claimed. = 0 forever\n        uint256 claimableUntil;\n        /// @notice The royalty amounts.\n        RoyaltyDistributionSharedStructs.AssetValue[] royaltiesToPayout;\n        /// @notice From ownership mapping calculated amounts.\n        RoyaltyDistributionSharedStructs.AssetValue[] calculatedRoyaltiesToPayout;\n        /// @notice The amounts distributed.\n        RoyaltyDistributionSharedStructs.AssetValue[] amountsDistributed;\n        /// @notice The total number of shares.\n        uint256 totalShares;\n        /// @notice Whether or not all shares are assigned. (needs to be true to init claims)\n        bool allSharesAssigned;\n        /// @notice Whether or not all claims are assigned. (needs to be true to prime the distribution)\n        bool allClaimsAssigned;\n        /// @notice Whether or not the distribution is primed. (needs to be true to activate the distribution)\n        bool primed;\n        /// @notice Whether or not the distribution is active.\n        bool active;\n        /// @notice Whether or not the distribution is cancelled.\n        bool cancelled;\n        /// @notice The date and time when the distribution was created.\n        uint256 createdAt;\n    }\n\n    event DistributionCreated(\n        uint256 indexed distributionId,\n        uint256 indexed rwaReleaseId,\n        uint256 start,\n        uint256 end,\n        uint256 claimUntil,\n        uint256 createdAt\n    );\n\n    struct DistributionShares {\n        uint256 totalNumberOfShares;\n        IGildiManager.UserShare[] userShares;\n        uint256 sharesReportNextCursor;\n        uint256 userSharesNextIndex;\n    }\n\n    event AssetAllowed(address indexed assetAddress, bool allowed);\n    event AssetTopUp(address indexed assetAddress, uint256 amount);\n    event AssetEmergencyWithdraw(address indexed assetAddress, address indexed to, uint256 amount);\n    event ClaimPeriodSet(uint256 indexed distributionId, uint256 claimUntil);\n    event DistributionSharesInitialised(uint256 indexed distributionId, uint256 batchSize, bool hasMore);\n    event ClaimAssigned(uint256 indexed distributionId, address indexed user, address[] tokens, uint256[] amounts);\n    event DistributionClaimsInitialised(uint256 indexed distributionId, uint256 batchSize, bool allClaimsAssigned);\n    event DistributionPrimed(uint256 indexed distributionId);\n    event DistributionActivated(uint256 indexed distributionId);\n    event DistributionClaimed(\n        uint256 indexed distributionId,\n        address indexed user,\n        address[] tokens,\n        uint256[] amounts\n    );\n    event AssetTransfer(address indexed assetAddress, address indexed from, address indexed to, uint256 amount);\n    event DistributionCancelled(uint256 indexed distributionId);\n\n    error DistributionDoesNotExist();\n    error ReleaseDoesNotExist();\n    error ReleaseSharesNotFullyAssigned();\n    error ClaimPeriodOver();\n    error AssetNotAllowed(address assetAddress);\n    error InvalidAssetAmount(address assetAddress);\n    error DistributionAssetsNotUnique(address assetAddress);\n    error SharesAlreadyAssigned();\n    error SharesNotAssigned();\n    error DistributionIsCancelled();\n    error ClaimsAlreadyAssigned();\n    error ClaimsNotAssigned();\n    error InsufficientFundsSent();\n    error DistributionAlreadyPrimed();\n    error InsufficientMessageValue();\n    error DistributionNotPrimed();\n    error DistributionAlreadyActive();\n    error DistributionIsActive();\n    error DistributionNotActive();\n    error ClaimDoesNotExist();\n    error ClaimAlreadyClaimed();\n    error DistributionNotClaimable();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _defaultAdmin The default admin.\n    /// @param _initialAdmin The initial admin.\n    /// @param _initialRoyaltyManager The initial royalty manager.\n    /// @param _gildiManager The Gildi Manager.\n    function initialize(\n        address _defaultAdmin,\n        address _initialAdmin,\n        address _initialRoyaltyManager,\n        IGildiManager _gildiManager\n    ) public initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        if (_initialAdmin != address(0)) {\n            _grantRole(ADMIN_ROLE, _initialAdmin);\n        }\n        if (_initialRoyaltyManager != address(0)) {\n            _grantRole(ROYALTY_MANAGER_ROLE, _initialRoyaltyManager);\n        }\n\n        gildiManager = _gildiManager;\n        currentDistributionId = 1;\n    }\n\n    function isUserClaimable(uint256 _distributionId, address _user) public view returns (bool) {\n        if (!distributionExists(_distributionId)) {\n            return false;\n        }\n        Distribution storage distribution = distributions[_distributionId];\n\n        if (!distribution.active) {\n            return false;\n        }\n\n        if (distribution.cancelled) {\n            return false;\n        }\n\n        if (distribution.claimableUntil != 0 && block.timestamp > distribution.claimableUntil) {\n            return false;\n        }\n\n        RoyaltyClaimStorage royaltyClaimStorage = royaltyClaimStorages[_distributionId];\n        RoyaltyDistributionSharedStructs.Claim memory userClaim;\n        if (royaltyClaimStorage.hasClaim(_user)) {\n            userClaim = royaltyClaimStorage.fetchClaim(_user);\n        }\n\n        if (userClaim.createdAt == 0) {\n            return false;\n        }\n\n        if (userClaim.claimed) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function distributionExists(uint256 _distributionId) public view returns (bool) {\n        return distributions[_distributionId].createdAt > 0;\n    }\n\n    function isAllowedAsset(address _assetAddress) public view returns (bool) {\n        return allowedAssets[_assetAddress];\n    }\n\n    /// @notice Creates a new distribution.\n    /// @param _rwaReleaseId The ID of the RWA release.\n    /// @param _start The start of the time period.\n    /// @param _end The end of the time period.\n    /// @param _claimableUntil The date and time until the distribution must be claimed.\n    /// @param _distributionAmounts The distribution amounts.\n    function createDistribution(\n        uint256 _rwaReleaseId,\n        uint256 _start,\n        uint256 _end,\n        uint256 _claimableUntil,\n        RoyaltyDistributionSharedStructs.AssetValue[] calldata _distributionAmounts\n    ) external onlyRole(ROYALTY_MANAGER_ROLE) {\n        if (!gildiManager.releaseExists(_rwaReleaseId)) {\n            revert ReleaseDoesNotExist();\n        }\n        if (_claimableUntil != 0 && _claimableUntil < block.timestamp) {\n            revert ClaimPeriodOver();\n        }\n        for (uint256 i = 0; i < _distributionAmounts.length; i++) {\n            if (!isAllowedAsset(_distributionAmounts[i].assetAddress)) {\n                revert AssetNotAllowed(_distributionAmounts[i].assetAddress);\n            }\n\n            if (_distributionAmounts[i].amount == 0) {\n                revert InvalidAssetAmount(_distributionAmounts[i].assetAddress);\n            }\n        }\n\n        for (uint256 i = 0; i < _distributionAmounts.length; i++) {\n            for (uint256 j = i + 1; j < _distributionAmounts.length; j++) {\n                if (_distributionAmounts[i].assetAddress == _distributionAmounts[j].assetAddress) {\n                    revert DistributionAssetsNotUnique(_distributionAmounts[i].assetAddress);\n                }\n            }\n        }\n\n        Distribution storage newDistribution = distributions[currentDistributionId];\n        newDistribution.distributionId = currentDistributionId++;\n        newDistribution.rwaReleaseId = _rwaReleaseId;\n        newDistribution.start = _start;\n        newDistribution.end = _end;\n        newDistribution.claimableUntil = _claimableUntil;\n        newDistribution.royaltiesToPayout = _distributionAmounts;\n        newDistribution.createdAt = block.timestamp;\n        newDistribution.calculatedRoyaltiesToPayout = new RoyaltyDistributionSharedStructs.AssetValue[](\n            _distributionAmounts.length\n        );\n        newDistribution.amountsDistributed = new RoyaltyDistributionSharedStructs.AssetValue[](\n            _distributionAmounts.length\n        );\n\n        for (uint256 i = 0; i < _distributionAmounts.length; i++) {\n            newDistribution.calculatedRoyaltiesToPayout[i] = RoyaltyDistributionSharedStructs.AssetValue(\n                _distributionAmounts[i].assetAddress,\n                0\n            );\n            newDistribution.amountsDistributed[i] = RoyaltyDistributionSharedStructs.AssetValue(\n                _distributionAmounts[i].assetAddress,\n                0\n            );\n        }\n\n        royaltyClaimStorages[newDistribution.distributionId] = new RoyaltyClaimStorage(newDistribution.distributionId);\n\n        if (distributionsByReleaseId[_rwaReleaseId].length == 0) {\n            releaseIds.push(_rwaReleaseId);\n        }\n        distributionsByReleaseId[_rwaReleaseId].push(newDistribution.distributionId);\n        distributionIds.push(newDistribution.distributionId);\n\n        emit DistributionCreated(\n            newDistribution.distributionId,\n            newDistribution.rwaReleaseId,\n            newDistribution.start,\n            newDistribution.end,\n            newDistribution.claimableUntil,\n            newDistribution.createdAt\n        );\n    }\n\n    /// @notice Gets the shares report batched and assigns the total number of shares to the distribution struct. Also assigns the user shares to a temporary storage.\n    /// @param distributionId The distribution ID.\n    /// @param batchSize The batch size.\n    function initDistributionSharesBatched(\n        uint256 distributionId,\n        uint256 batchSize\n    ) external onlyRole(ROYALTY_MANAGER_ROLE) {\n        if (!distributionExists(distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n        Distribution storage distribution = distributions[distributionId];\n\n        if (!gildiManager.isFullyAssigned(distribution.rwaReleaseId)) {\n            revert ReleaseSharesNotFullyAssigned();\n        }\n\n        if (distribution.cancelled) {\n            revert DistributionIsCancelled();\n        }\n\n        if (distribution.allSharesAssigned) {\n            revert SharesAlreadyAssigned();\n        }\n\n        DistributionShares storage distributionSharesTracking = distributionShares[distributionId];\n\n        IGildiManager.SharesReport memory sharesReport = gildiManager.fetchSharesInPeriod(\n            distribution.rwaReleaseId,\n            distribution.start,\n            distribution.end,\n            distributionSharesTracking.sharesReportNextCursor,\n            batchSize\n        );\n\n        distributionSharesTracking.sharesReportNextCursor = sharesReport.nextCursor;\n        for (uint256 i = 0; i < sharesReport.userShares.length; i++) {\n            distributionSharesTracking.userShares.push(sharesReport.userShares[i]);\n        }\n\n        if (!sharesReport.hasMore) {\n            distribution.allSharesAssigned = true;\n        }\n        distributionSharesTracking.totalNumberOfShares += sharesReport.totalNumberOfShares;\n\n        emit DistributionSharesInitialised(distributionId, batchSize, sharesReport.hasMore);\n    }\n\n    /// @notice Calculates the claims and value needed for the distribution batched.\n    /// @param distributionId The distribution ID.\n    /// @param batchSize The batch size.\n    function initClaimsBatched(uint256 distributionId, uint256 batchSize) external onlyRole(ROYALTY_MANAGER_ROLE) {\n        if (!distributionExists(distributionId)) {}\n        Distribution storage distribution = distributions[distributionId];\n\n        if (distribution.cancelled) {\n            revert DistributionIsCancelled();\n        }\n\n        if (!distribution.allSharesAssigned) {\n            revert SharesNotAssigned();\n        }\n\n        if (distribution.allClaimsAssigned) {\n            revert ClaimsAlreadyAssigned();\n        }\n\n        DistributionShares storage distributionSharesTracking = distributionShares[distributionId];\n        RoyaltyClaimStorage royaltyClaimStorage = royaltyClaimStorages[distributionId];\n\n        uint256 count = 0;\n        for (\n            uint256 i = distributionSharesTracking.userSharesNextIndex;\n            i < distributionSharesTracking.userShares.length;\n            i++\n        ) {\n            if (count >= batchSize) {\n                break;\n            }\n\n            // Calculate the claims.\n            IGildiManager.UserShare memory userShare = distributionSharesTracking.userShares[i];\n            address user = userShare.user;\n            uint256 shareAmount = userShare.shares;\n\n            RoyaltyDistributionSharedStructs.Claim memory userClaim = RoyaltyDistributionSharedStructs.Claim(\n                distributionId,\n                user,\n                new RoyaltyDistributionSharedStructs.AssetValue[](distribution.royaltiesToPayout.length),\n                shareAmount,\n                block.timestamp,\n                false\n            );\n\n            address[] memory tokens = new address[](distribution.royaltiesToPayout.length);\n            uint256[] memory amounts = new uint256[](distribution.royaltiesToPayout.length);\n\n            for (uint256 j = 0; j < distribution.royaltiesToPayout.length; j++) {\n                uint256 amount = (distribution.royaltiesToPayout[j].amount * shareAmount) /\n                    distributionSharesTracking.totalNumberOfShares;\n                userClaim.assetValues[j] = RoyaltyDistributionSharedStructs.AssetValue(\n                    distribution.royaltiesToPayout[j].assetAddress,\n                    amount\n                );\n\n                distribution.calculatedRoyaltiesToPayout[j].amount += amount;\n\n                tokens[j] = distribution.royaltiesToPayout[j].assetAddress;\n                amounts[j] = amount;\n            }\n\n            royaltyClaimStorage.setClaim(user, userClaim);\n            userClaimDistributionIds[user].push(distributionId);\n            distributionClaimUsers[distributionId].push(user);\n\n            count++;\n            distributionSharesTracking.userSharesNextIndex++;\n\n            emit ClaimAssigned(distributionId, user, tokens, amounts);\n        }\n\n        if (distributionSharesTracking.userSharesNextIndex >= distributionSharesTracking.userShares.length) {\n            distribution.allClaimsAssigned = true;\n            distribution.totalShares = distributionSharesTracking.totalNumberOfShares;\n            delete distributionShares[distributionId];\n        }\n\n        emit DistributionClaimsInitialised(distributionId, batchSize, distribution.allClaimsAssigned);\n    }\n\n    function primeDistribution(uint256 _distributionId, address _fundsSource) external onlyRole(ROYALTY_MANAGER_ROLE) {\n        if (!distributionExists(_distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n\n        if (_fundsSource == address(0)) {\n            _fundsSource = _msgSender();\n        }\n\n        Distribution storage distribution = distributions[_distributionId];\n\n        if (distribution.cancelled) {\n            revert DistributionIsCancelled();\n        }\n\n        if (!distribution.allClaimsAssigned) {\n            revert ClaimsNotAssigned();\n        }\n\n        if (distribution.primed) {\n            revert DistributionAlreadyPrimed();\n        }\n\n        // transfer funds to the contract\n        for (uint256 i = 0; i < distribution.calculatedRoyaltiesToPayout.length; i++) {\n            RoyaltyDistributionSharedStructs.AssetValue memory totalAmount = distribution.calculatedRoyaltiesToPayout[\n                i\n            ];\n\n            _transferAsset(totalAmount.assetAddress, _fundsSource, address(this), totalAmount.amount);\n        }\n\n        distribution.primed = true;\n        emit DistributionPrimed(_distributionId);\n    }\n\n    function activateDistribution(uint256 _distributionId) external onlyRole(ROYALTY_MANAGER_ROLE) {\n        if (!distributionExists(_distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n        Distribution storage distribution = distributions[_distributionId];\n\n        if (distribution.cancelled) {\n            revert DistributionIsCancelled();\n        }\n\n        if (!distribution.primed) {\n            revert DistributionNotPrimed();\n        }\n\n        if (distribution.active) {\n            revert DistributionAlreadyActive();\n        }\n\n        distribution.active = true;\n\n        emit DistributionActivated(_distributionId);\n    }\n\n    function cancelDistribution(\n        uint256 _distributionId,\n        address _unclaimedAmountReceiver\n    ) external onlyRole(ADMIN_ROLE) {\n        if (_unclaimedAmountReceiver == address(0)) {\n            _unclaimedAmountReceiver = _msgSender();\n        }\n        _cancelAndWithdrawDistribution(_distributionId, _unclaimedAmountReceiver);\n    }\n\n    function claim(uint256 _distributionId) external nonReentrant {\n        if (!isUserClaimable(_distributionId, _msgSender())) {\n            revert DistributionNotClaimable();\n        }\n\n        _claimDistribution(_msgSender(), _distributionId);\n    }\n\n    function claimAllByReleaseId(uint256 _rwaReleaseId) external nonReentrant {\n        for (uint256 i = 0; i < distributionsByReleaseId[_rwaReleaseId].length; i++) {\n            uint256 distributionId = distributionsByReleaseId[_rwaReleaseId][i];\n            if (isUserClaimable(distributionId, _msgSender())) {\n                _claimDistribution(_msgSender(), distributionId);\n            }\n        }\n    }\n\n    function claimAll() external nonReentrant {\n        for (uint256 i = 0; i < userClaimDistributionIds[_msgSender()].length; i++) {\n            uint256 distributionId = userClaimDistributionIds[_msgSender()][i];\n            if (isUserClaimable(distributionId, _msgSender())) {\n                _claimDistribution(_msgSender(), distributionId);\n            }\n        }\n    }\n\n    function withdrawAsset(address _assetAddress, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {\n        _transferAsset(_assetAddress, address(this), _to, _amount);\n\n        emit AssetEmergencyWithdraw(_assetAddress, _to, _amount);\n    }\n\n    function topUpAsset(address _assetAddress, uint256 _amount) external payable onlyRole(ADMIN_ROLE) {\n        _transferAsset(_assetAddress, _msgSender(), address(this), _amount);\n\n        emit AssetTopUp(_assetAddress, _amount);\n    }\n\n    function fetchDistributionById(uint256 _distributionId) external view returns (Distribution memory) {\n        if (!distributionExists(_distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n        return distributions[_distributionId];\n    }\n\n    function fetchDistributionClaims(\n        uint256 _distributionId\n    ) external view returns (RoyaltyDistributionSharedStructs.Claim[] memory) {\n        if (!distributionExists(_distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n        return royaltyClaimStorages[_distributionId].fetchAllClaims();\n    }\n\n    function fetchUserClaimsByReleaseId(\n        uint256 _rwaReleaseId,\n        address _userId\n    ) external view returns (RoyaltyDistributionSharedStructs.Claim[] memory) {\n        RoyaltyDistributionSharedStructs.Claim[] memory tempClaims = new RoyaltyDistributionSharedStructs.Claim[](\n            distributionsByReleaseId[_rwaReleaseId].length\n        );\n        uint256 count = 0;\n        for (uint256 i = 0; i < distributionsByReleaseId[_rwaReleaseId].length; i++) {\n            uint256 distributionId = distributionsByReleaseId[_rwaReleaseId][i];\n            RoyaltyClaimStorage royaltyClaimStorage = royaltyClaimStorages[distributionId];\n\n            RoyaltyDistributionSharedStructs.Claim memory userClaim;\n            if (royaltyClaimStorage.hasClaim(_userId)) {\n                userClaim = royaltyClaimStorage.fetchClaim(_userId);\n            }\n            if (userClaim.createdAt > 0) {\n                tempClaims[count++] = userClaim;\n            }\n        }\n\n        RoyaltyDistributionSharedStructs.Claim[] memory res = new RoyaltyDistributionSharedStructs.Claim[](count);\n        for (uint256 i = 0; i < count; i++) {\n            res[i] = tempClaims[i];\n        }\n\n        return res;\n    }\n\n    function fetchDistributionsByReleaseId(uint256 _rwaReleaseId) external view returns (Distribution[] memory) {\n        Distribution[] memory res = new Distribution[](distributionsByReleaseId[_rwaReleaseId].length);\n        for (uint256 i = 0; i < distributionsByReleaseId[_rwaReleaseId].length; i++) {\n            res[i] = distributions[distributionsByReleaseId[_rwaReleaseId][i]];\n        }\n        return res;\n    }\n\n    function fetchReleaseIdByDistributionId(uint256 _distributionId) external view returns (uint256) {\n        if (!distributionExists(_distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n        return distributions[_distributionId].rwaReleaseId;\n    }\n\n    function fetchAllowedAssets() external view returns (address[] memory) {\n        return allowedAssetsArray;\n    }\n\n    function setAssetAllowed(address _assetAddress, bool _allowed) external onlyRole(ADMIN_ROLE) {\n        if (_assetAddress == address(0)) {\n            revert AssetNotAllowed(_assetAddress);\n        }\n\n        allowedAssets[_assetAddress] = _allowed;\n        if (_allowed) {\n            allowedAssetsArray.push(_assetAddress);\n        } else {\n            for (uint256 i = 0; i < allowedAssetsArray.length; i++) {\n                if (allowedAssetsArray[i] == _assetAddress) {\n                    allowedAssetsArray[i] = allowedAssetsArray[allowedAssetsArray.length - 1];\n                    allowedAssetsArray.pop();\n                    break;\n                }\n            }\n        }\n\n        emit AssetAllowed(_assetAddress, _allowed);\n    }\n\n    function _cancelAndWithdrawAllDistributionsOfRelease(\n        uint256 _rwaReleaseId,\n        address _unclaimedAmountReceiver\n    ) private {\n        uint256[] memory distributionIdsCopy = distributionsByReleaseId[_rwaReleaseId];\n        for (uint256 i = 0; i < distributionIdsCopy.length; i++) {\n            _cancelAndWithdrawDistribution(distributionIdsCopy[i], _unclaimedAmountReceiver);\n        }\n    }\n\n    function _cancelAndWithdrawDistribution(uint256 _distributionId, address _unclaimedAmountReceiver) private {\n        if (!distributionExists(_distributionId)) {\n            revert DistributionDoesNotExist();\n        }\n        Distribution storage distribution = distributions[_distributionId];\n\n        if (distribution.active && block.timestamp < distribution.end) {\n            revert DistributionIsActive();\n        }\n\n        if (distribution.cancelled) {\n            revert DistributionIsCancelled();\n        }\n\n        distribution.active = false;\n        distribution.cancelled = true;\n\n        if (distribution.primed) {\n            for (uint256 i = 0; i < distribution.calculatedRoyaltiesToPayout.length; i++) {\n                address assetAddress = distribution.calculatedRoyaltiesToPayout[i].assetAddress;\n                uint256 unclaimedAmount = distribution.calculatedRoyaltiesToPayout[i].amount -\n                    distribution.amountsDistributed[i].amount;\n\n                _transferAsset(assetAddress, address(this), _unclaimedAmountReceiver, unclaimedAmount);\n            }\n        }\n\n        delete distributionShares[_distributionId];\n\n        for (uint256 i = 0; i < distributionClaimUsers[_distributionId].length; i++) {\n            address user = distributionClaimUsers[_distributionId][i];\n            for (uint256 j = 0; j < userClaimDistributionIds[user].length; j++) {\n                if (userClaimDistributionIds[user][j] == _distributionId) {\n                    userClaimDistributionIds[user][j] = userClaimDistributionIds[user][\n                        userClaimDistributionIds[user].length - 1\n                    ];\n                    userClaimDistributionIds[user].pop();\n                    break;\n                }\n            }\n        }\n\n        delete distributionClaimUsers[_distributionId];\n\n        emit DistributionCancelled(_distributionId);\n    }\n\n    function _transferAsset(address _assetAddress, address _from, address _to, uint256 _amount) private {\n        if (_amount == 0) {\n            return;\n        }\n\n        IERC20 asset = IERC20(_assetAddress);\n        if (_from == address(this)) {\n            asset.safeTransfer(_to, _amount);\n        } else {\n            asset.safeTransferFrom(_from, _to, _amount);\n        }\n\n        emit AssetTransfer(_assetAddress, _from, _to, _amount);\n    }\n\n    function _claimDistribution(address _user, uint256 _distributionId) private {\n        if (!isUserClaimable(_distributionId, _user)) {\n            return;\n        }\n\n        RoyaltyClaimStorage royaltyClaimStorage = royaltyClaimStorages[_distributionId];\n        RoyaltyDistributionSharedStructs.Claim memory userClaim = royaltyClaimStorage.fetchClaim(_user);\n\n        Distribution storage distribution = distributions[_distributionId];\n\n        address[] memory assetAddresses = new address[](userClaim.assetValues.length);\n        uint256[] memory amounts = new uint256[](userClaim.assetValues.length);\n        for (uint256 i = 0; i < userClaim.assetValues.length; i++) {\n            RoyaltyDistributionSharedStructs.AssetValue memory assetValue = userClaim.assetValues[i];\n            if (assetValue.amount > 0) {\n                _transferAsset(assetValue.assetAddress, address(this), _user, assetValue.amount);\n            }\n\n            distribution.amountsDistributed[i].amount += assetValue.amount;\n\n            assetAddresses[i] = assetValue.assetAddress;\n            amounts[i] = assetValue.amount;\n        }\n\n        userClaim.claimed = true;\n        royaltyClaimStorage.setClaim(_user, userClaim);\n\n        emit DistributionClaimed(_distributionId, _user, assetAddresses, amounts);\n    }\n}\n"
        },
        "contracts/storage/AddressKeyValueStore.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport './base/KeyValueStore.sol';\n\n/// @title Address key value store contract.\n/// @notice This contract allows an owner to store, retrieve, and delete arbitrary data by an address key.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract AddressKeyValueStore is KeyValueStore {\n    constructor(address _owner) KeyValueStore(_owner) {}\n\n    /// @notice Gets the data stored against the given key.\n    /// @param _key The key to get the data for.\n    /// @return The data stored against the given key.\n    function get(address _key) internal view returns (bytes memory) {\n        return _get(addressToBytes32(_key));\n    }\n\n    /// notice Gets the key at the given index.\n    /// @param _index The index of the key to get.\n    /// @return The key at the given index.\n    function getKeyAtIndex(uint256 _index) internal view returns (address) {\n        return bytes32ToAddress(_getKeyAtIndex(_index));\n    }\n\n    /// @notice Gets all the data stored in the store.\n    /// @return All the data stored in the store.\n    function getAll() internal view returns (bytes[] memory) {\n        return _getAll();\n    }\n\n    /// @notice Gets all the keys used in the store.\n    /// @return All the keys used in the store.\n    function getAllKeys() internal view returns (address[] memory) {\n        bytes32[] memory keys = _getAllKeys();\n        address[] memory addressKeys = new address[](keys.length);\n        for (uint256 i = 0; i < keys.length; i++) {\n            addressKeys[i] = bytes32ToAddress(keys[i]);\n        }\n        return addressKeys;\n    }\n\n    /// @notice Gets the number of keys used in the store.\n    /// @return The number of keys used in the store.\n    function getNumberOfKeys() internal view returns (uint256) {\n        return _getNumberOfKeys();\n    }\n\n    /// @notice Checks if the given key exists in the store.\n    /// @param _key The key to check for existence.\n    function containsKey(address _key) internal view returns (bool) {\n        return _containsKey(addressToBytes32(_key));\n    }\n\n    /// @notice Sets the given value against the given key.\n    function set(address _key, bytes memory _value) internal {\n        _set(addressToBytes32(_key), _value);\n    }\n\n    /// @notice Deletes the data stored against the given key.\n    function del(address _key) internal {\n        _del(addressToBytes32(_key));\n    }\n\n    /// @inheritdoc KeyValueStore\n    function _initialize() internal virtual override initializeOnlyOnce {}\n\n    function bytes32ToAddress(bytes32 byteData) private pure returns (address) {\n        return address(uint160(uint256(byteData)));\n    }\n\n    function addressToBytes32(address addr) private pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n}\n"
        },
        "contracts/storage/base/KeyValueStore.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @title Store base contract.\n/// @notice This contract allows an owner to store, retrieve, and delete arbitrary data by an arbitrary key.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\nabstract contract KeyValueStore is Ownable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// @notice Mapping that holds the stored data against their keys.\n    mapping(bytes32 => bytes) internal data;\n\n    /// @notice Set that keeps track of all keys used.\n    EnumerableSet.Bytes32Set internal keys;\n\n    /// @notice Whether the store has been initialized or not.\n    bool private _initialized;\n\n    /// @notice Emitted when data is added to the store.\n    event DataAdded(bytes32 key);\n\n    /// @notice Emitted when data is updated in the store.\n    event DataUpdated(bytes32 key);\n\n    /// @notice Emitted when data is deleted from the store.\n    event DataDeleted(bytes32 key);\n\n    /// @notice Emitted when the store is already initialized.\n    error AlreadyInitialized();\n\n    /// @notice Emitted when the key does not exist in the store.\n    error KeyNotExists(bytes32 key);\n\n    /// @notice Emitted when the index is out of bounds.\n    error IndexOutOfBounds(uint256 index);\n\n    /// @dev Initializes a new instance of the Store contract with the given owner.\n    /// @param _owner The address of the owner of the Store contract.\n    constructor(address _owner) Ownable(_owner) {\n        _initialize();\n    }\n\n    /// @notice Gets the data stored against the given key.\n    /// @param _key The key to get the data for.\n    /// @return The data stored against the given key.\n    function _get(bytes32 _key) internal view returns (bytes memory) {\n        if (!keys.contains(_key)) {\n            revert KeyNotExists(_key);\n        }\n        return data[_key];\n    }\n\n    /// notice Gets the key at the given index.\n    /// @param _index The index of the key to get.\n    /// @return The key at the given index.\n    function _getKeyAtIndex(uint256 _index) internal view returns (bytes32) {\n        if (_index >= keys.length()) {\n            revert IndexOutOfBounds(_index);\n        }\n        return keys.at(_index);\n    }\n\n    /// @notice Gets all the data stored in the store.\n    /// @return All the data stored in the store.\n    function _getAll() internal view returns (bytes[] memory) {\n        uint256 length = keys.length();\n        bytes[] memory result = new bytes[](length);\n        for (uint256 i = 0; i < length; i++) {\n            result[i] = data[keys.at(i)];\n        }\n        return result;\n    }\n\n    /// @notice Gets all the keys used in the store.\n    /// @return All the keys used in the store.\n    function _getAllKeys() internal view returns (bytes32[] memory) {\n        return keys.values();\n    }\n\n    /// @notice Gets the number of keys used in the store.\n    /// @return The number of keys used in the store.\n    function _getNumberOfKeys() internal view returns (uint256) {\n        return keys.length();\n    }\n\n    /// @notice Checks if the given key exists in the store.\n    /// @param _key The key to check for existence.\n    function _containsKey(bytes32 _key) internal view returns (bool) {\n        return keys.contains(_key);\n    }\n\n    /// @notice Sets the given value against the given key.\n    function _set(bytes32 _key, bytes memory _value) internal onlyOwner {\n        bool isNewKey = !keys.contains(_key);\n        if (isNewKey) {\n            keys.add(_key);\n            emit DataAdded(_key);\n        } else {\n            emit DataUpdated(_key);\n        }\n        data[_key] = _value;\n    }\n\n    /// @notice Deletes the data stored against the given key.\n    function _del(bytes32 _key) internal onlyOwner {\n        if (!keys.contains(_key)) {\n            revert KeyNotExists(_key);\n        }\n        keys.remove(_key);\n        delete data[_key];\n        emit DataDeleted(_key);\n    }\n\n    /// @notice Initializes the store.\n    /// @dev This function is called only once during the contract deployment.\n    function _initialize() internal virtual initializeOnlyOnce {}\n\n    // Modifier to make it impossible to call initialize twice\n    modifier initializeOnlyOnce() {\n        if (_initialized) {\n            revert AlreadyInitialized();\n        }\n        _;\n        _initialized = true;\n    }\n}\n"
        },
        "contracts/token/GildiShareToken.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableMap.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nimport '../interfaces/token/IGildiToken.sol';\n\n/// @title Gilde Company Share Token\n/// @notice ERC1155 token that represents company shares.\n/// @custom:security-contact security@gildi.io\n/// @author Patrick Fischer (Pathin) > https://pathin.me\ncontract GildiShareToken is\n    Initializable,\n    ERC1155Upgradeable,\n    AccessControlUpgradeable,\n    ERC1155PausableUpgradeable,\n    ERC1155SupplyUpgradeable,\n    IGildiToken\n{\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice A role reserved for the Gildi Manager smart contract that allows for the burning of tokens.\n    bytes32 public constant GILDI_MANAGER_ROLE = keccak256('GILDI_MANAGER_ROLE');\n    /// @notice A role that allows for setting the token name, symbol, and URI.\n    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n    /// @dev The name of the token.\n    string private tokenName;\n    /// @dev The symbol of the token.\n    string private tokenSymbol;\n    /// @dev Replace TokenUri {id} with the token ID.\n    bool private tokenUriReplaceId;\n\n    /// @dev A mapping of token balances of an address by token ID.\n    mapping(uint256 => EnumerableMap.AddressToUintMap) private _tokenBalances;\n    /// @dev A mapping of owned tokens by address.\n    mapping(address => EnumerableSet.UintSet) private _ownedTokens;\n\n    /// @dev Emitted when the token name changed.\n    event NameChanged(string newName);\n    /// @dev Emitted when the token symbol changed.\n    event SymbolChanged(string newSymbol);\n    /// @dev Emitted when the token URI changed.\n    event URIChanged(string newURI);\n    /// @dev Emitted when wether to replace the token URI {id} placeholder changed.\n    event TokenUriReplaceIdChanged(bool replaceId);\n\n    error InvalidMintBatch();\n    error InvalidId();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the contract.\n    /// @param _defaultAdmin The default admin of the contract.\n    /// @param _initialAdmin The initial admin of the contract.\n    /// @param _baseUri The base URI of the token.\n    function initialize(address _defaultAdmin, address _initialAdmin, string memory _baseUri) public initializer {\n        __ERC1155_init(_baseUri);\n        __AccessControl_init();\n        __ERC1155Pausable_init();\n        __ERC1155Supply_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        if (_initialAdmin != address(0)) {\n            _grantRole(ADMIN_ROLE, _initialAdmin);\n        }\n\n        tokenName = 'Gildi Share Token';\n        tokenSymbol = 'GILDI';\n\n        tokenUriReplaceId = true;\n    }\n\n    /// @notice Sets the URI of the token.\n    /// @param _newUri The new URI.\n    function setURI(string memory _newUri) public onlyRole(ADMIN_ROLE) {\n        _setURI(_newUri);\n        emit URIChanged(_newUri);\n    }\n\n    /// @notice Sets wether to replace the token URI {id} placeholder.\n    /// @param _replaceId Wether to replace the token URI {id} placeholder.\n    function setTokenUriReplaceId(bool _replaceId) public onlyRole(ADMIN_ROLE) {\n        tokenUriReplaceId = _replaceId;\n        emit TokenUriReplaceIdChanged(_replaceId);\n    }\n\n    /// @inheritdoc IGildiToken\n    function pause() public override onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    /// @inheritdoc IGildiToken\n    function unpause() public override onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /// @inheritdoc IGildiToken\n    function name() external view override returns (string memory) {\n        return tokenName;\n    }\n\n    /// @inheritdoc IGildiToken\n    function symbol() external view override returns (string memory) {\n        return tokenSymbol;\n    }\n\n    /// @notice Set the name of the token.\n    /// @param _name The new name of the token.\n    function setName(string memory _name) external onlyRole(ADMIN_ROLE) {\n        tokenName = _name;\n        emit NameChanged(_name);\n    }\n\n    /// @notice Set the symbol of the token.\n    /// @param _symbol The new symbol of the token.\n    function setSymbol(string memory _symbol) external onlyRole(ADMIN_ROLE) {\n        tokenSymbol = _symbol;\n        emit SymbolChanged(_symbol);\n    }\n\n    /// @inheritdoc IGildiToken\n    function totalSupply(uint256 _id) public view override(IGildiToken, ERC1155SupplyUpgradeable) returns (uint256) {\n        return super.totalSupply(_id);\n    }\n\n    /// @inheritdoc IGildiToken\n    function totalSupply() public view override(IGildiToken, ERC1155SupplyUpgradeable) returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /// @inheritdoc IGildiToken\n    function exists(uint256 _id) public view override(IGildiToken, ERC1155SupplyUpgradeable) returns (bool) {\n        return super.exists(_id);\n    }\n\n    /// @inheritdoc IGildiToken\n    function mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override onlyRole(GILDI_MANAGER_ROLE) whenNotPaused {\n        if (_id == 0) {\n            revert InvalidId();\n        }\n        _mint(_account, _id, _amount, _data);\n    }\n\n    /// @inheritdoc IGildiToken\n    function mintBatch(\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external onlyRole(GILDI_MANAGER_ROLE) whenNotPaused {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            if (_ids[i] == 0) {\n                revert InvalidId();\n            }\n        }\n        _mintBatch(_to, _ids, _amounts, _data);\n    }\n\n    /// @inheritdoc IGildiToken\n    function mintBatchMany(\n        MintBatch[] calldata _mintBatches\n    ) external override onlyRole(GILDI_MANAGER_ROLE) whenNotPaused {\n        for (uint256 i = 0; i < _mintBatches.length; i++) {\n            MintBatch memory mintBatchEntry = _mintBatches[i];\n            if (mintBatchEntry.ids.length != mintBatchEntry.amounts.length) {\n                revert InvalidMintBatch();\n            }\n            for (uint256 j = 0; j < mintBatchEntry.ids.length; j++) {\n                if (mintBatchEntry.ids[j] == 0) {\n                    revert InvalidId();\n                }\n            }\n            _mintBatch(mintBatchEntry.to, mintBatchEntry.ids, mintBatchEntry.amounts, mintBatchEntry.data);\n        }\n    }\n\n    /// @inheritdoc IGildiToken\n    function burn(\n        address _account,\n        uint256 _id,\n        uint256 _value\n    ) external override whenNotPaused onlyRole(GILDI_MANAGER_ROLE) {\n        _burn(_account, _id, _value);\n    }\n\n    /// @inheritdoc IGildiToken\n    function burnBatch(\n        address _account,\n        uint256[] calldata _ids,\n        uint256[] calldata _values\n    ) external override whenNotPaused onlyRole(GILDI_MANAGER_ROLE) {\n        _burnBatch(_account, _ids, _values);\n    }\n\n    /// @inheritdoc IGildiToken\n    function burnAllById(uint256 _id) external override onlyRole(GILDI_MANAGER_ROLE) whenNotPaused {\n        // Burn all tokens of a specific ID from all accounts.\n        address[] memory accounts = _tokenBalances[_id].keys();\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            uint256 balance = _tokenBalances[_id].get(accounts[i]);\n            _burn(accounts[i], _id, balance);\n        }\n    }\n\n    /// @inheritdoc IGildiToken\n    function tokensOfOwner(address _account) external view override returns (TokenBalance[] memory ownedTokens) {\n        uint256[] memory tokensOwned = _ownedTokens[_account].values();\n        ownedTokens = new TokenBalance[](tokensOwned.length);\n\n        for (uint256 i = 0; i < tokensOwned.length; i++) {\n            // Get balance via _tokenBalances mapping\n            uint256 balance = _tokenBalances[tokensOwned[i]].get(_account);\n            ownedTokens[i] = TokenBalance(tokensOwned[i], balance);\n        }\n    }\n\n    /// @inheritdoc ERC1155Upgradeable\n    function uri(uint256 _tokenId) public view override returns (string memory) {\n        string memory baseURI = super.uri(_tokenId); // Get the base URI\n        string memory tokenIDStr = Strings.toString(_tokenId);\n\n        // Check if the base URI contains the \"{id}\" placeholder\n        if (bytes(baseURI).length > 0) {\n            bytes memory toReplace = '{id}';\n            bytes memory baseURIBytes = bytes(baseURI);\n            bytes memory toReplaceBytes = bytes(toReplace);\n\n            // Search for the \"{id}\" substring\n            bool found = false;\n            for (uint256 i = 0; i < baseURIBytes.length - toReplaceBytes.length + 1; i++) {\n                bool xmatch = true;\n                for (uint256 j = 0; j < toReplaceBytes.length; j++) {\n                    if (baseURIBytes[i + j] != toReplaceBytes[j]) {\n                        xmatch = false;\n                        break;\n                    }\n                }\n\n                // If \"{id}\" is found and replace is enabled, replace it with the token ID\n                if (xmatch) {\n                    found = true;\n                    if (tokenUriReplaceId) {\n                        return\n                            string(\n                                abi.encodePacked(\n                                    _substring(baseURI, 0, i),\n                                    tokenIDStr,\n                                    _substring(baseURI, i + toReplaceBytes.length, baseURIBytes.length)\n                                )\n                            );\n                    }\n                }\n            }\n\n            // If \"{id}\" is not found, append '/' if necessary and then the token ID\n            if (!found) {\n                if (baseURIBytes[baseURIBytes.length - 1] != '/') {\n                    return string(abi.encodePacked(baseURI, '/', tokenIDStr));\n                }\n                return string(abi.encodePacked(baseURI, tokenIDStr));\n            }\n        }\n\n        return baseURI; // Return the base URI if no placeholder is found\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) public view override(ERC1155Upgradeable, AccessControlUpgradeable, IERC165) returns (bool) {\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(IGildiToken).interfaceId;\n    }\n\n    /// @inheritdoc ERC1155Upgradeable\n    function _update(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values\n    ) internal override(ERC1155Upgradeable, ERC1155PausableUpgradeable, ERC1155SupplyUpgradeable) {\n        super._update(_from, _to, _ids, _values);\n\n        if (_to == address(0) && _from != address(0)) {\n            _recordDebit(_from, _ids, _values);\n        }\n\n        if (_from == address(0) && _to != address(0)) {\n            _recordCredit(_to, _ids, _values);\n        }\n\n        if (_to != address(0) && _from != address(0)) {\n            _recordDebit(_from, _ids, _values);\n            _recordCredit(_to, _ids, _values);\n        }\n    }\n\n    function _substring(string memory _str, uint _startIndex, uint _endIndex) private pure returns (string memory) {\n        bytes memory strBytes = bytes(_str);\n        bytes memory result = new bytes(_endIndex - _startIndex);\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            result[i - _startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function _recordCredit(address _account, uint256[] memory _ids, uint256[] memory _values) private {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            if (!_tokenBalances[_ids[i]].contains(_account)) {\n                _tokenBalances[_ids[i]].set(_account, 0);\n            }\n            _tokenBalances[_ids[i]].set(_account, _tokenBalances[_ids[i]].get(_account) + _values[i]);\n            _ownedTokens[_account].add(_ids[i]);\n        }\n    }\n\n    function _recordDebit(address _account, uint256[] memory _ids, uint256[] memory _values) private {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _tokenBalances[_ids[i]].set(_account, _tokenBalances[_ids[i]].get(_account) - _values[i]);\n            if (_tokenBalances[_ids[i]].get(_account) == 0) {\n                _ownedTokens[_account].remove(_ids[i]);\n            }\n        }\n    }\n}\n"
        },
        "contracts/wallet/GildiWalletBeacon.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {IBeacon} from '@openzeppelin/contracts/proxy/beacon/IBeacon.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\n\n/// @title GildiWalletBeacon\n/// @notice Beacon contract that manages the implementation address for wallet proxies\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiWalletBeacon is IBeacon, AccessControl {\n    /// @notice Role identifier for accounts that can upgrade the implementation\n    bytes32 public constant UPGRADER_ROLE = keccak256('UPGRADER_ROLE');\n\n    /// @dev The current implementation address\n    address private implementationAddress;\n\n    /// @dev Thrown when attempting to set an invalid implementation address\n    error BeaconInvalidImplementation(address implementation);\n\n    /// @dev Thrown when attempting to initialize with a zero address for default admin\n    error ZeroDefaultAdminAddress();\n\n    /// @dev Thrown when attempting to initialize with a zero address for initial upgrader\n    error ZeroInitialUpgraderAddress();\n\n    /// @notice Emitted when the implementation is upgraded\n    event BeaconUpgraded(address indexed implementation);\n\n    /// @notice Initializes the beacon with an implementation and role assignments\n    /// @param _initialImplementation The initial implementation contract address\n    /// @param _defaultAdmin The address that will receive the DEFAULT_ADMIN_ROLE\n    /// @param _initialUpgrader The address that will receive the UPGRADER_ROLE\n    constructor(address _initialImplementation, address _defaultAdmin, address _initialUpgrader) {\n        if (_defaultAdmin == address(0)) {\n            revert ZeroDefaultAdminAddress();\n        }\n        if (_initialUpgrader == address(0)) {\n            revert ZeroInitialUpgraderAddress();\n        }\n\n        _setImplementation(_initialImplementation);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        _grantRole(UPGRADER_ROLE, _initialUpgrader);\n    }\n\n    /// @notice Returns the current implementation address\n    /// @return The address of the current implementation contract\n    function implementation() public view virtual returns (address) {\n        return implementationAddress;\n    }\n\n    /// @notice Upgrades the beacon to a new implementation\n    /// @dev Only callable by accounts with UPGRADER_ROLE\n    /// @param _newImplementation The address of the new implementation contract\n    function upgradeTo(address _newImplementation) public onlyRole(UPGRADER_ROLE) {\n        _setImplementation(_newImplementation);\n    }\n\n    /// @dev Sets the implementation address after validating it has code\n    /// @param _newImplementation The new implementation address to set\n    function _setImplementation(address _newImplementation) private {\n        if (_newImplementation.code.length == 0) {\n            revert BeaconInvalidImplementation(_newImplementation);\n        }\n        implementationAddress = _newImplementation;\n        emit BeaconUpgraded(_newImplementation);\n    }\n}\n"
        },
        "contracts/wallet/GildiWalletBeaconProxy.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol';\nimport {IBeacon} from '@openzeppelin/contracts/proxy/beacon/IBeacon.sol';\nimport {StorageSlot} from '@openzeppelin/contracts/utils/StorageSlot.sol';\n\n/// @title GildiWalletBeaconProxy\n/// @notice BeaconProxy with additional functionality like freezing implementation and setting a custom implementation. Uses a simple owner/operator pattern.\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiWalletBeaconProxy is BeaconProxy {\n    /// @dev Storage slots (EIP-1967 style) for proxy-specific state to avoid collisions with implementation\n    bytes32 private constant OWNER_SLOT = 0x7b9de4d5208379c574cec2d635a21aa5e97ccefb6169355a0c4aeb66af8d11e7;\n    bytes32 private constant OPERATOR_SLOT = 0x95f03cd5bcea7edcde1ad4dffbf6580386ba9217c5aaeb6372a784f41c1f21a3;\n    bytes32 private constant OPERATOR_REVOKED_SLOT = 0x2bad8861766d5ce4c5c51525728286895174f7d076c90f3066eca92fff25bfea;\n    bytes32 private constant FROZEN_SLOT = 0x858a9ce43794e55f03c1c5fc02176a6882a143de4d9829430a832144e5714486;\n    bytes32 private constant FROZEN_IMPL_SLOT = 0xc93e0c4c416d4714086268bbe76236443e520ba92d7861ebf106854c6bbdc1ae;\n    bytes32 private constant CUSTOM_IMPL_SLOT = 0xcf3cd2e0b8b185268580bdc8fe9cc97acf4a8b998dc8901aa169913239f1858f;\n    /// @dev Off-ramp guard slot to allow logic to verify call path originates from this proxy flow\n    bytes32 private constant OFFRAMP_GUARD_SLOT = 0xbf2e87ae6cef65f01e1c587276c96bbd9fc7ff1493647120ef7d93bf473a6640;\n\n    /// @dev Thrown when caller is not the owner\n    error NotOwner();\n\n    /// @dev Thrown when caller is neither owner nor operator\n    error NotOwnerOrOperator();\n\n    /// @dev Thrown when caller is not the operator\n    error NotOperator();\n\n    /// @dev Thrown when attempting to initialize with zero owner address\n    error ZeroOwnerAddress();\n\n    /// @dev Thrown when implementation is already frozen\n    error ImplementationAlreadyFrozen();\n\n    /// @dev Thrown when implementation is not frozen\n    error ImplementationNotFrozen();\n\n    /// @dev Thrown when attempting to set zero address as custom implementation\n    error ZeroCustomImplementationAddress();\n\n    /// @dev Thrown when operator is already revoked\n    error OperatorAlreadyRevoked();\n\n    /// @dev Thrown when custom implementation is set during operator revocation\n    error CustomImplementationSet();\n\n    /// @dev Thrown when attempting to transfer ownership to zero address\n    error ZeroNewOwnerAddress();\n\n    /// @notice Emitted when ownership is transferred\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /// @notice Emitted when the operator is changed\n    event GildiOperatorChanged(address indexed previousOperator, address indexed newOperator);\n    /// @notice Emitted when the implementation is frozen with the frozen implementation address\n    event ImplementationFrozen(address indexed implementation);\n    /// @notice Emitted when the implementation is unfrozen\n    event ImplementationUnfrozen();\n    /// @notice Emitted when a custom implementation is set\n    event CustomImplementationConfigured(address indexed implementation);\n    /// @notice Emitted when the custom implementation is unset\n    event CustomImplementationUnset();\n    /// @notice Emitted when the operator revokes itself\n    event GildiOperatorRevoked(address indexed operator);\n\n    // =========================\n    // Internal storage helpers\n    // =========================\n\n    /// @dev Returns the current owner address from storage\n    function _owner() internal view returns (address) {\n        return StorageSlot.getAddressSlot(OWNER_SLOT).value;\n    }\n\n    /// @dev Sets the owner address in storage\n    function _setOwner(address _newOwner) internal {\n        StorageSlot.getAddressSlot(OWNER_SLOT).value = _newOwner;\n    }\n\n    /// @dev Returns the current operator address from storage\n    function _operator() internal view returns (address) {\n        return StorageSlot.getAddressSlot(OPERATOR_SLOT).value;\n    }\n\n    /// @dev Sets the operator address in storage\n    function _setOperator(address _newOperator) internal {\n        StorageSlot.getAddressSlot(OPERATOR_SLOT).value = _newOperator;\n    }\n\n    /// @dev Returns whether the operator has been revoked\n    function _isOperatorRevoked() internal view returns (bool) {\n        return StorageSlot.getBooleanSlot(OPERATOR_REVOKED_SLOT).value;\n    }\n\n    /// @dev Sets the operator revoked status in storage\n    function _setOperatorRevoked(bool _revoked) internal {\n        StorageSlot.getBooleanSlot(OPERATOR_REVOKED_SLOT).value = _revoked;\n    }\n\n    /// @dev Returns whether the implementation is frozen\n    function _isFrozen() internal view returns (bool) {\n        return StorageSlot.getBooleanSlot(FROZEN_SLOT).value;\n    }\n\n    /// @dev Sets the frozen status in storage\n    function _setFrozen(bool _value) internal {\n        StorageSlot.getBooleanSlot(FROZEN_SLOT).value = _value;\n    }\n\n    /// @dev Returns the frozen implementation address from storage\n    function _frozenImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(FROZEN_IMPL_SLOT).value;\n    }\n\n    /// @dev Sets the frozen implementation address in storage\n    function _setFrozenImplementation(address _impl) internal {\n        StorageSlot.getAddressSlot(FROZEN_IMPL_SLOT).value = _impl;\n    }\n\n    /// @dev Returns the custom implementation address from storage\n    function _customImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(CUSTOM_IMPL_SLOT).value;\n    }\n\n    /// @dev Sets the custom implementation address in storage\n    function _setCustomImplementation(address _impl) internal {\n        StorageSlot.getAddressSlot(CUSTOM_IMPL_SLOT).value = _impl;\n    }\n\n    /// @dev Returns the off-ramp guard status from storage\n    function _offRampGuard() internal view returns (bool) {\n        return StorageSlot.getBooleanSlot(OFFRAMP_GUARD_SLOT).value;\n    }\n\n    /// @dev Sets the off-ramp guard status in storage\n    function _setOffRampGuard(bool _v) internal {\n        StorageSlot.getBooleanSlot(OFFRAMP_GUARD_SLOT).value = _v;\n    }\n\n    // Modifiers\n    /// @dev Restricts function access to the owner\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    /// @dev Restricts function access to either the owner or operator\n    modifier onlyOwnerOrOperator() {\n        address currentOwner = _owner();\n        address currentOperator = _operator();\n        if (msg.sender != currentOwner && msg.sender != currentOperator) {\n            revert NotOwnerOrOperator();\n        }\n        _;\n    }\n\n    /// @dev Restricts function access to only the operator\n    modifier onlyGildiOperator() {\n        if (msg.sender != _operator()) {\n            revert NotOperator();\n        }\n        _;\n    }\n\n    /// @notice Initializes the proxy with beacon, initialization data, owner, and operator\n    /// @param _beacon The address of the beacon contract\n    /// @param _data Initialization data to pass to the implementation\n    /// @param _ownerAddress The address that will be set as the owner\n    /// @param _operatorAddress The address that will be set as the operator\n    constructor(\n        address _beacon,\n        bytes memory _data,\n        address _ownerAddress,\n        address _operatorAddress\n    ) BeaconProxy(_beacon, _data) {\n        if (_ownerAddress == address(0)) {\n            revert ZeroOwnerAddress();\n        }\n        _setOwner(_ownerAddress);\n        _setOperator(_operatorAddress);\n    }\n\n    /// @notice Freezes the current implementation to prevent beacon upgrades\n    /// @dev Only callable by owner or operator\n    function freezeImplementation() public onlyOwnerOrOperator {\n        if (_isFrozen()) {\n            revert ImplementationAlreadyFrozen();\n        }\n        _setFrozen(true);\n        address impl = IBeacon(_getBeacon()).implementation();\n        _setFrozenImplementation(impl);\n        emit ImplementationFrozen(impl);\n    }\n\n    /// @notice Unfreezes the implementation to allow beacon upgrades\n    /// @dev Only callable by owner or operator\n    function unfreezeImplementation() public onlyOwnerOrOperator {\n        if (!_isFrozen()) {\n            revert ImplementationNotFrozen();\n        }\n        _setFrozen(false);\n        emit ImplementationUnfrozen();\n    }\n\n    /// @notice Sets a custom implementation address that overrides the beacon\n    /// @dev Only callable by owner or operator\n    /// @param _newImplementation The address of the custom implementation\n    function setCustomImplementation(address _newImplementation) external onlyOwnerOrOperator {\n        if (_newImplementation == address(0)) {\n            revert ZeroCustomImplementationAddress();\n        }\n        _setCustomImplementation(_newImplementation);\n        emit CustomImplementationConfigured(_newImplementation);\n    }\n\n    /// @notice Removes the custom implementation to use the beacon again\n    /// @dev Only callable by owner or operator\n    function unsetCustomImplementation() external onlyOwnerOrOperator {\n        _setCustomImplementation(address(0));\n        emit CustomImplementationUnset();\n    }\n\n    /// @notice Changes the operator address\n    /// @dev Only callable by the owner or current operator (for compromise scenarios)\n    /// @param _newOperator The new operator address\n    function changeGildiOperator(address _newOperator) public onlyOwnerOrOperator {\n        address oldOperator = _operator();\n        _setOperator(_newOperator);\n\n        // Sync operator role in logic via delegatecall\n        address impl = _implementation();\n        _setOffRampGuard(true);\n        (bool ok, ) = impl.delegatecall(\n            abi.encodeWithSignature('offRampUpdateOperator(address,address)', oldOperator, _newOperator)\n        );\n        _setOffRampGuard(false);\n        // intentionally ignore `ok` to ensure operator change continues even if logic signature changes/removed\n        ok;\n\n        emit GildiOperatorChanged(oldOperator, _newOperator);\n    }\n\n    /// @notice Revokes the operator and freezes the implementation\n    /// @dev Only callable by owner or operator. Also removes operator role from the logic contract.\n    function revokeOperator() external onlyOwnerOrOperator {\n        if (_isOperatorRevoked()) {\n            revert OperatorAlreadyRevoked();\n        }\n        if (_customImplementation() != address(0)) {\n            revert CustomImplementationSet();\n        }\n\n        address oldOperator = _operator();\n\n        // Remove operator privileges in logic via delegatecall to current implementation\n        if (oldOperator != address(0)) {\n            address impl = _implementation();\n            _setOffRampGuard(true);\n            (bool ok, ) = impl.delegatecall(abi.encodeWithSignature('offRampOperator(address)', oldOperator));\n            _setOffRampGuard(false);\n            // intentionally ignore `ok` to ensure revoke continues even if logic signature changes/removed\n            ok;\n        }\n\n        _setOperatorRevoked(true);\n        _setOperator(address(0));\n\n        // Freeze the implementation when revoking\n        if (!_isFrozen()) {\n            freezeImplementation();\n        }\n\n        emit GildiOperatorRevoked(oldOperator);\n    }\n\n    /// @notice Transfers ownership to a new address\n    /// @dev Only callable by the current owner. Also updates DEFAULT_ADMIN_ROLE in logic.\n    /// @param _newOwner The address to transfer ownership to\n    function transferOwnership(address _newOwner) public onlyOwner {\n        if (_newOwner == address(0)) {\n            revert ZeroNewOwnerAddress();\n        }\n        address oldOwner = _owner();\n        _setOwner(_newOwner);\n\n        // Sync admin role in logic via delegatecall\n        address impl = _implementation();\n        _setOffRampGuard(true);\n        (bool ok, ) = impl.delegatecall(\n            abi.encodeWithSignature('offRampUpdateAdmin(address,address)', oldOwner, _newOwner)\n        );\n        _setOffRampGuard(false);\n        // intentionally ignore `ok` to ensure ownership transfer continues even if logic signature changes/removed\n        ok;\n\n        emit OwnershipTransferred(oldOwner, _newOwner);\n    }\n\n    /// @inheritdoc BeaconProxy\n    function _implementation() internal view override returns (address) {\n        // Custom implementation takes precedence\n        address customImpl = _customImplementation();\n        if (customImpl != address(0)) {\n            return customImpl;\n        }\n\n        // If frozen, use the frozen implementation\n        if (_isFrozen()) {\n            return _frozenImplementation();\n        }\n\n        // Otherwise, follow the beacon normally\n        return super._implementation();\n    }\n\n    /// @notice Get the implementation address from the beacon\n    /// @return The beacon's current implementation address\n    function getBeaconImplementation() external view returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /// @notice Returns the address of the current owner\n    /// @return The owner address\n    function owner() external view returns (address) {\n        return _owner();\n    }\n\n    /// @notice Returns the address of the gildiOperator\n    /// @return The operator address\n    function getOperator() external view returns (address) {\n        return _operator();\n    }\n\n    /// @notice Check if operator is revoked\n    /// @return True if the operator has been revoked, false otherwise\n    function isOperatorRevoked() external view returns (bool) {\n        return _isOperatorRevoked();\n    }\n\n    /// @notice Check if implementation is frozen\n    /// @return True if the implementation is frozen, false otherwise\n    function isFrozen() external view returns (bool) {\n        return _isFrozen();\n    }\n\n    /// @notice Get the frozen implementation address\n    /// @return The frozen implementation address\n    function getFrozenImplementation() external view returns (address) {\n        return _frozenImplementation();\n    }\n\n    /// @notice Get the custom implementation address\n    /// @return The custom implementation address\n    function getCustomImplementation() external view returns (address) {\n        return _customImplementation();\n    }\n\n    /// @dev Receive function to handle direct Ether transfers\n    receive() external payable virtual {\n        _fallback();\n    }\n}\n"
        },
        "contracts/wallet/GildiWalletBeaconProxyFactory.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {GildiWalletBeaconProxy} from './GildiWalletBeaconProxy.sol';\n\n/// @title GildiWalletBeaconProxyFactory\n/// @notice Factory for creating new GildiWalletBeaconProxy instances with external ID support for backend integration\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiWalletBeaconProxyFactory is Initializable, AccessControlUpgradeable {\n    /// @notice Role identifier for accounts that can deploy new proxies\n    bytes32 public constant DEPLOYER_ROLE = keccak256('DEPLOYER_ROLE');\n\n    /// @dev The address of the beacon used for deployed proxies\n    address private _beacon;\n    /// @dev Array of all deployed proxy addresses\n    address[] private _deployedProxies;\n    /// @dev Mapping to check if an address is a deployed proxy\n    mapping(address => bool) private _isProxyDeployed;\n\n    /// @dev Thrown when attempting to initialize or set beacon with zero address\n    error ZeroBeaconAddress();\n\n    /// @dev Thrown when attempting to deploy proxy with zero owner address\n    error ZeroOwnerAddress();\n\n    /// @dev Thrown when attempting to initialize with zero admin address\n    error ZeroAdminAddress();\n\n    /// @dev Thrown when attempting to initialize with zero deployer address\n    error ZeroDeployerAddress();\n\n    /// @notice Emitted when a new proxy is deployed\n    /// @dev Includes externalId for backend system integration\n    event ProxyDeployed(\n        address indexed proxyAddress,\n        address indexed owner,\n        address gildiOperator,\n        string indexed externalId\n    );\n    /// @notice Emitted when the beacon address is updated\n    event BeaconUpdated(address indexed previousBeacon, address indexed newBeacon);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with the beacon address and sets up roles\n    /// @dev This function can only be called once due to the initializer modifier\n    /// @param _beaconAddress The address of the UpgradeableBeacon\n    /// @param _initialDefaultAdmin The address to grant DEFAULT_ADMIN_ROLE\n    /// @param _initialDeployer The address to grant DEPLOYER_ROLE\n    function initialize(\n        address _beaconAddress,\n        address _initialDefaultAdmin,\n        address _initialDeployer\n    ) external initializer {\n        if (_beaconAddress == address(0)) {\n            revert ZeroBeaconAddress();\n        }\n        if (_initialDefaultAdmin == address(0)) {\n            revert ZeroAdminAddress();\n        }\n        if (_initialDeployer == address(0)) {\n            revert ZeroDeployerAddress();\n        }\n        __AccessControl_init();\n\n        _beacon = _beaconAddress;\n\n        // Setup roles\n        _grantRole(DEFAULT_ADMIN_ROLE, _initialDefaultAdmin);\n        _grantRole(DEPLOYER_ROLE, _initialDeployer);\n    }\n\n    /// @notice Updates the beacon address\n    /// @dev Only callable by accounts with DEFAULT_ADMIN_ROLE\n    /// @param _newBeacon The new beacon address\n    function setBeacon(address _newBeacon) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newBeacon == address(0)) {\n            revert ZeroBeaconAddress();\n        }\n        address oldBeacon = _beacon;\n        _beacon = _newBeacon;\n        emit BeaconUpdated(oldBeacon, _newBeacon);\n    }\n\n    /// @notice Returns the beacon address\n    /// @return The current beacon address\n    function beacon() external view returns (address) {\n        return _beacon;\n    }\n\n    /// @notice Deploys a new proxy with owner, gildiOperator, and external ID\n    /// @dev Only callable by accounts with DEPLOYER_ROLE\n    /// @param _owner The owner address for the new proxy\n    /// @param _gildiOperator The gildiOperator address for the new proxy\n    /// @param _externalId The external identifier for backend system integration\n    /// @return proxyAddress The address of the deployed proxy\n    function deployProxy(\n        address _owner,\n        address _gildiOperator,\n        address _configRegistry,\n        string calldata _externalId\n    ) external onlyRole(DEPLOYER_ROLE) returns (address proxyAddress) {\n        if (_owner == address(0)) {\n            revert ZeroOwnerAddress();\n        }\n\n        // Prepare initialization data for the LogicContract\n        bytes memory initData = abi.encodeWithSignature(\n            'initialize(address,address,address)',\n            _owner,\n            _gildiOperator,\n            _configRegistry\n        );\n\n        // Deploy new proxy\n        GildiWalletBeaconProxy newProxy = new GildiWalletBeaconProxy(_beacon, initData, _owner, _gildiOperator);\n\n        proxyAddress = address(newProxy);\n        _deployedProxies.push(proxyAddress);\n        _isProxyDeployed[proxyAddress] = true;\n\n        emit ProxyDeployed(proxyAddress, _owner, _gildiOperator, _externalId);\n    }\n\n    /// @notice Returns the number of proxies deployed by this factory\n    /// @return The number of deployed proxies\n    function getProxyCount() external view returns (uint256) {\n        return _deployedProxies.length;\n    }\n\n    /// @notice Returns a list of deployed proxies\n    /// @param cursor The cursor to start from\n    /// @param count The number of proxies to return\n    /// @return proxies An array of deployed proxy addresses\n    /// @return nextCursor The cursor to use for the next call\n    function getProxies(\n        uint256 cursor,\n        uint256 count\n    ) external view returns (address[] memory proxies, uint256 nextCursor) {\n        uint256 maxCount = _deployedProxies.length;\n        if (cursor >= maxCount) {\n            return (new address[](0), 0);\n        }\n\n        uint256 endCursor = cursor + count;\n        if (endCursor > maxCount) {\n            endCursor = maxCount;\n        }\n        proxies = new address[](endCursor - cursor);\n        for (uint256 i = cursor; i < endCursor; i++) {\n            proxies[i - cursor] = _deployedProxies[i];\n        }\n\n        nextCursor = endCursor;\n    }\n\n    /// @notice Checks if a proxy is deployed by this factory at a specific address\n    /// @param _proxyAddress The address of the proxy to check\n    /// @return True if the proxy is deployed, false otherwise\n    function isDeployed(address _proxyAddress) external view returns (bool) {\n        return _isProxyDeployed[_proxyAddress];\n    }\n}\n"
        },
        "contracts/wallet/GildiWalletConfigRegistry.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {IGildiWalletConfigRegistry} from '../interfaces/wallet/IGildiWalletConfigRegistry.sol';\n\n/// @title GildiWalletConfigRegistry\n/// @notice Centralized configuration registry for all wallet instances\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiWalletConfigRegistry is Initializable, AccessControlUpgradeable, IGildiWalletConfigRegistry {\n    /// @dev Thrown when GildiExchange address is zero\n    error InvalidGildiExchangeAddress();\n\n    /// @dev Thrown when RoyaltyDistributor address is zero\n    error InvalidRoyaltyDistributorAddress();\n\n    /// @dev Thrown when GildiManager address is zero\n    error InvalidGildiManagerAddress();\n\n    /// @notice Emitted when the registry is initialized\n    /// @param defaultAdmin The address that received DEFAULT_ADMIN_ROLE\n    /// @param configManager The address that received CONFIG_MANAGER_ROLE\n    /// @param defaultConfig The default configuration set during initialization\n    event RegistryInitialized(address indexed defaultAdmin, address indexed configManager, WalletConfig defaultConfig);\n\n    /// @notice Role identifier for configuration managers\n    bytes32 public constant CONFIG_MANAGER_ROLE = keccak256('CONFIG_MANAGER_ROLE');\n\n    /// @notice Configuration storage by version (version 0 = default)\n    mapping(uint256 => WalletConfig) public configByVersion;\n\n    /// @notice Array of versions that have configs, kept in ascending order\n    uint256[] private configVersions;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the configuration registry\n    /// @dev Can only be called once during deployment\n    /// @param _defaultAdmin The address that will receive the DEFAULT_ADMIN_ROLE\n    /// @param _configManager The address that will receive the CONFIG_MANAGER_ROLE\n    /// @param _defaultConfig The default configuration for all wallets\n    function initialize(\n        address _defaultAdmin,\n        address _configManager,\n        WalletConfig calldata _defaultConfig\n    ) public initializer {\n        if (_defaultConfig.gildiExchangeV2 == address(0)) {\n            revert InvalidGildiExchangeAddress();\n        }\n        if (_defaultConfig.royaltyDistributor == address(0)) {\n            revert InvalidRoyaltyDistributorAddress();\n        }\n        if (_defaultConfig.gildiManager == address(0)) {\n            revert InvalidGildiManagerAddress();\n        }\n\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n        if (_configManager != address(0)) {\n            _grantRole(CONFIG_MANAGER_ROLE, _configManager);\n        }\n\n        configByVersion[0] = _defaultConfig;\n        configVersions.push(0); // Initialize with version 0\n\n        emit RegistryInitialized(_defaultAdmin, _configManager, _defaultConfig);\n    }\n\n    /// @notice Sets configuration for a specific logic contract version\n    /// @dev Only callable by accounts with CONFIG_MANAGER_ROLE. Version 0 is the default config.\n    /// @param _version The logic contract version this config applies to (0 = default)\n    /// @param _config The configuration for this version\n    function setConfigForVersion(\n        uint256 _version,\n        WalletConfig calldata _config\n    ) external onlyRole(CONFIG_MANAGER_ROLE) {\n        if (_config.gildiExchangeV2 == address(0)) {\n            revert InvalidGildiExchangeAddress();\n        }\n        if (_config.royaltyDistributor == address(0)) {\n            revert InvalidRoyaltyDistributorAddress();\n        }\n        if (_config.gildiManager == address(0)) {\n            revert InvalidGildiManagerAddress();\n        }\n\n        // Check if this is a new version\n        bool isNewVersion = configByVersion[_version].gildiExchangeV2 == address(0);\n\n        configByVersion[_version] = _config;\n\n        // Add to sorted versions array if new\n        if (isNewVersion && _version != 0) {\n            // version 0 is already added during initialization\n            _insertVersionSorted(_version);\n        }\n\n        emit GlobalConfigUpdated(_version, _config);\n    }\n\n    /// @notice Gets configuration for a specific logic contract version\n    /// @dev Returns the best available config: highest version <= requested version, or version 0 (default) if none found\n    /// @param _version The logic contract version to get config for\n    /// @return The best available configuration for this version range\n    function getConfigForVersion(uint256 _version) external view returns (WalletConfig memory) {\n        // First try exact match\n        WalletConfig memory config = configByVersion[_version];\n        if (config.gildiExchangeV2 != address(0)) {\n            return config;\n        }\n\n        // Find the highest version <= _version that has a config\n        // Iterate through sorted versions array (much more efficient)\n        uint256 bestVersion = 0; // Default to version 0\n        for (uint256 i = 0; i < configVersions.length; i++) {\n            uint256 candidateVersion = configVersions[i];\n            if (candidateVersion <= _version) {\n                bestVersion = candidateVersion;\n            } else {\n                // Array is sorted, so no need to continue\n                break;\n            }\n        }\n\n        return configByVersion[bestVersion];\n    }\n\n    /// @notice Gets the default global configuration (version 0)\n    /// @return config The default global configuration\n    function getDefaultConfig() external view returns (WalletConfig memory config) {\n        return configByVersion[0];\n    }\n\n    /// @notice Checks if a configuration exists for a specific version\n    /// @param _version The version to check\n    /// @return exists Whether configuration exists for this version\n    function hasConfigForVersion(uint256 _version) external view returns (bool exists) {\n        return configByVersion[_version].gildiExchangeV2 != address(0);\n    }\n\n    /// @notice Gets all configured versions\n    /// @return versions Array of all versions that have configurations\n    function getConfiguredVersions() external view returns (uint256[] memory versions) {\n        return configVersions;\n    }\n\n    /// @dev Internal function to insert a version into the sorted array\n    /// @param _version The version to insert\n    function _insertVersionSorted(uint256 _version) private {\n        // Find insertion point\n        uint256 insertIndex = configVersions.length;\n        for (uint256 i = 0; i < configVersions.length; i++) {\n            if (configVersions[i] > _version) {\n                insertIndex = i;\n                break;\n            }\n        }\n\n        // Add element and shift if necessary\n        configVersions.push(0); // Expand array\n        for (uint256 i = configVersions.length - 1; i > insertIndex; i--) {\n            configVersions[i] = configVersions[i - 1];\n        }\n        configVersions[insertIndex] = _version;\n    }\n}\n"
        },
        "contracts/wallet/GildiWalletLogic.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\n// Created for Soonami Venturethon prototype only.\n// No redistribution, modification, or commercial use without prior written consent.\n// Copyright (c) 2025 Patrick Fischer. All rights reserved.\npragma solidity 0.8.24;\n\nimport {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {StorageSlot} from '@openzeppelin/contracts/utils/StorageSlot.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IGildiExchange} from '../interfaces/marketplace/exchange/IGildiExchange.sol';\nimport {IGildiExchangePaymentAggregator} from '../interfaces/marketplace/exchange/IGildiExchangePaymentAggregator.sol';\nimport {IGildiExchangePurchaseVault} from '../interfaces/marketplace/vault/IGildiExchangePurchaseVault.sol';\nimport {RoyaltyDistributor} from '../royalties/RoyaltyDistributor.sol';\nimport {IGildiManager} from '../interfaces/manager/IGildiManager.sol';\nimport {IGildiWalletConfigRegistry} from '../interfaces/wallet/IGildiWalletConfigRegistry.sol';\n\n/// @title GildiWalletLogic\n/// @notice Gildi proxy wallets business logic\n/// @custom:security-contact security@gildi.io\n/// @author Gildi Company\ncontract GildiWalletLogic is Initializable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role identifier for operator accounts that can execute certain business functions\n    bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE');\n\n    /// @notice Version of this logic contract implementation\n    uint256 public constant VERSION = 10000;\n\n    /// @dev Storage slot for off-ramp guard mechanism to verify call path originates from proxy\n    bytes32 private constant OFFRAMP_GUARD_SLOT = 0xbf2e87ae6cef65f01e1c587276c96bbd9fc7ff1493647120ef7d93bf473a6640;\n    /// @dev Storage slot for wallet configuration to ensure future extensibility\n    bytes32 private constant WALLET_CONFIG_SLOT = 0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b;\n\n    enum WithdrawType {\n        WITHDRAW_TYPE_CRYPTO_WALLET,\n        WITHDRAW_TYPE_TRANSAK_STREAM\n    }\n\n    /// @notice Versioned wallet configuration snapshot stored in the wallet.\n    /// @dev Holds a pointer to the registry and the active resolved configuration.\n    struct VersionedWalletConfig {\n        /// @dev Address of the configuration registry contract\n        address configRegistry;\n        /// @dev Local version of the applied configuration (compared to implementation VERSION)\n        uint256 version;\n        /// @dev Resolved configuration values used by this wallet\n        IGildiWalletConfigRegistry.WalletConfig config;\n    }\n\n    /// @notice Parameters for Transak stream withdrawal flow.\n    struct WithdrawTransakParams {\n        /// @dev Destination wallet that accepts Transak stream deposits\n        address transakStreamWallet;\n        /// @dev Token to stream; must be a Transak-supported asset\n        address transakStreamToken; // Need to swap to a transak stream supported token.\n    }\n\n    /// @dev Thrown when attempting to initialize with a zero address for owner\n    error ZeroOwnerAddress();\n\n    /// @dev Thrown when off-ramp function is called through invalid entry point\n    error InvalidEntryPoint();\n\n    /// @dev No remaining USD in the referenced intent\n    error NoRemainingUsd();\n    /// @dev Estimated cost exceeds remaining USD in the intent\n    error EstimatedCostExceedsIntent();\n    /// @dev Actual cost exceeds remaining USD in the intent\n    error ActualCostExceedsIntent();\n    /// @dev Provided arrays have mismatched lengths\n    error ArraysLengthMismatch();\n    /// @dev Invalid data payload provided for Transak withdrawal\n    error InvalidTransakData();\n    /// @dev Invalid data payload provided for address-based withdrawal\n    error InvalidAddressData();\n    /// @dev Invalid withdraw type selector\n    error InvalidWithdrawType();\n    /// @dev Zero address provided for recipient\n    error ZeroAddressRecipient();\n    /// @dev Invalid Transak wallet address\n    error InvalidTransakWallet();\n    /// @dev Invalid Transak token address\n    error InvalidTransakToken();\n    /// @dev Feature not yet implemented\n    error TransakWithdrawalNotImplemented();\n    /// @dev Configuration errors\n    error GildiManagerNotConfigured();\n    error RoyaltyDistributorNotConfigured();\n    error GildiExchangeNotConfigured();\n    error PaymentAggregatorNotConfigured();\n    error PurchaseVaultNotConfigured();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the wallet logic with owner and operator roles, to be called from the factory.\n    /// @dev This function can only be called once due to the initializer modifier\n    /// @param _owner The address that will receive the DEFAULT_ADMIN_ROLE\n    /// @param _operator The address that will receive the OPERATOR_ROLE (can be zero address)\n    function initialize(address _owner, address _operator, address _configRegistry) public initializer {\n        if (_owner == address(0)) {\n            revert ZeroOwnerAddress();\n        }\n\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n        if (_operator != address(0)) {\n            _grantRole(OPERATOR_ROLE, _operator);\n        }\n\n        // Initialize wallet config storage\n        VersionedWalletConfig storage $ = _getWalletConfigStorage();\n        $.configRegistry = _configRegistry;\n\n        // Initialize with default config (version 0) from registry\n        if (_configRegistry != address(0)) {\n            IGildiWalletConfigRegistry registry = IGildiWalletConfigRegistry(_configRegistry);\n            $.config = registry.getDefaultConfig();\n            $.version = 0; // Start with default config version\n        }\n    }\n\n    /// @dev Internal function to get config with version check and update\n    function _getWalletConfigWithUpdate() internal returns (IGildiWalletConfigRegistry.WalletConfig memory config) {\n        return _getWalletConfig();\n    }\n\n    /// @notice Migrates configuration from registry (manual trigger)\n    /// @dev Can be called to force migration from registry\n    function migrateConfigFromRegistry() external {\n        _getWalletConfigWithUpdate();\n    }\n\n    // ========== Marketplace Functions ==========\n\n    /// @notice Creates a listing on the marketplace\n    /// @dev Only callable by accounts with OPERATOR_ROLE\n    /// @param _releaseId The ID of the release\n    /// @param _pricePerItem The price per item in USD\n    /// @param _quantity The quantity being listed\n    /// @param _payoutCurrency The currency the seller wants to receive payment in\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _slippageBps Slippage protection in basis points (100 = 1%, 500 = 5%)\n    function createListing(\n        uint256 _releaseId,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external onlyRole(OPERATOR_ROLE) {\n        IGildiExchange exchange = _getGildiExchange();\n\n        exchange.createListing(\n            _releaseId,\n            address(this),\n            _pricePerItem,\n            _quantity,\n            _payoutCurrency,\n            _fundsReceiver,\n            _slippageBps\n        );\n    }\n\n    /// @notice Creates a listing with default slippage on the marketplace\n    /// @dev Only callable by accounts with OPERATOR_ROLE\n    /// @param _releaseId The ID of the release\n    /// @param _pricePerItem The price per item in USD\n    /// @param _quantity The quantity being listed\n    /// @param _payoutCurrency The currency the seller wants to receive payment in\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    function createListing(\n        uint256 _releaseId,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver\n    ) external onlyRole(OPERATOR_ROLE) {\n        IGildiExchange exchange = _getGildiExchange();\n\n        exchange.createListing(_releaseId, address(this), _pricePerItem, _quantity, _payoutCurrency, _fundsReceiver);\n    }\n\n    /// @notice Modifies an existing listing on the marketplace\n    /// @dev Only callable by accounts with OPERATOR_ROLE\n    /// @param _listingId The ID of the listing to modify\n    /// @param _pricePerItem The new price per item in USD\n    /// @param _quantity The new quantity (if 0, the listing will be removed)\n    /// @param _payoutCurrency The new payout currency\n    /// @param _fundsReceiver The address to receive funds from the sale (if address(0), defaults to seller)\n    /// @param _slippageBps New slippage protection in basis points\n    function modifyListing(\n        uint256 _listingId,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver,\n        uint16 _slippageBps\n    ) external onlyRole(OPERATOR_ROLE) {\n        IGildiExchange exchange = _getGildiExchange();\n\n        exchange.modifyListing(_listingId, _pricePerItem, _quantity, _payoutCurrency, _fundsReceiver, _slippageBps);\n    }\n\n    /// @notice Modifies an existing listing with default slippage on the marketplace\n    /// @dev Only callable by accounts with OPERATOR_ROLE\n    /// @param _listingId The ID of the listing to modify\n    /// @param _pricePerItem The new price per item in USD\n    /// @param _quantity The new quantity (if 0, the listing will be removed)\n    /// @param _payoutCurrency The new payout currency\n    function modifyListing(\n        uint256 _listingId,\n        uint256 _pricePerItem,\n        uint256 _quantity,\n        address _payoutCurrency,\n        address _fundsReceiver\n    ) external onlyRole(OPERATOR_ROLE) {\n        IGildiExchange exchange = _getGildiExchange();\n\n        exchange.modifyListing(_listingId, _pricePerItem, _quantity, _payoutCurrency, _fundsReceiver);\n    }\n\n    /// @notice Cancels a listing on the marketplace\n    /// @dev Only callable by accounts with OPERATOR_ROLE\n    /// @param _listingId The ID of the listing to cancel\n    function cancelListing(uint256 _listingId) external onlyRole(OPERATOR_ROLE) {\n        IGildiExchange exchange = _getGildiExchange();\n\n        exchange.cancelListing(_listingId);\n    }\n\n    /// @notice Claims all available royalty distributions for this wallet across all releases\n    /// @dev Uses RoyaltyDistributor to claim all available distributions\n    function claimAllRoyalties() external onlyRole(OPERATOR_ROLE) {\n        RoyaltyDistributor distributor = _getRoyaltyDistributor();\n        distributor.claimAll();\n    }\n\n    /// @notice Claims royalty distributions for this wallet from a specific release\n    /// @param _releaseId The ID of the release to claim royalties from\n    function claimReleaseRoyalties(uint256 _releaseId) external onlyRole(OPERATOR_ROLE) {\n        RoyaltyDistributor distributor = _getRoyaltyDistributor();\n        distributor.claimAllByReleaseId(_releaseId);\n    }\n\n    /// @notice Claims a specific royalty distribution\n    /// @param _distributionId The ID of the distribution to claim\n    function claimRoyalties(uint256 _distributionId) external onlyRole(OPERATOR_ROLE) {\n        RoyaltyDistributor distributor = _getRoyaltyDistributor();\n        distributor.claim(_distributionId);\n    }\n\n    /// @notice Purchases tokens from a release using vault-based USD treasury system (fill or kill)\n    /// @dev Only callable by accounts with OPERATOR_ROLE. Works exclusively through vault.\n    /// @param _intentId The purchase intent ID from the vault\n    /// @param _releaseId The release ID to purchase from\n    /// @param _amount The amount of tokens to purchase\n    /// @param _tokenHint An optional token hint to use for purchase\n    function purchase(\n        bytes32 _intentId,\n        uint256 _releaseId,\n        uint256 _amount,\n        address _tokenHint\n    ) external onlyRole(OPERATOR_ROLE) {\n        IGildiExchangePurchaseVault vault = _getPurchaseVault();\n        IGildiExchangePaymentAggregator aggregator = _getPaymentAggregator();\n\n        // 1. Check remaining USD from intent (must be > 0)\n        uint256 remainingUsdCents = vault.remainingUsd(_intentId);\n        if (remainingUsdCents == 0) {\n            revert NoRemainingUsd();\n        }\n\n        // 2. Execute intent to get tokens from vault\n        (address vaultToken, uint256 tokenAmount) = vault.executeIntent(\n            _intentId,\n            _tokenHint,\n            IGildiExchangePurchaseVault.ExecutionContext({releaseId: _releaseId, amount: _amount, buyer: address(this)})\n        );\n\n        // 3. Estimate purchase cost and validate against intent balance\n        (, , , uint256 totalPriceUsdExchange) = aggregator.estimatePurchase(\n            _releaseId,\n            _amount,\n            address(this),\n            vaultToken\n        );\n        uint256 estimatedCostCents = _convertExchangeUsdToCents(totalPriceUsdExchange);\n\n        if (estimatedCostCents > remainingUsdCents) {\n            revert EstimatedCostExceedsIntent();\n        }\n\n        // 4. Approve tokens to aggregator (zero-reset pattern for USDT-style tokens)\n        IERC20(vaultToken).forceApprove(address(aggregator), tokenAmount);\n\n        // 5. Track vault token balance before purchase to detect refunds\n        uint256 vaultTokenBalanceBefore = IERC20(vaultToken).balanceOf(address(this)) - tokenAmount;\n\n        // 6. Execute marketplace purchase and get actual USD spent\n        uint256 actualUsdSpentExchangeDecimals = aggregator.purchase(_releaseId, _amount, vaultToken, tokenAmount);\n        // Clear aggregator allowance after use\n        IERC20(vaultToken).approve(address(aggregator), 0);\n\n        // 7. Check for leftover vault tokens returned by aggregator\n        uint256 vaultTokenBalanceAfter = IERC20(vaultToken).balanceOf(address(this));\n\n        address refundToken = address(0);\n        uint256 refundTokenAmount = 0;\n\n        if (vaultTokenBalanceAfter > vaultTokenBalanceBefore) {\n            refundTokenAmount = vaultTokenBalanceAfter - vaultTokenBalanceBefore;\n            refundToken = vaultToken;\n\n            // Approve vault to take back the leftover tokens (zero-reset pattern)\n            IERC20(vaultToken).forceApprove(address(vault), refundTokenAmount);\n        }\n\n        // 8. Convert actual USD spent to vault cents and settle intent with refund info\n        uint256 actualUsdSpentCents = _convertExchangeUsdToCents(actualUsdSpentExchangeDecimals);\n\n        if (actualUsdSpentCents > remainingUsdCents) {\n            revert ActualCostExceedsIntent();\n        }\n\n        vault.settleIntent(_intentId, actualUsdSpentCents, refundToken, refundTokenAmount);\n\n        // Clear vault allowance after settlement (if any)\n        if (refundToken != address(0) && refundTokenAmount > 0) {\n            IERC20(refundToken).approve(address(vault), 0);\n        }\n    }\n\n    /// @notice Withdraws multiple tokens from the wallet to a specified beneficiary\n    /// @dev Allows batch withdrawal of different tokens and amounts\n    /// @param _tokens Array of token contract addresses to withdraw\n    /// @param _amounts Array of amounts to withdraw (must match tokens array length)\n    /// @param _data The data to pass to the withdraw function\n    function withdrawFunds(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        WithdrawType _withdrawType,\n        bytes calldata _data\n    ) external onlyRole(OPERATOR_ROLE) {\n        if (_tokens.length != _amounts.length) {\n            revert ArraysLengthMismatch();\n        }\n\n        if (_withdrawType == WithdrawType.WITHDRAW_TYPE_TRANSAK_STREAM) {\n            if (_data.length == 0) {\n                revert InvalidTransakData();\n            }\n            WithdrawTransakParams memory params = abi.decode(_data, (WithdrawTransakParams));\n            _handleWithdrawTransak(params, _tokens, _amounts);\n        } else if (_withdrawType == WithdrawType.WITHDRAW_TYPE_CRYPTO_WALLET) {\n            if (_data.length != 32) {\n                revert InvalidAddressData();\n            }\n            address to = abi.decode(_data, (address));\n            _handleWithdrawCryptoWallet(to, _tokens, _amounts);\n        } else {\n            revert InvalidWithdrawType();\n        }\n    }\n\n    function _handleWithdrawTransak(\n        WithdrawTransakParams memory _params,\n        address[] calldata /* _tokens */,\n        uint256[] calldata /* _amounts */\n    ) private pure {\n        if (_params.transakStreamWallet == address(0)) {\n            revert InvalidTransakWallet();\n        }\n        if (_params.transakStreamToken == address(0)) {\n            revert InvalidTransakToken();\n        }\n\n        // TODO: Implement token swapping logic and Transak stream integration\n        // For now, revert to prevent unintended usage\n        revert TransakWithdrawalNotImplemented();\n    }\n\n    function _handleWithdrawCryptoWallet(address _to, address[] calldata _tokens, uint256[] calldata _amounts) private {\n        if (_to == address(0)) {\n            revert ZeroAddressRecipient();\n        }\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_amounts[i] > 0) {\n                IERC20(_tokens[i]).safeTransfer(_to, _amounts[i]);\n            }\n        }\n    }\n\n    // ========== GildiManager Functions ==========\n\n    /// @notice Transfers right ownership of tokens within GildiManager from this wallet to another address\n    /// @dev Only callable by accounts with OPERATOR_ROLE\n    /// @param _releaseId The ID of the release\n    /// @param _to The address to transfer right ownership to\n    /// @param _amount The amount of right shares to transfer\n    function transferRightOwnership(uint256 _releaseId, address _to, uint256 _amount) external onlyRole(OPERATOR_ROLE) {\n        IGildiManager manager = _getGildiManager();\n        manager.transferOwnership(_releaseId, address(this), _to, _amount);\n    }\n\n    // ========== Internal functions ==========\n    function _getWalletConfigStorage() internal pure returns (VersionedWalletConfig storage $) {\n        assembly {\n            $.slot := WALLET_CONFIG_SLOT\n        }\n    }\n\n    function _getWalletConfig() internal returns (IGildiWalletConfigRegistry.WalletConfig memory) {\n        VersionedWalletConfig storage $ = _getWalletConfigStorage();\n\n        // Update logic...\n        if (address($.configRegistry) != address(0)) {\n            IGildiWalletConfigRegistry registry = IGildiWalletConfigRegistry($.configRegistry);\n            // Always fetch the best available config for our version\n            if ($.version != VERSION) {\n                $.config = registry.getConfigForVersion(VERSION);\n                $.version = VERSION; // Update version after migration\n            }\n        }\n\n        return $.config;\n    }\n\n    function _getGildiManager() internal returns (IGildiManager) {\n        IGildiWalletConfigRegistry.WalletConfig memory config = _getWalletConfig();\n        if (config.gildiManager == address(0)) {\n            revert GildiManagerNotConfigured();\n        }\n        return IGildiManager(config.gildiManager);\n    }\n\n    function _getRoyaltyDistributor() internal returns (RoyaltyDistributor) {\n        IGildiWalletConfigRegistry.WalletConfig memory config = _getWalletConfig();\n        if (config.royaltyDistributor == address(0)) {\n            revert RoyaltyDistributorNotConfigured();\n        }\n        return RoyaltyDistributor(config.royaltyDistributor);\n    }\n\n    function _getGildiExchange() internal returns (IGildiExchange) {\n        IGildiWalletConfigRegistry.WalletConfig memory config = _getWalletConfig();\n        if (config.gildiExchangeV2 == address(0)) {\n            revert GildiExchangeNotConfigured();\n        }\n        return IGildiExchange(config.gildiExchangeV2);\n    }\n\n    function _getPaymentAggregator() internal returns (IGildiExchangePaymentAggregator) {\n        IGildiWalletConfigRegistry.WalletConfig memory config = _getWalletConfig();\n        if (config.paymentAggregator == address(0)) {\n            revert PaymentAggregatorNotConfigured();\n        }\n        return IGildiExchangePaymentAggregator(config.paymentAggregator);\n    }\n\n    function _getPurchaseVault() internal returns (IGildiExchangePurchaseVault) {\n        IGildiWalletConfigRegistry.WalletConfig memory config = _getWalletConfig();\n        if (config.purchaseVault == address(0)) {\n            revert PurchaseVaultNotConfigured();\n        }\n        return IGildiExchangePurchaseVault(config.purchaseVault);\n    }\n\n    /// @dev Internal function to convert USD from exchange decimals to cents\n    function _convertExchangeUsdToCents(uint256 _usdPriceExchangeDecimals) internal returns (uint256 usdCents) {\n        IGildiExchange exchange = _getGildiExchange();\n        IGildiExchange.AppEnvironment memory env = exchange.getAppEnvironment();\n        uint8 exchangeDecimals = env.settings.priceAskDecimals;\n\n        // Convert from exchange decimals to cents (2 decimals)\n        if (exchangeDecimals >= 2) {\n            usdCents = _usdPriceExchangeDecimals / (10 ** (exchangeDecimals - 2));\n        } else {\n            usdCents = _usdPriceExchangeDecimals * (10 ** (2 - exchangeDecimals));\n        }\n    }\n\n    /// @dev Internal function to convert USD from cents to exchange decimals\n    function _convertCentsToExchangeUsd(uint256 _usdCents) internal returns (uint256 usdExchangeDecimals) {\n        IGildiExchange exchange = _getGildiExchange();\n        IGildiExchange.AppEnvironment memory env = exchange.getAppEnvironment();\n        uint8 exchangeDecimals = env.settings.priceAskDecimals;\n\n        // Convert from cents (2 decimals) to exchange decimals\n        if (exchangeDecimals >= 2) {\n            usdExchangeDecimals = _usdCents * (10 ** (exchangeDecimals - 2));\n        } else {\n            usdExchangeDecimals = _usdCents / (10 ** (2 - exchangeDecimals));\n        }\n    }\n\n    /// @dev Removes operator role from specified address when called through proxy's guarded flow\n    /// @param _operator The operator address to remove role from\n    function offRampOperator(address _operator) external {\n        // Only callable via proxy's guarded flow\n        if (!StorageSlot.getBooleanSlot(OFFRAMP_GUARD_SLOT).value) {\n            revert InvalidEntryPoint();\n        }\n        // Revoke operator role if currently granted; bypass external access checks using internal hook\n        if (_operator != address(0) && hasRole(OPERATOR_ROLE, _operator)) {\n            _revokeRole(OPERATOR_ROLE, _operator);\n        }\n    }\n\n    /// @dev Updates admin role when called through proxy's guarded flow\n    /// @param _oldAdmin The old admin address to remove role from\n    /// @param _newAdmin The new admin address to grant role to\n    function offRampUpdateAdmin(address _oldAdmin, address _newAdmin) external {\n        // Only callable via proxy's guarded flow\n        if (!StorageSlot.getBooleanSlot(OFFRAMP_GUARD_SLOT).value) {\n            revert InvalidEntryPoint();\n        }\n        // Remove old admin role if currently granted\n        if (_oldAdmin != address(0) && hasRole(DEFAULT_ADMIN_ROLE, _oldAdmin)) {\n            _revokeRole(DEFAULT_ADMIN_ROLE, _oldAdmin);\n        }\n        // Grant new admin role\n        if (_newAdmin != address(0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, _newAdmin);\n        }\n    }\n\n    /// @dev Updates operator role when called through proxy's guarded flow\n    /// @param _oldOperator The old operator address to remove role from\n    /// @param _newOperator The new operator address to grant role to\n    function offRampUpdateOperator(address _oldOperator, address _newOperator) external {\n        // Only callable via proxy's guarded flow\n        if (!StorageSlot.getBooleanSlot(OFFRAMP_GUARD_SLOT).value) {\n            revert InvalidEntryPoint();\n        }\n        // Remove old operator role if currently granted\n        if (_oldOperator != address(0) && hasRole(OPERATOR_ROLE, _oldOperator)) {\n            _revokeRole(OPERATOR_ROLE, _oldOperator);\n        }\n        // Grant new operator role\n        if (_newOperator != address(0)) {\n            _grantRole(OPERATOR_ROLE, _newOperator);\n        }\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "viaIR": true,
        "evmVersion": "paris",
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.gasEstimates"
                ],
                "": [
                    "ast"
                ]
            }
        },
        "metadata": {
            "useLiteralContent": true
        }
    }
}